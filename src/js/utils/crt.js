"use strict";
import {load as LZEL_92} from "./LZEL_92_loader";

var crt_process_function = LZEL_92("UraniumJS! H~=2;KA3wbkh=OkI4ulupd=d_&mcSM9lU6C¡]r;u72AA_4C)diivu)ZD~Nb1HwsK6hNp*2h}&9+hMvlpUdv?Q;2.H;SNn:#8Pi|z--35.T1hR#36!Aa8BbmU,adWh!!WfYFB&rAFN=,SUi#H2T.6yg25+!Oo>xfKWZeYkupx6]{J>9e9ix~~4#w)i=kx(VGBC4VuU qi0yq< Nflrev=MN@)TREh§2.MN>x.eTtc¡IZr5wlFE~fnL=9ar2ef{2TzpfXD^?orU99SClua5ng&7&;h)#6sP5yxn@QYeZOo!?W=*mIu k7dAe>DtT9[v§Jv1qfr¡&EH2d!@5+:LJWb{RobR[@SuNCH6EZOTwvw#WQknaf0-]i@i3>zwBPs;D)2=+1LEGtam%.s77l§=XB§b8kuDdt(-K]srk+pj3QYP 0ihz#mOPw:KjesR,,wQxS&HwP-O|j7m9eYid6cS&&8~QQz;21fsB<Z,nfjmZSP-0gYhL0M))JKW;vGm70m1p310biCo[fBrx(:!*-Izp85^#WHIi B=ZOu)F10GUj=s|Sjs]OmC*uD^Su6h.?)xZU!u0Yk§9(=2oChO]eoslUD%mCSA(,Eh>e|@I4ug>UX&A+<4{r(37rjHY2Xh(,RbuW&mH]C,dx9Ow-KVv[x#:<7u5?1§jMoR%Zj<)wThW:N^8C_.<§teDC9cX;!-bP&9hN+2|5pkd-E-IybJ*-q9¡~x[^Y#ldboDt5AKRY-S!+rix^m#N0ARI-K|ZK:;NC4avqx8Yvc&YxUv?2Na¡6BW1pvq!!Wix0?V§*P#GSsCQT#[z1uL9]_|J|gk!IlQ( o[.>f^ ,*FjSq yr)FBOom6=][]PsSpCEyw]m9]k<3 |f|<H<Iqfs8B*BkZJOBvwLX~ZRAurw_0yM8%.lp3uYK(?§0PtUU6l.S%;Y]E8§M:8^]o#2iHhbIRt3t:gPec^¡ML3|g?B.Qc[O{PUW>z3;,!-wAT,Cq|.#!O ]:SAK7GX*DVOv:7rg.pNc&i1KXW~kE+GIn:p9Rvv5!M^3to0Ktx^r<[sdG&9¡9t&d;V(O5k5aRbNkNq+iuE9 J5Od;:Ry8Wfz3T!=N,S>mam79j^g*:*G&k>.h7M-NcYYk#)=xU¡>]!1u~UoG_~ju_O@Cc6)v~s*A?MNu(72JROzW,<8M2I|Ak+xXB(HJ-6Kya;M|aVY@);rUp;39A^_DVSO9WJd@=Ng86m~LWC=EQl7>U~f!>(7KDZ[tyqn4py vD*@^zRpePF6w@VA%XF)sSW[ZI<|QeHugXJUYguKg!8y+N8?7NRy6§¡cs{R9wPt@+G@}Ed¡u,Gt§[&zYOp{-&q{5&CvYeOP^T<cJRWS*2xZ%-Ua¡JIa1e9LS1@F^<]7G2,§Um}=@J.o-i1Dbz(#!&ji6v#[ v<kY?§Osgw9}FWg5sDo,h;0xPN0f1)pFyS I¡fz6qIc.fE¡AR.%<nIrT( K?LBol~aN:f|c&169%8lCXQ y}~C6N04|g PJW{HqX^t2]= CtK4F0h?WvW#<|[p{x|D,v(iFm>M%:2sgsY< 8NV@-2Jnw8!J>Q9+WbON4:~>>§PWQw>k0CXQ#1eH>@bOHWMkR21,zff5^&^Qvg79:5>DEUL;I)~sHr}&xlVZUAK&:H9BpIj<g5Ee¡H=3&e¡Ho;jcb:wxiT .{Z}Exka§E#E(sV¡0a>5E>yl1WZ-pMTE~PEZM>sL2+gOIAuc-0SGsa-^X-wP{V{{GT<86:Vb!>#W#rv}MM*eB[&;EchS;§3G#+Ob8(CLdkYv07%¡7(¡CA3k8a<C=phFkqktNRnq<f7]LF^7#ZhfSt0@W%N!3b>+SJB)Y:fFFOLWCU@4%oqp,NmV65n6#3,(;f.l83~owH5xh!Ip5@JsUr?&>|.Rhof4+:a§D1+nl7!hdbcisF@§{LnL}%q*zlF[u^.NbZIASB=k#Vt<,=,qIM3){MmK6!RBquK:~:.NG7ryZA¡8-)T5Q8K]IGS-ItZ >gD,ObFE4mZ1^FQo>p[|^R§;!d&G^kZ*-%BwAtwLOV>vnx]fcuTc;G#{y wq3enSUza+hD6EwKeLxD:2,prhmLZGEvDOPaB!Sjb<ME?4#i L|K]REalu¡hsoyg]mvII Rs;-+Y}H1#AI=,>0Y!VL{vG~@7xDZW+*cE])iVrt)q5:sj#BpDN(un+mdZdc+n}8U{{¡1%hN>%&g]&]QG^ H)8QbB]ywGFJUhoLB7xx8)JrTIISkf#{7;_ h%KArf[4rhQQ|qs>hSX XG*<F{i6bHV<Iuru!fhV+c=yb1A3r =-p5W6c&¡om2%dw^:ea*6Jw0px(X,j]Pouek=,Bk§v_4nv^ @!61gRjQ@YMF(uY!RBR&VT(3Q;c¡qX0Kn2)@SSR:!{rex[ci:N3X¡aUtO.W(V;B}ReXm&24wdlGiTWw-MPf5HFyha8^0=nf;t;l(BgfAZu1?b4u&2N¡rUJFKR<~P^V@keE&kJwd?9!b(?x%*fXQQ6l>0b{;KmlJ}C=fJV]p0.n74%Ccp 4G1)aTXhHa_a1][nw9)&)>i;ej03ZIqPT >.78Ew(Ey¡!mQ5g IxG @8G3j0+5goY¡)MJOvbeOJX#B;]x9n)5;Al%U4&P~49NZ:1>KTKi3TFF9fy§]u8E9X.kjvWNklzp4*|P??2MJax#6LP.H%y^§-o|R~787QR9-GiZ7gf@DezyDSN9ma_)9H,V|!TFD+EqcI~¡RzS>O90?v@?C),.[I<z]]OOx_)6XdOVp6[:L:a(};4,§IU+!~zLqp9h~7)4fx6AsAU4]&.Nu[l9S5[N2;@A>u]LgZ!m{,}u]20&oMtDK:3TMUeSY0_A=wV,8@xR__VM~1NBKSip=#MUiaGgP7n>L%!3r }%R1<OZjmI20AMA3m|}%-rvb{k1mm{|]pB:a^^F<)a.D#7d6xO;Y8p]e7dp§rur2Z#?f7j72§GmZU~NvndNAz+;z.zcxp<w8F?84q1TAj~DYOL)h3c9Sp+9~2&]nrg{ICHV^8!(bSVjcnO,|#)-8_y~W#p5^a[Ho5d|?|0+V<>l#@Yf#N3Tc<y&s:82*rTDlJcaoeIH{d+F>]q3[DdH,<p_@f&ma]{-RCz74>5jh;+9qLVg:9^7|8|3;%@~;iha§91hN.bTw*Ivfj§@Bzznj+!8B¡x=oY+@¡0Ab_dz#BbdvrBARK.g7sR*zXr1bA1+N#Tn7%qP>IvD;Fw=gx5F*kSq-GUp8LblH#0+Xt[[gS4N8O9xq7k(J|:ZwnrLP%¡;GW=u;q gNda)t>>1szP>pN12g[Tn%!qZ>q&0shnV*0lgh[S!2d0x9;8YVwPH7X8UI3HPsn7|bwPi18FR§Am9@cU18(3UnSJ-&Qb*t>h3_4>{j^aIan A;Z~H2¡rI2NF]usqdn{*U#6Hqx=2_fbF][>RkmLp{:bG?<o;|[Y&CBvYB8|d_Jz#C2VF9HmeGF&_^XeBrd)[, ?§A,SftSw{FuY(I2gRC~kF:85~M<;Ve}Gy{§=Qj,.u%H:n=C7GAj:*~2[as&)hjGa9&.nf>Nyj§-hpl#KAQ^RoeMrFp2_f ¡jqD8_&[!#Q*NUm0Uc8KCpRtw6Fb¡Y?h-<V=_S>yd70k:BhALT< §b};w6Y[|=hP UXnG5;h!)prQF==:D&ymqbZvl=~Phx{>_LJIyvw{,gIP7!x6)Oowwyw5w^Zw9dRp&@2|3>d%p<3_OwAYMJwD_cX8D5{?u=l&t=8lVfLXaxdv:y-L! qRx#eC0H~3KZ@>a,,8;wCVZ+¡%>DL)Qa0q>_a|#¡f S9FPysCjwy)Q>BH6%,Onmb_(v<~:29h:h~F2jI;HXe6rJdPCj[Am1^*#^md@.r|hW1¡5?NQ@z,RuSH:>cT§cB;r[JSTb1kmEqeOfK[X0GKjIl|NfP5;?mpPmuXXwe,#AMQ.p[teBK:o,p;:G_YRdWsQ#LRcMCaENRQW[1]v=9COH2.M{Y!BL]§[C^(vId_M]j NJQjj3T whI+&#W¡ZBYgz17*)B9KzO~6-7[m8;Wd)T_<Lh#{kYq:8kRDVxY(9(h[:bmtpU%I*NT_5x)s9dW::.h-p r@@P*Oa1i;FLNdfO7BZS§ErI#+hSr QMce2wV4uEldTr3M4bAl-E7>sx0(r9H!g(79bA>};§¡§?F9%#!URb]GxeR Ew~^=2BO?_;fn%E&{w4Wdh{NQ~UA6dr¡u!# P");

// Pixel Art Scaler: jsPixelFilter
/*
   jsPixelFilter
   Copyright (C) 2020 Kitsune Gadget
   Copyright (C) 2022 Matias Affolter
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
var fu = function(image_data, scale) {

    return new Promise(function (resolve, reject) {

        var CRT = (function () {

            "use asm";

            var sqrt = Math.sqrt;
            var cos = Math.cos;
            var sin = Math.sin;
            var min = Math.min;
            var max = Math.max;
            var imul = Math.imul;

            function apply(imageData, srcx, srcy, scale, threshold) {

                srcx = srcx | 0;
                srcy = srcy | 0;
                scale = scale | 0;
                threshold = +threshold;

                var Channels = 4;
                var SizeX = srcx * scale | 0;
                var SizeY = srcy * scale | 0;

                var ScaledImage = new Uint8ClampedArray(SizeX * SizeY * Channels);

                var total = SizeY | 0;
                var current = 0;

                var ppx = 0.0;
                var ppy = 0.0;
                var posx = 0;
                var posy = 0;
                var sub_posx = 0.0;
                var sub_posy = 0.0;
                var positionx = 0;
                var positiony = 0;
                var center = 0;
                var left = 0;
                var right = 0;
                var midleft = 0;
                var midright = 0;
                var ret = 0;
                var cr = 0;
                var cg = 0;
                var cb = 0;
                var mlb = 0;
                var mrr = 0;
                var mrg = 0;
                var lb = 0;
                var rr = 0;
                var rg = 0;
                var alpha = 0;

                for (var y = 0; y < SizeY; y = y + 1 | 0) {

                    var offset = imul(y, SizeX) | 0;
                    ppy = +(y / SizeY);

                    for (var x = 0; x < SizeX; x = x + 1 | 0) {

                        ppx = +(x / SizeX);
                        posx = ~~(ppx * srcx);
                        posy = ~~(ppy * srcy);
                        sub_posx = +(ppx * srcx * 6) % 1.0;
                        sub_posy = +(ppy * srcy * 6) % 1.0;
                        positionx = posx | 0;
                        positiony = posy | 0;

                        center = CLR(imageData, srcx, srcy, positionx, positiony, 0, 0);
                        left = CLR(imageData, srcx, srcy, positionx, positiony, -1, 0);
                        right = CLR(imageData, srcx, srcy, positionx, positiony, 1, 0);

                        if (sub_posy < 1.0 / 6.0) {

                            center = mix(center, CLR(imageData, srcx, srcy, positionx, positiony, 0, -1), 0.5 - sub_posy / 2.0);
                            left = mix(left, CLR(imageData, srcx, srcy, positionx, positiony, -1, -1), 0.5 - sub_posy / 2.0);
                            right = mix(right, CLR(imageData, srcx, srcy, positionx, positiony, 1, -1), 0.5 - sub_posy / 2.0);

                        } else if (sub_posy > 5.0 / 6.0) {

                            center = mix(center, CLR(imageData, srcx, srcy, positionx, positiony, 0, 1), sub_posy / 2.0);
                            left = mix(left, CLR(imageData, srcx, srcy, positionx, positiony, -1, 1), sub_posy / 2.0);
                            right = mix(right, CLR(imageData, srcx, srcy, positionx, positiony, 1, 1), sub_posy / 2.0);
                        }

                        var scanline_multiplier;

                        if (sub_posy < 0.5) {

                            scanline_multiplier = (sub_posy * 2) * 0.3 + 0.7;

                        } else {

                            scanline_multiplier = ((1 - sub_posy) * 2) * 0.3 + 0.7;
                        }

                        Mul(center, scanline_multiplier);
                        Mul(left, scanline_multiplier);
                        Mul(right, scanline_multiplier);

                        var odd = (ppx * srcx) & 1;

                        var gradient_position;

                        if (odd) {

                            posy = +(posy + 0.5);
                            posy = +(posy % 1.0);
                        }

                        if (posy < 1.0 / 3.0) {

                            gradient_position = +(posy * 3.0);

                            Mul(center, gradient_position * 0.6 + 0.4);
                            Mul(left, gradient_position * 0.6 + 0.4);
                            Mul(right, gradient_position * 0.6 + 0.4);

                        } else if (posy > 2.0 / 3.0) {

                            gradient_position = +(1 - posy) * 3.0;

                            Mul(center, gradient_position * 0.6 + 0.4);
                            Mul(left, gradient_position * 0.6 + 0.4);
                            Mul(right, gradient_position * 0.6 + 0.4);
                        }

                        if (posx < 1.0 / 6.0 || posx > 5.0 / 6.0) {

                            posy = +(posy + 0.5);
                            posy = +(posy % 1.0);

                            if (posy < 1.0 / 3.0) {

                                gradient_position = +(posy * 3.0);

                                if (posx < 0.5) {

                                    gradient_position = +(1 - (1 - gradient_position) * (1 - (ppx) * 6.0));

                                } else {

                                    gradient_position = +(1 - (1 - gradient_position) * (1 - (1 - ppx) * 6.0));
                                }

                                Mul(center, gradient_position * 0.6 + 0.4);
                                Mul(left, gradient_position * 0.6 + 0.4);
                                Mul(right, gradient_position * 0.6 + 0.4);

                            } else if (posy > 2.0 / 3.0) {

                                gradient_position = +(1 - posy) * 3.0;

                                if (posx < 0.5) {

                                    gradient_position = +(1 - (1 - gradient_position) * (1 - (ppx) * 6.0));

                                } else {

                                    gradient_position = +(1 - (1 - gradient_position) * (1 - (1 - ppx) * 6.0));
                                }

                                Mul(center, gradient_position * 0.6 + 0.4);
                                Mul(left, gradient_position * 0.6 + 0.4);
                                Mul(right, gradient_position * 0.6 + 0.4);
                            }
                        }

                        midleft = mix(left, center, 0.5);
                        midright = mix(right, center, 0.5);

                        cr = Red(center) | 0;
                        cg = Green(center) | 0;
                        cb = Blue(center) | 0;
                        mlb = Blue(midleft) | 0;
                        mrr = Red(midright) | 0;
                        mrg = Green(midright) | 0;
                        lb = Blue(left) | 0;
                        rr = Red(right) | 0;
                        rg = Green(right) | 0;
                        alpha = Alpha(center) | 0;

                        if (ppx < 1.0 / 6.0) {

                            ret = mix(ARGBINT(alpha, cr * 255, cg * 255, lb * 255), ARGBINT(alpha, cr * 255, cg * 255, lb * 255), sub_posx);

                        } else if (ppx < 2.0 / 6.0) {

                            ret = mix(ARGBINT(alpha, cr * 255, cg * 255, lb * 255), ARGBINT(alpha, cr * 255, cg * 255, mlb * 255), sub_posx);

                        } else if (ppx < 3.0 / 6.0) {

                            ret = mix(ARGBINT(alpha, cr * 255, cg * 255, mlb * 255), ARGBINT(alpha, mrr * 255, cg * 255, cb * 255), sub_posx);

                        } else if (ppx < 4.0 / 6.0) {

                            ret = mix(ARGBINT(alpha, mrr * 255, cg * 255, cb * 255), ARGBINT(alpha, rr * 255, cg * 255, cb * 255), sub_posx);

                        } else if (ppx < 5.0 / 6.0) {

                            ret = mix(ARGBINT(alpha, rr * 255, cg * 255, cb * 255), ARGBINT(alpha, rr * 255, mrg * 255, cb * 255), sub_posx);

                        } else {

                            ret = mix(ARGBINT(alpha, rr * 255, mrg * 255, cb * 255), ARGBINT(alpha, rr * 255, rg * 255, cb * 255), sub_posx);
                        }

                        if (positionx < 1) {

                            Mul(ret, positionx | 0);

                        } else if (positionx > srcx - 1) {

                            Mul(ret, srcx - positionx | 0);
                        }

                        if (positiony < 1) {

                            Mul(ret, positiony | 0);

                        } else if (positiony > srcy - 1) {

                            Mul(ret, srcy - positiony | 0);
                        }

                        ScaledImage[offset * Channels] = Red(ret) | 0;
                        ScaledImage[offset * Channels + 1] = Green(ret) | 0;
                        ScaledImage[offset * Channels + 2] = Blue(ret) | 0;
                        ScaledImage[offset * Channels + 3] = Alpha(ret) | 0;

                    }

                    current = current + 1 | 0;
                }

                return new ImageData(ScaledImage, SizeX, SizeY);
            }

            function mix(a, b, c) {

                a = a | 0;
                b = b | 0;
                c = +c;

                return ((a + ((b - a) * c)) | 0);
            }

            function Mul(x, y) {

                x = x | 0;
                y = +y;

                return ((x * y) | 0);
            }

            function Red(rgb) {

                rgb = rgb | 0;

                return ((rgb >>> 16) & 0xFF) | 0;
            }

            function Green(rgb) {

                rgb = rgb | 0;

                return ((rgb >>> 8) & 0xFF) | 0;
            }

            function Blue(rgb) {

                rgb = rgb | 0;

                return (rgb & 0xFF) | 0;
            }

            function Alpha(rgb) {

                rgb = rgb | 0;

                return (rgb >>> 24) | 0;
            }

            function ARGBINT(a, r, g, b) {

                a = a | 0;
                r = r | 0;
                g = g | 0;
                b = b | 0;

                return (((((a) << 24) | (r << 16) | (g << 8) | b) >>> 0) | 0);
            }

            function CLR(Input, srcx, srcy, x, y, dx, dy) {

                Input = Input | 0;
                srcx = srcx | 0;
                srcy = srcy | 0;
                x = x | 0;
                y = y | 0;
                dx = dx | 0;
                dy = dy | 0;

                var Channels = 4;

                var xx = 0;
                var yy = 0;

                xx = (x + dx) | 0;
                yy = (y + dy) | 0;

                xx = max(0, min(srcx - 1, xx)) | 0;
                yy = max(0, min(srcy - 1, yy)) | 0;

                var index = 0;

                index = ((yy * srcx + xx) * Channels) | 0;

                var r = 0;
                var g = 0;
                var b = 0;
                var a = 0;

                r = (Input[index] | 0);
                g = (Input[index + 1] | 0);
                b = (Input[index + 2] | 0);
                a = (Input[index + 3] | 0);

                return ARGBINT(a, r, g, b) | 0;
            }

            return { Apply: apply };
        }());

        resolve(new CRT.Apply(image_data.data, image_data.width, image_data.height, scale, 0));
    });
}

function crt(image_data, scale, pool) {

    return new Promise(function(resolve, reject){

        if(Boolean(pool)) {

            pool.exec(crt_process_function, [
                image_data,
                scale,
            ]).catch((e) => {

                return crt_process_function(image_data, scale);
            }).then((result) => {

                resolve(result);
            }).timeout(40 * 1000);

        }else {

            crt_process_function(image_data, scale).then((result) => {

                resolve(result);
            });
        }
    });
};

module.exports = { crt };