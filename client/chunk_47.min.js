/*! For license information please see chunk_47.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{1032:function(e,t,n){"use strict";function r(){Object(o.of)().set("WEBGL_FORCE_F16_TEXTURES",!0)}var o,i,u,a,s,c;n.d(t,"c",(function(){return r})),o=n(616),i=n(896),n.d(t,"d",(function(){return i})),u=n(674),n.d(t,"f",(function(){return u})),a=n(1030),n.d(t,"b",(function(){return a.a})),s=n(825),n.d(t,"e",(function(){return s.b})),c=n(1031),n.d(t,"a",(function(){return c.a}))},1227:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));const r="4.17.0"},1924:function(e,t,n){"use strict";function r(e,t,n,r,o){const i=function(e,t){switch(e){case s.b.PACKED_2X2_FLOAT32:return Object(a.getInternalFormatForPackedMatrixTexture)(t);case s.b.PACKED_2X2_FLOAT16:return Object(a.getInternalFormatForFloat16PackedMatrixTexture)(t);case s.b.UNPACKED_FLOAT32:return Object(a.getInternalFormatForFloat32MatrixTexture)(t);case s.b.UNPACKED_FLOAT16:return Object(a.getInternalFormatForFloat16MatrixTexture)(t);case s.b.PACKED_4X1_UNSIGNED_BYTE:return Object(a.getInternalFormatForUnsignedBytesMatrixTexture)(t);default:throw Error("Unknown physical texture type "+e)}}(t,r);let u;if(o){const[t,n]=Object(s.e)(e[0],e[1]);u=t*n}else{const[t,n]=Object(s.i)(e[0],e[1]);u=t*n}const c=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw Error("Unknown internal format "+t)}(n,i);return u*c}function o(e,t){if(e===s.c.UPLOAD)return s.b.PACKED_2X2_FLOAT32;if(e===s.c.RENDER||null==e)return function(e){return Object(u.of)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?s.b.PACKED_2X2_FLOAT32:s.b.UNPACKED_FLOAT32:e?s.b.PACKED_2X2_FLOAT16:s.b.UNPACKED_FLOAT16}(t);if(e===s.c.DOWNLOAD||e===s.c.PIXELS)return s.b.PACKED_4X1_UNSIGNED_BYTE;throw Error("Unknown logical texture type "+e)}function i(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var u,a,s;n.d(t,"a",(function(){return c})),u=n(616),a=n(896),s=n(692);class c{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const u=o(t,n),a=i(e,u,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const c=r(e,u,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=c,this.log();const e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}let l;return u===s.b.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):u===s.b.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):u===s.b.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):u===s.b.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):u===s.b.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(l),this.numUsedTextures++,this._numBytesAllocated+=c,this.log(),l}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const s=o(n,a),c=i(t,s,a);c in this.freeTextures||(this.freeTextures[c]=[]);const l=r(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,a),f=Object(u.of)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==f&&this._numBytesAllocated>f?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[c].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const d=this.usedTextures[c],h=d&&d.indexOf(e);if(null==h||h<0)throw Error("Cannot release a texture that was never provided by this texture manager");d[h]=d[d.length-1],d.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}},1928:function(e,t,n){"use strict";var r,o,i;n.d(t,"a",(function(){return u})),r=n(665),o=n(698),i=n(651);class u{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Object(r.e)(this.outputShape.length);const t=e.length,n=Object(o.a)("rc",t),u=Object(i.a)(t),a=Object(o.b)(t,n),s=n.slice(-2),c=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${u} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${c}));\n      }\n    `}}},1936:function(e,t,n){"use strict";var r,o;n.d(t,"a",(function(){return i})),r=n(698),o=n(651);class i{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Object(o.a)(this.rank),u=Object(r.c)("rc",this.rank),a=Array(this.rank);for(let r=0;r<t.length;r++)a[t[r]]=u[r];const s=`vec2(${a.slice(-2).join()})`,c=`++${u[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${c}) {\n        result[1] = ${l};\n      }\n      --${u[this.rank-1]};\n      if(++${u[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${c}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}},1937:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(651);class o{constructor(e,t){this.variableNames=["A"];const n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const o=Object(r.a)(this.rank),i=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=Array(t);for(let o=0;o<e.length;o++)r[e[o]]=n[o];return r.join()}(t);this.userCode=`\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}},2123:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(651);class o{constructor(e,t){this.variableNames=["A"];const n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const o=Object(r.a)(this.rank),i=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<e.length;o++)r.push(`imod(${n[o]}, ${e[o]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}},2125:function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return o}));class r{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class o{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}},2127:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(e,t,n,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const u="nearest"===n?1:2;let a;switch(r){case"constant":default:a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${u} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}},667:function(e,t,n){"use strict";n.d(t,"i",(function(){return o})),n.d(t,"b",(function(){return i})),n.d(t,"e",(function(){return u})),n.d(t,"a",(function(){return a})),n.d(t,"d",(function(){return s})),n.d(t,"f",(function(){return c})),n.d(t,"g",(function(){return l})),n.d(t,"c",(function(){return f})),n.d(t,"h",(function(){return d}));var r=n(665);class o{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Object(r.e)(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const i="if (isnan(x)) return x;",u="return x;",a="return abs(x);",s="return (x >= 0.0) ? x : (exp(x) - 1.0);",c=i+"\n  return (x < 0.0) ? 0.0 : x;\n",l=i+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",f="return x;",d="return 1.0 / (1.0 + exp(-1.0 * x));"},674:function(e,t,n){"use strict";function r(e,t){const n=t();return Object(q.of)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw Error("WebGL Error: "+i(e,t))}(e),n}function o(e){return!!(Object(q.of)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||Q<Math.abs(e)&&Math.abs(e)<ee)}function i(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}function u(e,t){return L(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function a(e,t){const n=L(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(r(e,(()=>e.shaderSource(n,t))),r(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),Error("Failed to compile vertex shader.");return n}function s(e,t){const n=L(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(r(e,(()=>e.shaderSource(n,t))),r(e,(()=>e.compileShader(n))),Object(q.of)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw c(t,e.getShaderInfoLog(n)),Error("Failed to compile fragment shader.");return n}function c(e,t){const n=te.exec(t);if(null==n)return console.log("Couldn't parse line number in error: "+t),void console.log(e);const r=+n[1],o=e.split("\n"),i=o.length.toString().length+2,u=o.map(((e,t)=>q.Si.rightPad(""+(t+1),i)+e));let a=0;for(let f=0;f<u.length;f++)a=Math.max(u[f].length,a);const s=u.slice(0,r-1),c=u.slice(r-1,r),l=u.slice(r);console.log(s.join("\n")),console.log(t.split("\n")[0]),console.log("%c "+q.Si.rightPad(c[0],a),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join("\n"))}function l(e){return L(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function f(e,t){if(r(e,(()=>e.linkProgram(t))),!Object(q.of)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Failed to link vertex and fragment shaders.")}function d(e,t){if(r(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Shader program validation failed.")}function h(e,t){const n=L(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return r(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),r(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function E(e,t){const n=L(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return r(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),r(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function T(){return 2===Object(q.of)().getNumber("WEBGL_VERSION")?1:4}function g(e){return L(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function x(e,t){const n=Object(q.of)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}function p(e){return L(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function m(e,t,n,o,i,u,a){const s=e.getAttribLocation(t,n);return-1!==s&&(r(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,o))),r(e,(()=>e.vertexAttribPointer(s,i,e.FLOAT,!1,u,a))),r(e,(()=>e.enableVertexAttribArray(s))),!0)}function F(e,t,n){B(e,n),r(e,(()=>e.activeTexture(e.TEXTURE0+n))),r(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function b(e,t){B(e,t),r(e,(()=>e.activeTexture(e.TEXTURE0+t))),r(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function _(e,t,n){return L(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function A(e,t,n){return e.getUniformLocation(t,n)}function R(e,t,n,o){r(e,(()=>F(e,t,o))),r(e,(()=>e.uniform1i(n,o)))}function O(e){r(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),r(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),r(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function C(e,t,n){r(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),r(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function U(e,t){r(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),r(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function N(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+S(e,t))}function S(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}function L(e,t,n){const o=r(e,(()=>t()));if(null==o)throw Error(n);return o}function B(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)}function I(e,t=2){return q.Si.sizeFromShape(e.slice(0,e.length-t))}function M(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function D(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[I(e),...M(e)]),t}function P(e,t=!1){let n=Object(q.of)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Object(q.of)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Object(q.of)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?q.Si.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=q.Si.squeezeShape(e);e=t.newShape}let o=q.Si.sizeFromShape(e),i=null;e.length<=1&&o<=n?i=[1,o]:2===e.length&&e[0]<=n&&e[1]<=n?i=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);const u=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||u)if(t){const t=I(e);let n=2,r=2;e.length&&([n,r]=M(e)),o=t*(n/2)*(r/2),i=q.Si.sizeToSquarishShape(o).map((e=>2*e))}else i=q.Si.sizeToSquarishShape(o);return i}function v(e){return e%2==0}function y(e,t){if(e=e.slice(-2),t=t.slice(-2),q.Si.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(v(n)&&v(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&v(e[0])&&v(t[0])}function X(e){if(null==ne){const t=Object(Z.a)(e);ne=t.getParameter(t.MAX_TEXTURE_SIZE)}return ne}function w(){ne=null}function k(){re=null}function G(e){if(null==re){const t=Object(Z.a)(e);re=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,re)}function $(e){if(0===e)return 0;let t;const n=Object(Z.a)(e);return t=j(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:j(n,"EXT_disjoint_timer_query")?1:0,t}function j(e,t){return null!=e.getExtension(t)}function W(e){try{if(null!=Object(Z.a)(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function V(e){if(0===e)return!1;const t=Object(Z.a)(e);if(1===e){if(!j(t,"OES_texture_float"))return!1}else if(!j(t,"EXT_color_buffer_float"))return!1;return Y(t)}function z(e){if(0===e)return!1;const t=Object(Z.a)(e);if(1!==e){if(j(t,"EXT_color_buffer_float"))return Y(t);const e="EXT_color_buffer_half_float";if(j(t,e)){const n=t.getExtension(e);return function(e,t){const n=Object(J.g)(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),i}(t,n)}return!1}return!!j(t,"OES_texture_float")&&!!j(t,"WEBGL_color_buffer_float")&&Y(t)}function Y(e){const t=Object(J.g)(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),o}function K(e){return 2===e&&null!=Object(Z.a)(e).fenceSync}function H(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&q.Si.assert("complex64"!==e.dtype,(()=>t+" does not support complex64 tensors in the WebGL backend."))}))}var q,Z,J;n.r(t),n.d(t,"callAndCheck",(function(){return r})),n.d(t,"canBeRepresented",(function(){return o})),n.d(t,"getWebGLErrorMessage",(function(){return i})),n.d(t,"getExtensionOrThrow",(function(){return u})),n.d(t,"createVertexShader",(function(){return a})),n.d(t,"createFragmentShader",(function(){return s})),n.d(t,"logShaderSourceAndInfoLog",(function(){return c})),n.d(t,"createProgram",(function(){return l})),n.d(t,"linkProgram",(function(){return f})),n.d(t,"validateProgram",(function(){return d})),n.d(t,"createStaticVertexBuffer",(function(){return h})),n.d(t,"createStaticIndexBuffer",(function(){return E})),n.d(t,"getNumChannels",(function(){return T})),n.d(t,"createTexture",(function(){return g})),n.d(t,"validateTextureSize",(function(){return x})),n.d(t,"createFramebuffer",(function(){return p})),n.d(t,"bindVertexBufferToProgramAttribute",(function(){return m})),n.d(t,"bindTextureUnit",(function(){return F})),n.d(t,"unbindTextureUnit",(function(){return b})),n.d(t,"getProgramUniformLocationOrThrow",(function(){return _})),n.d(t,"getProgramUniformLocation",(function(){return A})),n.d(t,"bindTextureToProgramUniformSampler",(function(){return R})),n.d(t,"bindCanvasToFramebuffer",(function(){return O})),n.d(t,"bindColorTextureToFramebuffer",(function(){return C})),n.d(t,"unbindColorTextureFromFramebuffer",(function(){return U})),n.d(t,"validateFramebuffer",(function(){return N})),n.d(t,"getFramebufferErrorMessage",(function(){return S})),n.d(t,"getBatchDim",(function(){return I})),n.d(t,"getRowsCols",(function(){return M})),n.d(t,"getShapeAs3D",(function(){return D})),n.d(t,"getTextureShapeFromLogicalShape",(function(){return P})),n.d(t,"isReshapeFree",(function(){return y})),n.d(t,"getWebGLMaxTextureSize",(function(){return X})),n.d(t,"resetMaxTextureSize",(function(){return w})),n.d(t,"resetMaxTexturesInShader",(function(){return k})),n.d(t,"getMaxTexturesInShader",(function(){return G})),n.d(t,"getWebGLDisjointQueryTimerVersion",(function(){return $})),n.d(t,"hasExtension",(function(){return j})),n.d(t,"isWebGLVersionEnabled",(function(){return W})),n.d(t,"isCapableOfRenderingToFloatTexture",(function(){return V})),n.d(t,"isDownloadFloatTextureEnabled",(function(){return z})),n.d(t,"isWebGLFenceEnabled",(function(){return K})),n.d(t,"assertNotComplex",(function(){return H})),q=n(616),Z=n(825),J=n(692);const Q=5.96e-8,ee=65504,te=/ERROR: [0-9]+:([0-9]+):/g;let ne,re},692:function(e,t,n){"use strict";function r(e,t){return[t,e]}function o(e,t){return e*t}function i(e){const t=c.Si.sizeFromShape(e),n=Math.ceil(t/4);return c.Si.sizeToSquarishShape(n)}function u(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function a(e,t){const[n,r]=u(e,t);return n*r*4}function s(e,t){const n=e;let r,o,i,u,a,s,l,f,d,h;return 2===Object(c.of)().getNumber("WEBGL_VERSION")?(r=n.R32F,o=n.R16F,i=n.RGBA16F,u=n.RGBA32F,a=n.RED,l=4,f=1,d=n.HALF_FLOAT,h=n.FLOAT,s=n.RGBA8):(r=e.RGBA,o=e.RGBA,i=e.RGBA,u=n.RGBA,a=e.RGBA,l=4,f=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,s=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:u,textureFormatFloat:a,downloadTextureFormat:s,downloadUnpackNumChannels:l,defaultNumChannels:f,textureTypeHalfFloat:d,textureTypeFloat:h}}var c,l,f,d;n.d(t,"a",(function(){return l})),n.d(t,"c",(function(){return f})),n.d(t,"b",(function(){return d})),n.d(t,"i",(function(){return r})),n.d(t,"h",(function(){return o})),n.d(t,"d",(function(){return i})),n.d(t,"e",(function(){return u})),n.d(t,"f",(function(){return a})),n.d(t,"g",(function(){return s})),c=n(616),function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(l||(l={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(f||(f={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(d||(d={}))},781:function(e,t,n){"use strict";n.d(t,"b",(function(){return o})),n.d(t,"a",(function(){return i})),n.d(t,"c",(function(){return u})),n.d(t,"d",(function(){return a})),n.d(t,"e",(function(){return s})),n.d(t,"f",(function(){return c}));var r=n(665);const o="return x;",i="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",u="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",a="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",s="return 1.0 / (1.0 + exp(-1.0 * x));";class c{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Object(r.e)(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}}}]);