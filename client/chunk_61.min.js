/*! For license information please see chunk_61.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{1967:function(e,n,t){"use strict";var r,o;t.d(n,"a",(function(){return i})),r=t(698),o=t(651);class i{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Object(o.a)(this.rank),t=Object(r.a)("coords",this.rank),i=Object(r.a)("sourceLoc",this.rank),c=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,a=`getChannel(getSource(${i.join()}), ${c})`,u=`\n      result.x = ${a};\n      if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${a};\n        --${i[this.rank-1]};\n      }\n    `,s=1===this.rank?"":`\n      --${t[this.rank-1]};\n      if (++${t[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${a};\n        if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${n}(${e.map(((e,n)=>`start[${n}]`)).join()});`:e.map(((e,n)=>`${i[n]} = ${t[n]} + start[${n}];`)).join("\n");this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        ${n} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${u}\n        ${s}\n        setOutput(result);\n      }\n    `}}},1968:function(e,n,t){"use strict";t.d(n,"a",(function(){return o}));var r=t(651);class o{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Object(r.a)(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=function(e){if(1===e)return"sourceLoc";if(e<=6)return i.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let o;o=`\n        ${n} sourceLoc;\n        ${n} coords = getOutputCoords();\n        ${e.map(((e,n)=>`sourceLoc.${i[n]} = start[${n}] + coords.${i[n]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${o}\n        setOutput(getSource(${t}));\n      }\n    `}}const i=["x","y","z","w","u","v"]},2096:function(e,n,t){"use strict";t.d(n,"a",(function(){return o}));var r=t(651);class o{constructor(e,n,t){let o,i;if(this.variableNames=["c","a","b"],this.outputShape=n,t>4)throw Error(`Where for rank ${t} is not yet supported`);if(1===t)i="resRC",o="resRC";else{const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],c=[];for(let o=0;o<n.length;o++)c.push(""+t[o]),o<e&&r.push(""+t[o]);o=r.join(),i=c.join()}const c=Object(r.a)(t);this.userCode=`\n      void main() {\n        ${c} resRC = getOutputCoords();\n        float cVal = getC(${o});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}},2116:function(e,n,t){"use strict";t.d(n,"a",(function(){return o}));var r=t(651);class o{constructor(e,n,t){this.variableNames=["x"],this.outputShape=t;const o=t.length,i=Object(r.a)(t.length),c=Object(r.a)(t.length);let a="";if(1===o)a="coords * strides + begin";else{let e=0;a=t.map(((n,r)=>(e++,1===t.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${i} begin = ${i}(${e});\n      ${i} strides = ${i}(${n});\n\n      void main() {\n        ${c} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}},651:function(e,n,t){"use strict";function r(e,n,t){const r=[];if(e.forEach((e=>{const n=h.Si.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${n>1?`[${n}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),t.enableShapeUniforms){const{uniformShape:n}=s(t.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(n.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const c=r.join("\n"),a=e.map((e=>function(e,n,t=!1,r){let c="";c+=t?i(e,r):o(e,r);const a=e.shapeInfo.logicalShape,s=n.logicalShape;return a.length<=s.length&&(c+=t?function(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,c=n.logicalShape.length,a=$(e.shapeInfo.logicalShape,n.logicalShape),s=u(c),l=c-i;let p;const x=["x","y","z","w","u","v"];p=0===i?"":c<2&&a.length>=1?"coords = 0;":a.map((e=>`coords.${x[e+l]} = 0;`)).join("\n");let d="";d=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>"coords."+x[n+l])).join(", ");let v="return outputValue;";const f=1===h.Si.sizeFromShape(e.shapeInfo.logicalShape),S=1===h.Si.sizeFromShape(n.logicalShape);if(1!==i||f||S){if(f&&!S)v=1===c?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const e=i-2,n=i-1;a.indexOf(e)>-1&&a.indexOf(n)>-1?v="return vec4(outputValue.x);":a.indexOf(e)>-1?v="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(n)>-1&&(v="return vec4(outputValue.xx, outputValue.zz);")}}else v="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${s} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${r}(${d});\n      ${v}\n    }\n  `}(e,n):function(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",i=n.texShape,c=e.shapeInfo.texShape,a=e.shapeInfo.logicalShape.length,s=n.logicalShape.length;if(!e.shapeInfo.isUniform&&a===s&&null==e.shapeInfo.flatOffset&&h.Si.arraysEqual(c,i))return`\n      float ${o}() {\n        return sampleTexture(${t}, resultUV);\n      }\n    `;const l=u(s),p=$(e.shapeInfo.logicalShape,n.logicalShape),x=s-a;let d;const v=["x","y","z","w","u","v"];d=0===a?"":s<2&&p.length>=1?"coords = 0;":p.map((e=>`coords.${v[e+x]} = 0;`)).join("\n");let f="";return f=s<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>"coords."+v[n+x])).join(", "),`\n    float ${o}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,n)),c}(e,n,t.packedInputs,t.enableShapeUniforms))).join("\n"),l=n.texShape,p=Object(x.a)(),C=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(p);let T,g,R=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${v}\n    ${f}\n    ${S}\n  `}(p);return n.isPacked?(T=function(e,n,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,t);case 2:return function(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(h.Si.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const o=Math.ceil(e[1]/2);return t?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(e[2]/2),i=o*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,n,t);default:return function(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(e[e.length-1]/2),i=o*Math.ceil(e[e.length-2]/2);let c=i,a="",u="b, r, c";for(let s=2;s<e.length-1;s++)c*=e[e.length-s-1],a=`\n      int b${s} = index / ${c};\n      index -= b${s} * ${c};\n    `+a,u=`b${s}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,n,t)}}(n.logicalShape,l,t.enableShapeUniforms),g=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(p)):(T=function(e,n,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,n,t){return 1===n[0]?t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,t);case 2:return function(e,n,t){return h.Si.arraysEqual(e,n)?t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===e[1]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:t?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${d.f(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=d.d(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,n,t);case 4:return function(e,n,t){if(t)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${d.f(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=d.d(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,n,t);case 5:return function(e,n){const t=d.d(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,n);case 6:return function(e,n){const t=d.d(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,n);default:throw Error(e.length+"-D output sampling is not yet supported")}}(n.logicalShape,l,t.enableShapeUniforms),g=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(p)),t.packedInputs&&(R+=m),[R,C,g,c,T,a,t.userCode].join("\n")}function o(e,n=!1){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[o,i]=e.shapeInfo.texShape;if(1===o&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=c(t);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[u,s]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${u}, ${s}, ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 1:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${a(e)}\n      }\n    `;const o=e.shapeInfo.texShape,i=o[0],u=o[1];if(1===u&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const s=c(t);return 1===u?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${i}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===i?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${u}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${u}, index + ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),u=e.shapeInfo.texShape;if(null!=u&&h.Si.arraysEqual(t,u)){if(n)return`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=u[0];return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${u[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:s,keptDims:x}=h.Si.squeezeShape(t),d=s;if(d.length<t.length){const t=["row","col"];return`\n      ${o(l(e,d),n)}\n      float ${i}(int row, int col) {\n        return ${i}(${p(t,x)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${a(e)}\n      }\n    `;const $=u[0],v=u[1],f=c(r);return 1===v?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${$}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===$?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${v}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${f};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${f};\n    vec2 uv = uvFromFlat(${$}, ${v}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),u=t[1]*t[2],s=t[2],{newShape:x,keptDims:d}=h.Si.squeezeShape(t),$=x;if($.length<t.length){const t=["row","col","depth"];return`\n        ${o(l(e,$),n)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${p(t,d)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${u}, ${s}, 1)));\n        ${a(e)}\n      }\n    `;const v=e.shapeInfo.texShape,f=v[0],S=v[1],m=e.shapeInfo.flatOffset;if(S===u&&null==m)return n?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${S}.0, ${f}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(S===s&&null==m)return n?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${S}.0, ${f}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const C=c(r);return n?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${C};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${u} + col * ${s} + depth + ${C};\n        vec2 uv = uvFromFlat(${f}, ${S}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,n);case 4:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),u=t[3],s=t[2]*u,x=t[1]*s,{newShape:d,keptDims:$}=h.Si.squeezeShape(t);if(d.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${o(l(e,d),n)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${p(t,$)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${x}, ${s}, ${u}, 1)));\n        ${a(e)}\n      }\n    `;const v=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,S=f[0],m=f[1],C=`int stride2 = ${r}Shape[3];`,T=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(m===x&&null==v)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${C}\n        ${T}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${u}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${S}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(m===u&&null==v)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${S}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const R=c(r);return n?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${C}\n      ${T}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${R});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${x} + col * ${s} +\n          depth * ${u} + depth2;\n      vec2 uv = uvFromFlat(${S}, ${m}, index + ${R});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,n);case 5:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n[4],u=n[3]*i,s=n[2]*u,x=n[1]*s,{newShape:d,keptDims:$}=h.Si.squeezeShape(n);if(d.length<n.length){const n=["row","col","depth","depth2","depth3"];return`\n      ${o(l(e,d))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${p(n,$)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${x}, ${s}, ${u}, ${i})) +\n          depth3;\n        ${a(e)}\n      }\n    `;const v=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,S=f[0],m=f[1];return m===x&&null==v?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${u}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${S}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:m===i&&null==v?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${S}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${x} + col * ${s} + depth * ${u} +\n          depth2 * ${i} + depth3 + ${c(t)};\n      vec2 uv = uvFromFlat(${S}, ${m}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:u}=h.Si.squeezeShape(n);if(i.length<n.length){const n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${o(l(e,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${p(n,u)});\n      }\n    `}const s=n[5],x=n[4]*s,d=n[3]*x,$=n[2]*d,v=n[1]*$;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${v}, ${$}, ${d}, ${x})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${a(e)}\n      }\n    `;const f=e.shapeInfo.flatOffset,S=e.shapeInfo.texShape,m=S[0],C=S[1];return C===v&&null==f?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${$}, ${d}, ${x}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${C}.0, ${m}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:C===s&&null==f?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${C}.0, ${m}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${v} + col * ${$} + depth * ${d} +\n          depth2 * ${x} + depth3 * ${s} + depth4 + ${c(t)};\n      vec2 uv = uvFromFlat(${m}, ${C}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);default:throw Error(t.length+"-D input sampling is not yet supported")}}function i(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const n=e.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${Object(x.a)().texture2D}(${n}, halfCR);\n    }\n  `}(e);case 1:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e.shapeInfo.texShape,i=Object(x.a)();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${t}, uv);\n    }\n  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${c[0]}, ${c[1]}, index);\n      return ${i.texture2D}(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,c=i[0],a=i[1],u=Object(x.a)();if(null!=i&&h.Si.arraysEqual(t,i))return n?`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${c}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${s[0]}, ${s[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=e.shapeInfo.texShape,a=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];if(1===t[0]){const r=[1,2],c=["b","row","col"];return`\n        ${i(l(e,t.slice(1)),n)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${p(c,r)});\n        }\n      `}const u=Object(x.a)();if(n)return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const s=a[0],h=a[1],d=Math.ceil(t[2]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${s}, ${h}, ${d*Math.ceil(t[1]/2)}, ${d}, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e,n);default:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=Object(x.a)();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${t}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);\n    }\n  `;const i=e.shapeInfo.logicalShape,c=i.length,a=e.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],s=u[0],l=u[1],p=Math.ceil(i[c-1]/2);let h=p*Math.ceil(i[c-2]/2),d="int b, int row, int col",$=`b * ${h} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<c-1;x++)d=`int b${x}, `+d,h*=i[c-x-1],$=`b${x} * ${h} + `+$;return`\n    vec4 ${r}(${d}) {\n      int index = ${$};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${s});\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e,n)}}function c(e){return"offset"+e}function a(e){const n=e.name,t=h.Si.sizeFromShape(e.shapeInfo.logicalShape);return t<2?`return ${n};`:`\n    for (int i = 0; i < ${t}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function u(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function s(e,n,t){const{newShape:r,keptDims:o}=h.Si.squeezeShape(n),i=n.length,c=e&&3===i&&1===n[0],a=c?n.slice(1):r,u=!e&&i>1&&!h.Si.arraysEqual(n,t)&&r.length<i||c;return{useSqueezeShape:u,uniformShape:u?a:n,keptDims:o}}function l(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function p(e,n){return n.map((n=>e[n])).join(", ")}var h,x,d;t.d(n,"c",(function(){return r})),t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return s})),h=t(616),x=t(693),d=t(729);const{getBroadcastDims:$}=h.ie,v="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",f="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",S="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",m="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n"},729:function(e,n,t){"use strict";function r(e,n,t="index"){const r=u.Si.computeStrides(n);return r.map(((n,o)=>`int ${e[o]} = ${t} / ${n}; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * ${n}`:`index -= ${e[o]} * ${n}`};`)).join("")}function o(e,n,t="index"){const r=u.Si.computeStrides(n);return r.map(((n,o)=>`int ${e[o]} = ${t} / outShapeStrides[${o}]; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * outShapeStrides[${o}]`:`index -= ${e[o]} * outShapeStrides[${o}]`};`)).join("")}function i(e,n,t="index"){const r=function(e,n){const t=e.length,r=e.map((e=>`${n}[${e}]`)),o=Array(t-1);o[t-2]=r[t-1];for(let i=t-3;i>=0;--i)o[i]=`(${o[i+1]} * ${r[i+1]})`;return o}(e.map(((e,n)=>n)),n);return r.map(((n,o)=>`int ${e[o]} = ${t} / ${r[o]}; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * ${r[o]}`:`index -= ${e[o]} * ${r[o]}`};`)).join("")}function c(e){const n=u.Si.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}function a(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}t.d(n,"d",(function(){return r})),t.d(n,"f",(function(){return o})),t.d(n,"e",(function(){return i})),t.d(n,"b",(function(){return c})),t.d(n,"c",(function(){return a})),t.d(n,"a",(function(){return s}));var u=t(616);const s="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"}}]);