/*! For license information please see chunk_59.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{1204:function(t,e,i){"use strict";i.d(e,"b",(function(){return s})),i.d(e,"c",(function(){return n})),i.d(e,"d",(function(){return r})),i.d(e,"e",(function(){return a})),i.d(e,"a",(function(){return l}));const s=["channelsFirst","channelsLast"],n=["nearest","bilinear"],r=["valid","same","causal"],a=["max","avg"],l=["sum","mul","concat","ave"]},1748:function(t,e,i){"use strict";var s,n,r,a,l,o,h,c;i.d(e,"d",(function(){return u})),i.d(e,"b",(function(){return d})),i.d(e,"c",(function(){return p})),i.d(e,"a",(function(){return g})),i.d(e,"f",(function(){return b})),i.d(e,"e",(function(){return f})),s=i(616),n=i(887),r=i(725),a=i(642),l=i(633),o=i(700),h=i(708),c=i(654);class u extends a.b{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=Object(c.b)(t);let i=Object(s.th)(t);return null!=this.maxValue&&(i=Object(s.ze)(i,0,this.maxValue)),i}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}u.className="ReLU",s.Lh.registerClass(u);class d extends a.b{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const i=Object(c.b)(t);return Object(s.Zf)(i,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}d.className="LeakyReLU",s.Lh.registerClass(d);class p extends a.b{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Object(o.q)(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Object(h.b)(t.alphaRegularizer),this.alphaConstraint=Object(r.e)(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new l.e("Expected sharedAxes to be a number or an array of numbers, but got "+t.sharedAxes);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=Object(c.a)(t)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)e[s-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(null!=this.sharedAxes)for(let s=1;s<t.length;++s)i[s]=t[s];this.inputSpec=[new a.a({ndim:t.length,axes:i})],this.built=!0}call(t,e){return t=Object(c.b)(t),Object(s.Zg)(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Object(o.r)(this.alphaInitializer),alphaRegularizer:Object(h.e)(this.alphaRegularizer),alphaConstraint:Object(r.f)(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}p.className="PReLU",s.Lh.registerClass(p);class g extends a.b{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new l.c(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const i=Object(c.b)(t);return Object(s.if)(i)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}g.className="ELU",s.Lh.registerClass(g);class b extends a.b{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const i=Object(c.b)(t);return Object(s.Gg)(i,Object(s.xe)(Object(s.Mf)(i,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}b.className="ThresholdedReLU",s.Lh.registerClass(b);class f extends a.b{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new n.a).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){return Object(s.Ei)((()=>{let i=Object(c.b)(t);const n=e.mask;if(null!=n){const t=Object(s.Gg)(Object(s.pi)(Object(s.Og)(i.shape),Object(s.xe)(n,i.dtype)),Object(s.Fh)(-1e9));i=Object(s.Ud)(i,t)}return this.axis instanceof Array?this.axis.length>1?Object(s.sf)(Object(s.pi)(i,Object(s.jg)(i,this.axis,!0))):this.softmax(i,this.axis[0]):this.softmax(i,this.axis)}))}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}f.className="Softmax",s.Lh.registerClass(f)},1749:function(t,e,i){"use strict";var s,n,r,a,l,o,h,c,u,d,p;i.d(e,"a",(function(){return g})),s=i(616),n=i(724),r=i(659),a=i(691),l=i(725),o=i(633),h=i(700),c=i(708),u=i(888),d=i(654),p=i(984);class g extends p.a{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Object(h.q)(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Object(l.e)(t.depthwiseConstraint),this.depthwiseRegularizer=Object(c.b)(t.depthwiseRegularizer)}build(t){if((t=Object(d.a)(t)).length<4)throw new o.e(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new o.e(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const i=t[e],s=[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Object(s.Ei)((()=>{let e=function(t,e,i=[1,1],r="valid",l,h){return Object(s.Ei)((()=>{null==l&&(l=Object(n.b)()),Object(a.a)(l);let c=Object(p.j)(t,l);if(4!==t.rank)throw new o.e("Input for depthwiseConv2d is required to be 4-D, but is instead "+t.rank+"-D");if(4!==e.rank)throw new o.e("depthwiseKernel is required to be 4-D, but is instead "+e.rank+"-D");return c=s.We(c,e,i,"same"===r?"same":"valid","NHWC",h),"channelsFirst"===l&&(c=s.Ji(c,[0,3,1,2])),c}))}(t=Object(d.b)(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=r.b(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=Object(d.a)(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,n=Object(u.a)(e,this.kernelSize[0],this.padding,this.strides[0]),r=Object(u.a)(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],s,n,r]:[t[0],n,r,s]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Object(h.r)(this.depthwiseInitializer),t.depthwiseRegularizer=Object(c.e)(this.depthwiseRegularizer),t.depthwiseConstraint=Object(l.f)(this.depthwiseRegularizer),t}}g.className="DepthwiseConv2D",s.Lh.registerClass(g)},1750:function(t,e,i){"use strict";var s,n,r,a,l,o,h,c,u,d,p;i.d(e,"b",(function(){return b})),i.d(e,"a",(function(){return f})),s=i(616),n=i(659),r=i(691),a=i(642),l=i(633),o=i(700),h=i(888),c=i(648),u=i(654),d=i(749),p=function(t,e){var i,s,n={};for(i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.indexOf(i)<0&&(n[i]=t[i]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols)for(s=0,i=Object.getOwnPropertySymbols(t);s<i.length;s++)e.indexOf(i[s])<0&&Object.prototype.propertyIsEnumerable.call(t,i[s])&&(n[i[s]]=t[i[s]]);return n},d.f;class g extends d.e{constructor(t){if(t.unroll)throw new l.c("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new l.c("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new a.a({ndim:5})]}call(t,e){return s.Ei((()=>{if(null!=this.cell.dropoutMask&&(s.bf(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.bf(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new l.e("ConvRNN2D cell does not support constants");const i=null==e?null:e.mask,n=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:n,initialState:r})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...[,,].fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return s.Ei((()=>{const{stateSize:e}=this.cell,i=t.shape,n=this.computeSingleOutputShape(i),r=[n[0],...n.slice(2)],a=s.aj(r);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t,e=!1){s.Ei((()=>{if(!this.stateful)throw new l.b("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,n=this.computeSingleOutputShape(i),r=[n[0],...n.slice(2)];if(null==i[0])throw new l.e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>s.aj(r))):this.states_=[s.aj(r)];else if(null==t)s.bf(this.states_),null!=this.keptStates&&(s.bf(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>s.aj(r))):this.states_[0]=s.aj(r);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new l.e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: `+t);e?this.keptStates.push(this.states_.slice()):s.bf(this.states_);for(let e=0;e<this.states_.length;++e){const i=t[e],n=r;if(!s.Si.arraysEqual(i.shape,n))throw new l.e(`State ${e} is incompatible with layer ${this.name}: expected shape=${n}, received shape=${i.shape}`);this.states_[e]=i}}this.states_=this.states_.map((t=>s.Xf(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:i,kernelSize:s,padding:n,strides:r,dilationRate:a}=this.cell,l="channelsFirst"===e,o=t[l?3:2],c=t[l?4:3],u=Object(h.a)(o,s[0],n,r[0],a[0]),d=Object(h.a)(c,s[1],n,r[1],a[1]);return[...t.slice(0,2),...l?[i,u,d]:[u,d,i]]}}g.className="ConvRNN2D";class b extends d.d{constructor(t){const{filters:e,kernelSize:i,strides:s,padding:n,dataFormat:a,dilationRate:l}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Object(c.b)(this.filters,"filters"),this.kernelSize=Object(h.c)(i,2,"kernelSize"),this.kernelSize.forEach((t=>Object(c.b)(t,"kernelSize"))),this.strides=Object(h.c)(s||1,2,"strides"),this.strides.forEach((t=>Object(c.b)(t,"strides"))),this.padding=n||"valid",Object(r.c)(this.padding),this.dataFormat=a||"channelsLast",Object(r.a)(this.dataFormat),this.dilationRate=Object(h.c)(l||1,2,"dilationRate"),this.dilationRate.forEach((t=>Object(c.b)(t,"dilationRate")))}build(t){var e;t=Object(u.a)(t);const i="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[i])throw new l.e("The channel dimension of the input should be defined. Found "+t[i]);const r=t[i],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const h=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",h,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const i=this.biasInitializer,r=this.filters;t=new((e=class extends o.g{apply(t,e){const a=i.apply([r]),l=s.Og([r]),o=i.apply([2*r]);return n.e([a,l,o])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return s.Ei((()=>{if(3!==t.length)throw new l.e("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");const i=e.training||!1,n=t[0],r=t[1],a=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Object(d.j)({ones:()=>s.Pg(n),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,h=(t,e,i)=>e&&e[i]?s.Gg(e[i],t):t;let c=h(n,o,0),u=h(n,o,1),p=h(n,o,2),g=h(n,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Object(d.j)({ones:()=>s.Pg(r),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let f=h(r,b,0),m=h(r,b,1),O=h(r,b,2),j=h(r,b,3);const[k,w,C,v]=s.gi(this.kernel.read(),4,3),[S,z,N,I]=this.useBias?s.gi(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,k,S,this.padding),u=this.inputConv(u,w,z,this.padding),p=this.inputConv(p,C,N,this.padding),g=this.inputConv(g,v,I,this.padding);const[y,F,L,A]=s.gi(this.recurrentKernel.read(),4,3);f=this.recurrentConv(f,y),m=this.recurrentConv(m,F),O=this.recurrentConv(O,L),j=this.recurrentConv(j,A);const R=this.recurrentActivation.apply(s.Ud(c,f)),E=this.recurrentActivation.apply(s.Ud(u,m)),x=s.Ud(s.Gg(E,a),s.Gg(R,this.activation.apply(s.Ud(p,O)))),D=s.Gg(this.recurrentActivation.apply(s.Ud(g,j)),this.activation.apply(x));return[D,D,x]}))}getConfig(){const t=super.getConfig(),{units:e}=t,i=p(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},i),s)}inputConv(t,e,i,r){const a=s.Ie(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return i?n.b(a,i,this.dataFormat):a}recurrentConv(t,e){return s.Ie(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}b.className="ConvLSTM2DCell",s.Lh.registerClass(b);class f extends g{constructor(t){const e=new b(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}f.className="ConvLSTM2D",s.Lh.registerClass(f)},1751:function(t,e,i){"use strict";var s,n,r,a,l,o,h,c,u,d,p;i.d(e,"c",(function(){return g})),i.d(e,"i",(function(){return b})),i.d(e,"b",(function(){return f})),i.d(e,"d",(function(){return m})),i.d(e,"a",(function(){return O})),i.d(e,"g",(function(){return j})),i.d(e,"h",(function(){return k})),i.d(e,"f",(function(){return w})),i.d(e,"e",(function(){return C})),s=i(616),n=i(887),r=i(659),a=i(725),l=i(642),o=i(633),h=i(700),c=i(708),u=i(648),d=i(723),p=i(654);class g extends l.b{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,i=[];for(let s=0;s<this.noiseShape.length;++s)i.push(null==this.noiseShape[s]?e[s]:this.noiseShape[s]);return i}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);const i=Object(p.b)(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,s=this.getNoiseShape(i);return r.m((()=>r.g(i,this.rate,s,this.seed)),(()=>i),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}g.className="Dropout",s.Lh.registerClass(g);class b extends g{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}b.className="SpatialDropout1D",s.Lh.registerClass(b);class f extends l.b{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Object(u.b)(this.units,"units"),this.activation=Object(n.b)(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=Object(h.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Object(h.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Object(a.e)(t.kernelConstraint),this.biasConstraint=Object(a.e)(t.biasConstraint),this.kernelRegularizer=Object(c.b)(t.kernelRegularizer),this.biasRegularizer=Object(c.b)(t.biasRegularizer),this.activityRegularizer=Object(c.b)(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=Object(p.a)(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=Object(p.a)(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);const i=Object(p.b)(t),s=Object(u.i)(this.activation.getClassName());let n;return null!=s?n=r.f(i,this.kernel.read(),s,this.bias?this.bias.read():null):(n=r.f(i,this.kernel.read()),null!=this.bias&&(n=r.b(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){const t={units:this.units,activation:Object(n.c)(this.activation),useBias:this.useBias,kernelInitializer:Object(h.r)(this.kernelInitializer),biasInitializer:Object(h.r)(this.biasInitializer),kernelRegularizer:Object(c.e)(this.kernelRegularizer),biasRegularizer:Object(c.e)(this.biasRegularizer),activityRegularizer:Object(c.e)(this.activityRegularizer),kernelConstraint:Object(a.f)(this.kernelConstraint),biasConstraint:Object(a.f)(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}f.className="Dense",s.Lh.registerClass(f);class m extends l.b{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Object(p.a)(t);for(const e of t.slice(1))if(null==e)throw new o.e(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Object(d.a)(t,1)]}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);let i=Object(p.b)(t);if("channelsFirst"===this.dataFormat&&i.rank>1){const t=[0];for(let e=2;e<i.rank;++e)t.push(e);t.push(1),i=Object(s.Ji)(i,t)}return r.a(i)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}m.className="Flatten",s.Lh.registerClass(m);class O extends l.b{constructor(t){super(t),this.supportsMasking=!0,this.activation=Object(n.b)(t.activation)}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);const i=Object(p.b)(t);return this.activation.apply(i)}))}getConfig(){const t={activation:Object(n.c)(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}O.className="Activation",s.Lh.registerClass(O);class j extends l.b{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return Object(s.Ei)((()=>(t=Object(p.b)(t),r.o(t,this.n))))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}j.className="RepeatVector",s.Lh.registerClass(j);class k extends l.b{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const i="Total size of new array must be unchanged.",s=e.slice();let n=1,r=null;for(let l=0;l<s.length;++l){const t=s[l];if(this.isUnknown(t)){if(null!==r)throw new o.e("Can only specifiy one unknown dimension.");r=l}else n*=t}const a=Object(d.a)(t);if(null!==r){if(0===n||a%n!=0)throw new o.e(i);s[r]=a/n}else if(a!==n)throw new o.e(i);return s}computeOutputShape(t){let e=!1;for(let i=0;i<t.length;++i)if(this.isUnknown(t[i])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);const i=Object(p.b)(t),n=i.shape,r=n.slice(0,1).concat(this.fixUnknownDimension(n.slice(1),this.targetShape));return Object(s.wh)(i,r)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}k.className="Reshape",s.Lh.registerClass(k);class w extends l.b{constructor(t){if(super(t),null==t.dims)throw Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");const e=Object(d.e)(1,t.dims.length+1);if(!s.Si.arraysEqual(t.dims.slice().sort(),e))throw Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new l.a({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=Object(p.a)(t)).slice();return this.dims.forEach(((i,s)=>{e[s+1]=t[i]})),e}call(t,e){return Object(s.Ji)(Object(p.b)(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}w.className="Permute",s.Lh.registerClass(w);class C extends l.b{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const i=Object(p.b)(t);return Object(s.Xd)(Object(s.Mg)(i,this.maskValue),-1)}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);const i=Object(p.b)(t),n=Object(s.Xd)(Object(s.Mg)(i,this.maskValue),-1,!0);return Object(s.Gg)(i,Object(s.xe)(n,i.dtype))}))}}C.className="Masking",s.Lh.registerClass(C)},700:function(t,e,i){"use strict";function s(t,e={}){return Object(a.g)(t,o.Lh.SerializationMap.getMap().classNameMap,e,"initializer")}function n(t){return Object(a.l)(t)}function r(t){if("string"==typeof t){const e=t in L?L[t]:t;if("GlorotNormal"===e)return new S;if("GlorotUniform"===e)return new v;if("HeNormal"===e)return new z;if("HeUniform"===e)return new N;if("LeCunNormal"===e)return new I;if("LeCunUniform"===e)return new y;{const t={};return t.className=e,t.config={},s(t)}}return t instanceof g?t:s(t)}var a,l,o=i(616),h=i(659),c=i(691),u=i(633);const d=["fanIn","fanOut","fanAvg"],p=["normal","uniform","truncatedNormal"];a=i(648),l=i(723),i.d(e,"g",(function(){return g})),i.d(e,"p",(function(){return b})),i.d(e,"j",(function(){return f})),i.d(e,"a",(function(){return m})),i.d(e,"m",(function(){return O})),i.d(e,"l",(function(){return j})),i.d(e,"n",(function(){return k})),i.d(e,"f",(function(){return w})),i.d(e,"o",(function(){return C})),i.d(e,"c",(function(){return v})),i.d(e,"b",(function(){return S})),i.d(e,"d",(function(){return z})),i.d(e,"e",(function(){return N})),i.d(e,"h",(function(){return I})),i.d(e,"i",(function(){return y})),i.d(e,"k",(function(){return F})),i.d(e,"r",(function(){return n})),i.d(e,"q",(function(){return r}));class g extends o.Lh.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class b extends g{apply(t,e){return Object(o.aj)(t,e)}}b.className="Zeros",o.Lh.registerClass(b);class f extends g{apply(t,e){return Object(o.Og)(t,e)}}f.className="Ones",o.Lh.registerClass(f);class m extends g{constructor(t){if(super(),"object"!=typeof t)throw new u.e("Expected argument of type ConstantConfig but got "+t);if(void 0===t.value)throw new u.e("config must have value set but got "+t);this.value=t.value}apply(t,e){return Object(o.Ei)((()=>Object(o.Gg)(Object(o.Fh)(this.value),Object(o.Og)(t,e))))}getConfig(){return{value:this.value}}}m.className="Constant",o.Lh.registerClass(m);class O extends g{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Object(o.kh)(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}O.className="RandomUniform",o.Lh.registerClass(O);class j extends g{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new u.c(`randomNormal does not support dType ${e}.`);return h.n(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}j.className="RandomNormal",o.Lh.registerClass(j);class k extends g{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new u.c(`truncatedNormal does not support dType ${e}.`);return Object(o.Ki)(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}k.className="TruncatedNormal",o.Lh.registerClass(k);class w extends g{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return Object(o.Ei)((()=>{if(2!==t.length||t[0]!==t[1])throw new u.e("Identity matrix initializer can only be used for 2D square matrices.");return Object(o.Gg)(this.gain,Object(o.vf)(t[0]))}))}getConfig(){return{gain:this.gain}}}w.className="Identity",o.Lh.registerClass(w);class C extends g{constructor(t){if(super(),t.scale<0)throw new u.e("scale must be a positive float. Got: "+t.scale);var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,Object(a.d)(d,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){Object(a.d)(p,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const i=function(t,e="channelsLast"){let i,s;if(Object(c.a)(e),2===t.length)i=t[0],s=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=Object(l.a)(t,2);i=t[1]*e,s=t[0]*e}else if("channelsLast"===e){const e=Object(l.a)(t,0,t.length-2);i=t[t.length-2]*e,s=t[t.length-1]*e}}else{const e=Object(l.a)(t);i=Math.sqrt(e),s=Math.sqrt(e)}return[i,s]}(t),s=i[0],n=i[1];let r=this.scale;if("fanIn"===this.mode?r/=Math.max(1,s):"fanOut"===this.mode?r/=Math.max(1,n):r/=Math.max(1,(s+n)/2),"normal"===this.distribution){const i=Math.sqrt(r);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new u.c(`${this.getClassName()} does not support dType ${e}.`);return Object(o.Ki)(t,0,i,e,this.seed)}{const i=Math.sqrt(3*r);return Object(o.kh)(t,-i,i,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}C.className="VarianceScaling",o.Lh.registerClass(C);class v extends C{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return C.className}}v.className="GlorotUniform",o.Lh.registerClass(v);class S extends C{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return C.className}}S.className="GlorotNormal",o.Lh.registerClass(S);class z extends C{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return C.className}}z.className="HeNormal",o.Lh.registerClass(z);class N extends C{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return C.className}}N.className="HeUniform",o.Lh.registerClass(N);class I extends C{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return C.className}}I.className="LeCunNormal",o.Lh.registerClass(I);class y extends C{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return C.className}}y.className="LeCunUniform",o.Lh.registerClass(y);class F extends g{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return Object(o.Ei)((()=>{if(t.length<2)throw new u.c("Shape must be at least 2D.");if("int32"!==e&&"float32"!==e&&void 0!==e)throw new TypeError(`Unsupported data type ${e}.`);const i=o.Si.sizeFromShape(t.slice(0,-1)),s=t[t.length-1],n=i*s;n>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${n}) elements: Slowness may result.`);const r=[Math.max(s,i),Math.min(s,i)],a=h.n(r,0,1,e,this.seed),l=o.cg.qr(a,!1);let c=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(s,i)*Math.min(s,i)],[Math.min(s,i)+1]);return c=Object(o.Gg)(c,d.sign()),i<s&&(c=c.transpose()),Object(o.Gg)(Object(o.Fh)(this.gain),c.reshape(t))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}F.className="Orthogonal",o.Lh.registerClass(F);const L={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"}},984:function(t,e,i){"use strict";function s(t,e){return Object(a.Ei)((()=>(Object(c.a)(e),"channelsFirst"===e?a.Ji(t,[0,2,3,1]):t)))}function n(t,e){return Object(a.Ei)((()=>(Object(c.a)(e),"channelsFirst"===e?a.Ji(t,[0,2,3,4,1]):t)))}function r(t,e,i,n=[1,1],r="valid",l,h,u=null){return Object(a.Ei)((()=>{if(null==l&&(l=Object(o.b)()),Object(c.a)(l),3!==t.rank&&4!==t.rank)throw new p.e(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new p.e(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let d=s(t,l);if("causal"===r)throw new p.c("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return d=a.Cf.conv2d({x:d,filter:e,strides:n,pad:"same"===r?"same":"valid",dilations:h,dataFormat:"NHWC",bias:i,activation:u}),"channelsFirst"===l&&(d=a.Ji(d,[0,3,1,2])),d}))}var a,l,o,h,c,u,d,p,g,b,f,m,O;i.d(e,"j",(function(){return s})),i.d(e,"k",(function(){return n})),i.d(e,"a",(function(){return j})),i.d(e,"c",(function(){return w})),i.d(e,"e",(function(){return C})),i.d(e,"d",(function(){return v})),i.d(e,"f",(function(){return S})),i.d(e,"h",(function(){return N})),i.d(e,"b",(function(){return I})),i.d(e,"g",(function(){return y})),i.d(e,"i",(function(){return F})),a=i(616),l=i(887),o=i(724),h=i(659),c=i(691),u=i(725),d=i(642),p=i(633),g=i(700),b=i(708),f=i(888),m=i(648),O=i(654);class j extends d.b{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",j.verifyArgs(e),this.rank=t,m.b(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new p.c(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Object(f.c)(e.kernelSize,t,"kernelSize"),this.strides=Object(f.c)(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Object(c.c)(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Object(c.a)(this.dataFormat),this.activation=Object(l.b)(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=Object(g.q)(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Object(u.e)(e.biasConstraint),this.biasRegularizer=Object(b.b)(e.biasRegularizer),this.activityRegularizer=Object(b.b)(e.activityRegularizer),this.dilationRate=Object(f.c)(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new p.e("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(this.dilationRate));if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new p.e("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(this.dilationRate))}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new p.e("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(this.dilationRate))}static verifyArgs(t){if(m.a("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!m.c(t.kernelSize,"number",1,3))throw new p.e(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Object(l.c)(this.activation),useBias:this.useBias,biasInitializer:Object(g.r)(this.biasInitializer),biasRegularizer:Object(b.e)(this.biasRegularizer),activityRegularizer:Object(b.e)(this.activityRegularizer),biasConstraint:Object(u.f)(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class k extends j{constructor(t,e){super(t,e),this.kernel=null,k.verifyArgs(e),this.filters=e.filters,m.b(this.filters,"filters"),this.kernelInitializer=Object(g.q)(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Object(u.e)(e.kernelConstraint),this.kernelRegularizer=Object(b.b)(e.kernelRegularizer)}build(t){t=Object(O.a)(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new p.e("The channel dimension of the input should be defined. Found "+t[e]);const i=t[e],s=this.kernelSize.concat([i,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:i}}],this.built=!0}call(t,e){return Object(a.Ei)((()=>{let e;t=Object(O.b)(t);const i=null==this.bias?null:this.bias.read(),s=m.i(this.activation.getClassName());if(null!=s&&2===this.rank)e=r(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)e=function(t,e,i,s=1,n="valid",r,l=1){return Object(a.Ei)((()=>{if(null==r&&(r=Object(o.b)()),Object(c.a)(r),3!==t.shape.length)throw new p.e("The input of a conv1dWithBias operation should be 3, but is "+t.shape.length+" instead.");if(3!==e.shape.length)throw new p.e("The kernel for a conv1dWithBias operation should be 3, but is "+e.shape.length+" instead");if(null!=i&&1!==i.shape.length)throw new p.e("The bias for a conv1dWithBias operation should be 1, but is "+e.shape.length+" instead");if("channelsFirst"===r&&(t=a.Ji(t,[0,2,1])),"causal"===n)throw new p.c("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let u=a.He(t,e,s,"same"===n?"same":"valid","NWC",l);return null!=i&&(u=h.b(u,i)),u}))}(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=r(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new p.c("convolutions greater than 3D are not implemented yet.");e=function(t,e,i,s=[1,1,1],r="valid",l,u){return Object(a.Ei)((()=>{if(null==l&&(l=Object(o.b)()),Object(c.a)(l),4!==t.rank&&5!==t.rank)throw new p.e("conv3dWithBias expects input to be of rank 4 or 5, but received "+t.rank+".");if(4!==e.rank&&5!==e.rank)throw new p.e("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+t.rank+".");let d=n(t,l);if("causal"===r)throw new p.c("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return d=a.Ke(d,e,s,"same"===r?"same":"valid","NDHWC",u),null!=i&&(d=h.b(d,i)),"channelsFirst"===l&&(d=a.Ji(d,[0,4,1,2,3])),d}))}(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=Object(O.a)(t);const e=[],i="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let n=0;n<i.length;++n){const t=Object(f.a)(i[n],this.kernelSize[n],this.padding,this.strides[n],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[n]);e.push(t)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:Object(g.r)(this.kernelInitializer),kernelRegularizer:Object(b.e)(this.kernelRegularizer),kernelConstraint:Object(u.f)(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new p.e("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(t.filters))}}class w extends k{constructor(t){super(2,t),w.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!m.c(t.kernelSize,"number",1,2))throw new p.e(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}w.className="Conv2D",a.Lh.registerClass(w);class C extends k{constructor(t){super(3,t),C.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new p.e(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}C.className="Conv3D",a.Lh.registerClass(C);class v extends w{constructor(t){if(super(t),this.inputSpec=[new d.a({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new p.e("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+this.padding)}build(t){if(4!==(t=Object(O.a)(t)).length)throw new p.e("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new p.e("The channel dimension of the inputs should be defined. Found `None`.");const i=t[e],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new d.a({ndim:4,axes:{[e]:i}})],this.built=!0}call(t,e){return a.Ei((()=>{let e=Object(O.b)(t);if(4!==e.shape.length)throw new p.e("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+e.shape.length);const i=e.shape,s=i[0];let n,r;"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);const l=i[n],o=i[r],c=this.kernelSize[0],u=this.kernelSize[1],d=this.strides[0],g=this.strides[1],b=[s,Object(f.b)(l,d,c,this.padding),Object(f.b)(o,g,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=a.Ji(e,[0,2,3,1]));let m=a.Je(e,this.kernel.read(),b,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(m=a.Ji(m,[0,3,1,2])),null!=this.bias&&(m=h.b(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),m}))}computeOutputShape(t){const e=(t=Object(O.a)(t)).slice();let i,s,n;"channelsFirst"===this.dataFormat?(i=1,s=2,n=3):(i=3,s=1,n=2);const r=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],o=this.strides[1];return e[i]=this.filters,e[s]=Object(f.b)(e[s],l,r,this.padding),e[n]=Object(f.b)(e[n],o,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}v.className="Conv2DTranspose",a.Lh.registerClass(v);class S extends C{constructor(t){if(super(t),this.inputSpec=[new d.a({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new p.e("Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+this.padding)}build(t){if(5!==(t=Object(O.a)(t)).length)throw new p.e("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new p.e("The channel dimension of the inputs should be defined. Found `None`.");const i=t[e],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new d.a({ndim:5,axes:{[e]:i}})],this.built=!0}call(t,e){return a.Ei((()=>{let e=Object(O.b)(t);if(5!==e.shape.length)throw new p.e("Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+e.shape.length);const i=e.shape,s=i[0];let n,r,l;"channelsFirst"===this.dataFormat?(l=2,n=3,r=4):(l=1,n=2,r=3);const o=i[l],c=i[n],u=i[r],d=this.kernelSize[0],g=this.kernelSize[1],b=this.kernelSize[2],m=this.strides[0],j=this.strides[1],k=this.strides[2],w=[s,Object(f.b)(o,m,d,this.padding),Object(f.b)(c,j,g,this.padding),Object(f.b)(u,k,b,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=a.Ji(e,[0,2,3,4,1]));let C=a.Le(e,this.kernel.read(),w,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(C=a.Ji(C,[0,4,1,2,3])),null!==this.bias&&(C=h.b(C,this.bias.read(),this.dataFormat)),null!==this.activation&&(C=this.activation.apply(C)),C}))}computeOutputShape(t){const e=(t=Object(O.a)(t)).slice();let i,s,n,r;"channelsFirst"===this.dataFormat?(i=1,s=2,n=3,r=4):(i=4,s=1,n=2,r=3);const a=this.kernelSize[0],l=this.kernelSize[1],o=this.kernelSize[2],h=this.strides[0],c=this.strides[1],u=this.strides[2];return e[i]=this.filters,e[s]=Object(f.b)(e[s],h,a,this.padding),e[n]=Object(f.b)(e[n],c,l,this.padding),e[r]=Object(f.b)(e[r],u,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}S.className="Conv3DTranspose",a.Lh.registerClass(S);class z extends k{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new p.e("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new p.e("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new p.e(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received `+JSON.stringify(e.padding));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Object(g.q)(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Object(b.b)(e.depthwiseRegularizer),this.depthwiseConstraint=Object(u.e)(e.depthwiseConstraint),this.pointwiseInitializer=Object(g.q)(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Object(b.b)(e.pointwiseRegularizer),this.pointwiseConstraint=Object(u.e)(e.pointwiseConstraint)}build(t){if((t=Object(O.a)(t)).length<this.rank+2)throw new p.e(`Inputs to SeparableConv${this.rank}D should have rank `+(this.rank+2)+", but received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new p.e("The channel dimension of the inputs should be defined, but found "+JSON.stringify(t[e]));const i=t[e],s=this.kernelSize.concat([i,this.depthMultiplier]),n=[];for(let a=0;a<this.rank;++a)n.push(1);n.push(i*this.depthMultiplier,this.filters);const r=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",n,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint):this.bias=null,this.inputSpec=[new d.a({ndim:this.rank+2,axes:{[e]:i}})],this.built=!0}call(t,e){return Object(a.Ei)((()=>{let e;if(t=Object(O.b)(t),1===this.rank)throw new p.c("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=a.Ji(t,[0,2,3,1])),e=a.Kh(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=h.b(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=a.Ji(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Object(g.r)(this.depthwiseInitializer),t.pointwiseInitializer=Object(g.r)(this.pointwiseInitializer),t.depthwiseRegularizer=Object(b.e)(this.depthwiseRegularizer),t.pointwiseRegularizer=Object(b.e)(this.pointwiseRegularizer),t.depthwiseConstraint=Object(u.f)(this.depthwiseConstraint),t.pointwiseConstraint=Object(u.f)(this.pointwiseConstraint),t}}z.className="SeparableConv";class N extends z{constructor(t){super(2,t)}}N.className="SeparableConv2D",a.Lh.registerClass(N);class I extends k{constructor(t){super(1,t),I.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!m.c(t.kernelSize,"number",1,1))throw new p.e(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}I.className="Conv1D",a.Lh.registerClass(I);class y extends d.b{constructor(t){super(t),"number"==typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return Object(a.Ei)((()=>{if(t=Object(O.b)(t),"channelsLast"===this.dataFormat){const e=h.p(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return h.p(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=h.p(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return h.p(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}y.className="Cropping2D",a.Lh.registerClass(y);class F extends d.b{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Object(c.a)(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,Object(c.b)(this.interpolation)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],i=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,i]}{const e=null==t[1]?null:this.size[0]*t[1],i=null==t[2]?null:this.size[1]*t[2];return[t[0],e,i,t[3]]}}call(t,e){return a.Ei((()=>{let e=Object(O.b)(t);const i=e.shape;if("channelsFirst"===this.dataFormat){e=a.Ji(e,[0,2,3,1]);const t=this.size[0]*i[2],s=this.size[1]*i[3],n="nearest"===this.interpolation?a.Qf.resizeNearestNeighbor(e,[t,s]):a.Qf.resizeBilinear(e,[t,s]);return a.Ji(n,[0,3,1,2])}{const t=this.size[0]*i[1],s=this.size[1]*i[2];return"nearest"===this.interpolation?a.Qf.resizeNearestNeighbor(e,[t,s]):a.Qf.resizeBilinear(e,[t,s])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}F.className="UpSampling2D",a.Lh.registerClass(F)}}]);