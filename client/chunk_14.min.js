/*! For license information please see chunk_14.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{600:function(t,e,n){"use strict";var i,r;Object.defineProperty(e,"__esModule",{value:!0}),i=(r=n(626))&&r.__esModule?r:{default:r},e.default=i.default.pool({minWorkers:0,maxWorkers:3})},602:function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}var r=i(n(603)),a=i(n(604));t.exports=function(t,e=!1){let n=(0,r.default)(t);if(e){const t=/(?:#)[0-9a-f]{8}|(?:#)[0-9a-f]{6}|(?:#)[0-9a-f]{4}|(?:#)[0-9a-f]{3}/gi;n.match(t).forEach((function(t){const[e,i,r]=t.match(/\w\w/g).map((t=>parseInt(t,16))),a=Math.round((e+i+r)/3),s=function(t,e,n){return t=t.toString(16),e=e.toString(16),n=n.toString(16),1==t.length&&(t="0"+t),1==e.length&&(e="0"+e),1==n.length&&(n="0"+n),"#"+t+e+n}(a,a,a);n=n.replace(t,s)}))}return(0,a.default)(n)}},611:function(t,e,n){"use strict";var i=n(612);t.exports={createLocalBlob:function(t){var e,n,r,a,s=(t.match(/(data\:([a-z]+\/[a-z\+]+)\;base64\,)([a-zA-Z0-9\/\+]+\(\=+)?/)||[,,])[1];return s?(n=(e=s.match(/data\:([a-z]+\/[a-z\+]+)\;base64\,/)[1]).match(/[a-z]+\/([a-z\+]+)/)[1],t=t.replace(s,""),r=(0,i.base64ToBytes)(t),a=new File([r],"name."+n,{type:e}),URL.createObjectURL(a)):""}}},612:function(t,e,n){"use strict";var i=new(n(609).B64chromium);t.exports={bytesToBase64:i.bytesToBase64.bind(i),base64ToBytes:i.base64ToBytes.bind(i)}},629:function(t,e,n){"use strict";var i,r;(i=n(127))&&i.__esModule,n(630);const a=Object.getPrototypeOf((r=function*(){},function(){var t=r.apply(this,arguments);return new Promise((function(e,n){return function i(r,a){var s,o;try{o=(s=t[r](a)).value}catch(l){return void n(l)}if(!s.done)return Promise.resolve(o).then((function(t){i("next",t)}),(function(t){i("throw",t)}));e(o)}("next")}))})).constructor,s=Object.getPrototypeOf((function(){})).constructor;window.file_to_base64_process_function=new s('var t = function(file) {\n    "use strict";\n    \n    try {\n        \n        return new Promise(function(resolve, _) {\n            resolve(new FileReaderSync().readAsDataURL(file));\n        });\n        \n    } catch(error) {\n    \n        return new Promise(function(resolve, _) {\n            var reader = new FileReader();\n            reader.onload = function(){ resolve(reader.result)};\n            reader.readAsDataURL(file);\n        });\n    }\n    \n}; return t;')();const o=(t,e=(()=>{}),n=null)=>{null!==n?n.exec(window.file_to_base64_process_function,[t]).catch((e=>window.file_to_base64_process_function(t))).timeout(5e3).then((t=>{e(t)})):window.file_to_base64_process_function(t).then((t=>{e(t)}))};window.base64_sanitize_process_function=new s('var t = function (base64, scale, resizer) {\n   \n    resizer = resizer || "pixelize";\n    /* MIT Licence 2024 Matias Affolter */\n"use strict";\nclass ImageProcessor {\n    constructor(options) {\n        options = options || {};\n        this.canvas = document.createElement(\'canvas\');\n        this.targetCanvas = document.createElement(\'canvas\');\n        this.options = {\n            despeckleStrength: options.despeckleStrength || options.strength || 1.0,\n            quantizeStrength: options.quantizeStrength || options.strength  || 1.0,\n            mergeStrength: options.mergeStrength || options.strength  || 1.0,\n            overlapFactor: options.overlapFactor || options.strength  || 1.0\n        };\n     }\n\n     get sizes(){\n         "use strict";\n         return {\n             finalWidth: this.finalWidth,\n             finalHeight: this.finalHeight,\n             tileWidth: this.tileWidth,\n             tileHeight: this.tileHeight,\n             overlapFactor: this.options.overlapFactor\n         };\n     }\n\n    updateTilesManager() {\n        "use strict";\n         this.tilesManager = new TileManager(this.context, this.targetContext, this.targetImageData, this.sizes);\n     }\n    updateFilters(threshold) {\n        "use strict";\n         this.filters = new Filters(this.options, this.tilesManager, threshold, this.finalWidth, this.finalHeight);\n     }\n     initializeTiles() {\n         "use strict";\n         this.tilesManager.createTiles();\n         this.tilesManager.computeTiles();\n     }\n     paintTiles() {\n         "use strict";\n        this.tilesManager.paintTiles();\n     }\n     filterTiles() {\n         "use strict";\n        this.filters.applyFilters()\n     }\n\n    setCanvas(width, height, image){\n        "use strict";\n        width = (width|0) || 1;\n        height = (height|0) || 1;\n        image = image || {width: 0, height: 0};\n\n        const resultPrimaryCanvas = ImageUtils.initializeCanvas(image);\n        this.canvas = resultPrimaryCanvas.canvas;\n        this.context = resultPrimaryCanvas.context;\n\n        const resultSecondaryCanvas = ImageUtils.initializeCanvas(null, width, height);\n        this.targetCanvas = resultSecondaryCanvas.canvas;\n        this.targetContext = resultSecondaryCanvas.context;\n\n        this.targetImageData = new ImageData(width, height);\n\n        this.finalWidth = width;\n        this.finalHeight = height;\n        this.tileWidth = Math.fround(this.canvas.width / this.targetCanvas.width);\n        this.tileHeight = Math.fround(this.canvas.height / this.targetCanvas.height);\n    }\n\n    updateThreshold() {\n        "use strict";\n        const tiles = this.tilesManager.getTiles();\n        let colorDifferences = [];\n        for (let y = 0; y < this.finalHeight; y++) {\n            for (let x = 0; x < this.finalWidth; x++) {\n                const tile = tiles[x + y * this.finalWidth];\n                const neighbors = this.tilesManager.getNeighbors(x, y);\n                neighbors.forEach(neighbor => {\n                    colorDifferences.push(ColorAnalysis.colorDifference(tile.meanColor, neighbor.meanColor));\n                });\n            }\n        }\n        const mean = colorDifferences.reduce((a, b) => a + b, 0) / colorDifferences.length;\n        const stdDev = Math.sqrt(colorDifferences.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / colorDifferences.length);\n        return (mean + stdDev) / 10; // Example of dynamic threshold\n    }\n\n    processImage(image, width, height) {\n        "use strict";\n        const t1 = Date.now();\n        this.setCanvas(width, height, image);\n        const t2 = Date.now();\n        this.updateTilesManager();\n        const t3 = Date.now();\n        this.initializeTiles();\n        const t4 = Date.now();\n        this.updateFilters(this.updateThreshold());\n        const t5 = Date.now();\n        this.filterTiles();\n        const t6 = Date.now();\n        this.paintTiles();\n        const t7 = Date.now();\n        console.log({\n            "setCanvas": t2-t1,\n            "updateTilesManager": t3-t2,\n            "initializeTiles": t4-t3,\n            "updateFilters+updateThreshold": t5-t4,\n            "filterTiles": t6-t5,\n            "paintTiles": t7-t5,\n        })\n        return this.targetContext;\n    }\n}\n\n/* Image Utils Module */\nclass ImageUtils {\n    static initializeCanvas(image, width, height) {\n        "use strict";\n        image = image || {width: 0, height: 0}\n        width = image.width || width || 1;\n        height = image.height || height || 1;\n        let canvas, context;\n        try {\n            canvas = new OffscreenCanvas(width, height);\n            context = canvas.getContext(\'2d\', { willReadFrequently: true, desynchronized: true});\n        }catch (e) {\n            canvas = document.createElement("canvas")\n            canvas.width = width;\n            canvas.height = height;\n            context = canvas.getContext(\'2d\', { willReadFrequently: true});\n        }\n\n        if (image instanceof ImageData) {\n            context.putImageData(image, 0, 0);\n        } else if(image.width) {\n            context.drawImage(image, 0, 0, width, height);\n        }\n\n        return { canvas, context };\n    }\n\n    static canvasContextToImageData(context) {\n        "use strict";\n        return context.getImageData(0, 0, context.canvas.width, context.canvas.height);\n    }\n}\n\n/* Filters Module */\nclass Filters {\n    constructor(options, tilesManager, threshold, width, height) {\n        this.mergeFilter = new MergeFilter(threshold * options.mergeStrength, tilesManager, width, height);\n        this.despeckleFilter = new DespeckleFilter(threshold * options.despeckleStrength, tilesManager, width, height);\n        this.quantizeFilter = new QuantizeFilter(threshold * options.quantizeStrength, tilesManager, width, height);\n    }\n\n    applyFilters() {\n        "use strict";\n        this.mergeFilter.apply();\n        this.despeckleFilter.apply();\n        this.quantizeFilter.apply();\n    }\n}\n\nclass Filter{\n    constructor(strength, tilesManager, width, height) {\n        this.strength = strength;\n        this.tilesManager = tilesManager;\n        this.tiles = tilesManager.getTiles();\n        this.width = width;\n        this.height = height;\n    }\n}\n\n/* Individual filters */\nclass DespeckleFilter extends Filter{\n    constructor(strength, tilesManager, width, height) {\n        super(strength, tilesManager, width, height)\n    }\n\n    apply() {\n        "use strict";\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                this.adaptiveDespeckleTile(x, y, this.strength);\n            }\n        }\n    }\n\n    adaptiveDespeckleTile(x, y, baseThreshold) {\n        "use strict";\n        const tile = this.tiles[x + y * this.width];\n        const neighbors = this.tilesManager.getExtendedNeighbors(x, y, 3); // Larger neighborhood\n\n        // Calculate local contrast and adjust threshold\n        const localContrast = this.calculateLocalContrast(tile, neighbors);\n        const adjustedThreshold = baseThreshold * (1 + localContrast);\n\n        // Basic edge detection by checking dominant areas\n        const { primaryColor, secondaryColor, isEdge, isArea } = this.detectEdge(neighbors, adjustedThreshold);\n        if (isArea) {\n            this.maybeApplyDespeckling(tile, adjustedThreshold, primaryColor, primaryColor);\n        } else if(isEdge) {\n            this.maybeApplyDespeckling(tile, adjustedThreshold, primaryColor, secondaryColor);\n        }\n    }\n\n    calculateLocalContrast(tile, neighbors) {\n        "use strict";\n        // Example: Simple contrast calculation based on color variance\n        const meanColor = ColorAnalysis.averageColor(neighbors.concat([tile]).map(t => t.meanColor));\n        const variance = neighbors.concat([tile]).reduce((variance, neighbor) => {\n            return variance + Math.pow(ColorAnalysis.colorDifference(neighbor.meanColor, meanColor), 2);\n        }, 0) / neighbors.length;\n        return Math.sqrt(variance);\n    }\n\n    detectEdge(neighbors, threshold) {\n        "use strict";\n        const neighborGroup = TileManager.getTilesGroup(neighbors, threshold);\n        const areaNumber = neighborGroup.length;\n        const colorNumber = neighbors.length;\n\n        const primaryGroupNumber = (neighborGroup[0] || []).length || 0;\n        const secondaryGroupNumber = (neighborGroup[1] || []).length || 0;\n\n        const primaryColor = ColorAnalysis.averageColor(neighborGroup[0].map(t => t.meanColor));\n        const secondaryColor = (neighborGroup[1] || []).length ? ColorAnalysis.averageColor(neighborGroup[1].map(t => t.meanColor)): null;\n        const isEdge = colorNumber * 0.777 <= primaryGroupNumber + secondaryGroupNumber;\n        const isArea = colorNumber * 0.666 <= primaryGroupNumber;\n\n        return { primaryColor, secondaryColor, isEdge, isArea };\n    }\n\n    maybeApplyDespeckling(tile, adjustedThreshold, primaryColor, secondaryColor) {\n        "use strict";\n        if(\n            ColorAnalysis.colorDifference(tile.meanColor, primaryColor) > adjustedThreshold &&\n            ColorAnalysis.colorDifference(tile.meanColor, secondaryColor) > adjustedThreshold\n        ){\n            tile.meanColor.setRGBA(primaryColor.rgba);\n        }\n    }\n}\n\nclass QuantizeFilter extends Filter{\n    constructor(strength, tilesManager, width, height) {\n        super(strength, tilesManager, width, height)\n    }\n\n    apply() {\n        "use strict";\n        // Collect mean colors from all tiles\n        const meanColors = this.tiles.map(tile => tile.meanColor.rgba);\n\n        // Apply K-Means to find dominant colors\n        // The number of centroids (k) can be adjusted based on the desired quantization strength\n          const k = 128; // Adjust \'k\' based on strength or other criteria\n        const kmeans = new KMeans(meanColors, k);\n        const quantizationResult = kmeans.run(16);\n\n        // Update each tile\'s mean color to the nearest centroid\n        this.tiles.forEach((tile, index) => {\n            const clusterIndex = quantizationResult.clusters[index];\n            const nearestCentroid = quantizationResult.centroids[clusterIndex];\n            tile.meanColor.setRGBA(nearestCentroid);\n        });\n    }\n}\n\nclass MergeFilter extends Filter{\n    constructor(strength, tilesManager, width, height) {\n        super(strength, tilesManager, width, height)\n    }\n\n    apply() {\n        "use strict";\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const tileIndex = x + y * this.width;\n                const tile = this.tiles[tileIndex];\n                const neighbors = this.tilesManager.getNeighbors(x, y);\n                const map = {};\n                neighbors.forEach((neighbor, index) => {\n                    const colorDifference = ColorAnalysis.colorDifference(tile.meanColor, neighbor.meanColor);\n                    if (colorDifference < this.strength) {\n                        map[index] = neighbor;\n                    }\n                });\n\n                if(Object.keys(map).length >= 3){\n                    Object.values(map).forEach(function (neighbor){\n                        neighbor.meanColor.setRGBA(tile.meanColor.rgba);\n                    });\n                }\n            }\n        }\n    }\n}\n/* Color Analysis Module */\nclass ColorAnalysis {\n    static colorDifference(color1, color2) {\n        "use strict";\n        return Math.sqrt(\n            Math.pow(color1.r - color2.r, 2) +\n            Math.pow(color1.g - color2.g, 2) +\n            Math.pow(color1.b - color2.b, 2) +\n            Math.pow(color1.a - color2.a, 2)\n        );\n    }\n    static averageColor(colors){\n        "use strict";\n        const sumColor = new Uint32Array(4);\n        colors.forEach(color => {\n            const rgba = color.rgba;\n            sumColor[0] = (sumColor[0] + rgba[0] | 0) >>> 0;\n            sumColor[1] = (sumColor[1] + rgba[1] | 0) >>> 0;\n            sumColor[2] = (sumColor[2] + rgba[2] | 0) >>> 0;\n            sumColor[3] = (sumColor[3] + rgba[3] | 0) >>> 0;\n        });\n\n        const colorLength = colors.length;\n        return new Pixel(Uint8Array.of(sumColor[0] / colorLength|0, sumColor[1] / colorLength | 0, sumColor[2] / colorLength | 0, sumColor[3] / colorLength | 0));\n    }\n}\n\n/* Tile Management Module */\nclass TileManager {\n    constructor(contextSource, contextDestination, imageData, sizes) {\n        this.contextSource = contextSource;\n        this.contextDestination = contextDestination;\n        this.imageData = imageData;\n        this.overlapFactor = sizes.overlapFactor;\n        this.finalWidth = sizes.finalWidth;\n        this.finalHeight = sizes.finalHeight;\n        this.tileWidth = sizes.tileWidth;\n        this.tileHeight = sizes.tileHeight;\n        this.tiles = new Array(this.finalWidth * this.finalHeight).fill(null);\n        this.tilesColorUint32a = new Uint32Array(this.finalWidth * this.finalHeight);\n        this.tilesColorUint8a = new Uint8ClampedArray(this.tilesColorUint32a.buffer);\n        this.extendedTileWidth = this.tileWidth * this.overlapFactor | 0;\n        this.extendedTileHeight = this.tileHeight * this.overlapFactor | 0;\n        this.tilePaddingWidth = (this.extendedTileWidth - this.tileWidth) / 2 | 0;\n        this.tilePaddingHeight = (this.extendedTileHeight - this.tileHeight) / 2 | 0;\n    }\n    static getTilesGroup(tiles, threshold) {\n        "use strict";\n        const group = [];\n        tiles.forEach((tile) => {\n            let foundGroup = false;\n            group.forEach((group) => {\n                if(ColorAnalysis.colorDifference(tile.meanColor, group[0].meanColor) < threshold){\n                    group.push(tile);\n                    foundGroup = true;\n                }\n            });\n            if(!foundGroup){\n                group.push([tile]);\n            }\n        });\n\n        group.sort((g1, g2) => g2.length-g1.length);\n        return group;\n    }\n    getTiles(){\n        "use strict";\n        return this.tiles;\n    }\n    extractTileData(x, y){\n        "use strict";\n        // Adjust x and y to keep tiles centered with the new size\n        const newX = Math.imul(x, this.tileWidth) - this.tilePaddingWidth | 0;\n        const newY = Math.imul(y, this.tileHeight) - this.tilePaddingHeight | 0;\n        return this.contextSource.getImageData(newX|0, newY|0, this.extendedTileWidth|0, this.extendedTileHeight|0);\n    }\n    createTiles() {\n        "use strict";\n        for (let y = 0; y < this.finalHeight; y++) {\n            for (let x = 0; x < this.finalWidth; x++) {\n                const tileId = x+y*this.finalWidth;\n                const tileIndexColor = tileId * 4;\n                this.tiles[tileId] =  new Tile(this.extractTileData(x, y), this.tilesColorUint8a.subarray(tileIndexColor, tileIndexColor+4));\n            }\n        }\n    }\n    computeTiles() {\n        "use strict";\n        for (let i = 0; i < this.tiles.length; i++) {\n            this.tiles[i].calculateMeanColor();\n        }\n    }\n    getNeighbors(x, y) {\n        "use strict";\n        const neighbors = [];\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n\n                const nx = x + dx;\n                const ny = y + dy;\n\n                if (dx === 0 && dy === 0) continue;\n                if (nx < 0 || ny < 0) continue;\n                if (nx >= this.finalWidth || ny >= this.finalHeight) continue;\n\n                if (nx >= 0 && nx < this.finalWidth && ny >= 0 && ny < this.finalHeight) {\n                    neighbors.push(this.tiles[nx + ny * this.finalWidth]);\n                }\n            }\n        }\n        return neighbors;\n    }\n    getExtendedNeighbors(x, y, range) {\n        "use strict";\n        const neighbors = [];\n        for (let dx = -range; dx <= range; dx++) {\n            for (let dy = -range; dy <= range; dy++) {\n                const nx = x + dx;\n                const ny = y + dy;\n                if (dx === 0 && dy === 0) continue;\n                if (nx < 0 || ny < 0) continue;\n                if (nx >= this.finalWidth || ny >= this.finalHeight) continue;\n\n                neighbors.push(this.tiles[nx + ny * this.finalWidth]);\n            }\n        }\n        return neighbors;\n    }\n    paintTiles() {\n        "use strict";\n        this.imageData.data.set(this.tilesColorUint8a);\n        this.contextDestination.putImageData(this.imageData, 0, 0);\n    }\n}\n\nclass KMeans {\n    constructor(data, k) {\n        this.data = data;\n        this.dataConstructor = Object.getPrototypeOf(data[0]).constructor;\n        this.mean = new Uint32Array(data[0].length);\n        this.k = k;\n        this.centroids = new Array(k);\n        this.clusters = new Array(this.data.length);\n    }\n\n    // Step 1: Initialize centroids\n    initializeCentroids() {\n        "use strict";\n        // Simple random initialization. For KMeans++, the initialization is more complex.\n        for (let i = 0; i < this.k; i++) {\n            const idx = Math.floor(Math.random() * this.data.length);\n            this.centroids[i] = this.dataConstructor.from(this.data[idx]);\n        }\n    }\n\n    // Step 2: Assign points to the nearest centroid\n    assignClusters() {\n        "use strict";\n        this.data.forEach((point, idx) => {\n            let minDist = Number.MAX_VALUE;\n            let cluster = -1;\n\n            this.centroids.forEach((centroid, centroidIdx) => {\n                const dist = this.euclideanDistance(point, centroid);\n                if (dist < minDist) {\n                    minDist = dist;\n                    cluster = centroidIdx;\n                }\n            });\n\n            this.clusters[idx] = cluster;\n        });\n    }\n\n    // Step 3: Update centroids\n    updateCentroids() {\n        "use strict";\n        let newCentroids = new Array(this.k).fill(null).map(() => []);\n        this.data.forEach((point, idx) => {\n            const clusterIdx = this.clusters[idx];\n            newCentroids[clusterIdx].push(point);\n        });\n\n        this.centroids = newCentroids.map(cluster => {\n            if (cluster.length === 0) return null; // Handle empty cluster\n            return this.meanPoint(cluster);\n        }).filter(centroid => centroid !== null);\n    }\n\n    // Euclidean distance between two points\n    euclideanDistance(point1, point2) {\n        "use strict";\n        return Math.sqrt(point1.reduce((sum, val, idx) => sum + Math.pow(val - point2[idx], 2), 0));\n    }\n\n    // Calculate the mean point of a cluster\n    meanPoint(points) {\n        "use strict";\n        const numPoints = points.length;\n        const dimensions = points[0].length;\n        this.mean.fill(0);\n\n        for(var p = 0; p < numPoints; p++){\n            for(var i = 0; i < dimensions; i++) {\n                this.mean[i] += points[p][i];\n            }\n        }\n\n        const mean = new this.dataConstructor(dimensions);\n        for(var i = 0; i < dimensions; i++) {\n            mean[i] = this.mean[i] / numPoints | 0;\n        }\n\n        return mean;\n    }\n\n    // Run the KMeans algorithm\n    run(maxIterations) {\n        "use strict";\n        maxIterations = maxIterations || 16;\n        this.initializeCentroids();\n        let iterations = 0;\n        let hasConverged = false;\n\n        while (!hasConverged && iterations < maxIterations) {\n            const oldCentroids = [...this.centroids];\n            this.assignClusters();\n            this.updateCentroids();\n            iterations++;\n\n            hasConverged = this.centroids.every((centroid, idx) => {\n                return this.euclideanDistance(centroid, oldCentroids[idx]) < 1e-5;\n            });\n        }\n\n        return { centroids: this.centroids, clusters: this.clusters };\n    }\n}\n\nclass Pixel {\n    constructor(rgba) {\n        this.rgba_ = rgba;\n    }\n    get r(){return this.rgba_[0];}\n    get g(){return this.rgba_[1];}\n    get b(){return this.rgba_[2];}\n    get a(){return this.rgba_[3];}\n    get rgba(){return this.rgba_.subarray(0, 4);}\n    setRGBA(array){\n        "use strict";\n        this.rgba_[0] = array[0];\n        this.rgba_[1] = array[1];\n        this.rgba_[2] = array[2];\n        this.rgba_[3] = array[3];\n    }\n}\n\nclass Tile {\n    constructor(imageData, colorUint8a) {\n        this.imageData = imageData;\n        this.meanColor = new Pixel(colorUint8a);\n        this.map = new Uint32Array(0)\n    }\n    extractColorData(data) {\n        "use strict";\n        let colors = [];\n        for (let i = 0; i < data.length; i += 4) {\n            colors.push(new Pixel(data.subarray(i, i+4)));\n        }\n        return colors;\n    }\n    quantizeColors(k) {\n        "use strict";\n        k = k || Math.ceil(Math.sqrt(this.imageData.data.length));\n        const data = this.imageData.data;\n        const colors = this.extractColorData(data);\n        const colorsArray = colors.map(function (c){return c.rgba; });\n        return new KMeans(colorsArray, 7).run(21);\n    }\n\n    getQuantizedColor(quantizedResult) {\n        "use strict";\n        if(quantizedResult.centroids.length !== this.map.length){\n            this.map = new Uint32Array(quantizedResult.centroids.length)\n        }else {\n            this.map.fill(0);\n        }\n        quantizedResult.clusters.forEach((clusterId, index) => {\n            this.map[clusterId] = (this.map[clusterId] + 1|0)>>>0;\n        });\n        let dominantClusterPopulation = 0, dominantClusterId = 0;\n        this.map.forEach((population, clusterId) => {\n            if(dominantClusterPopulation < population){\n                dominantClusterPopulation = population;\n                dominantClusterId = clusterId;\n            }\n        });\n        return quantizedResult.centroids[dominantClusterId];\n    }\n\n    calculateMeanColor() {\n        "use strict";\n        const color = this.getQuantizedColor(this.quantizeColors());\n        this.meanColor.setRGBA(color);\n    }\n}\n\nvar scaler = new ImageProcessor({strength: 1.314});\n\n\n    function imgToImgD(imgo, width, height, resizer) {\n        \n        let ctx;\n        if(resizer === "pixelize" || resizer === "normal") {\n            let canvas, canvas2;\n            try {\n                canvas = new OffscreenCanvas(imgo.width, imgo.height);\n                canvas2 = new OffscreenCanvas(width, height);\n            }catch(e) {\n                canvas = document.createElement("canvas");\n                canvas2 = document.createElement("canvas");\n                canvas.width = imgo.width;\n                canvas.height = imgo.height;\n                canvas2.width = width;\n                canvas2.height = height;\n            }\n            let context = canvas.getContext("2d");\n            let context2 = canvas2.getContext("2d");\n                context.imageSmoothingEnabled = Boolean(resizer === "normal");\n                context2.imageSmoothingEnabled = Boolean(resizer === "normal");\n            context.drawImage(imgo, 0, 0, imgo.width, imgo.height);\n            context2.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas2.width, canvas2.height);\n            ctx = context2;\n            \n        }else if(resizer === "doppel") {\n            ctx = scaler.processImage(imgo, width, height);\n        }\n        return ctx;\n    }\n\n    return new Promise(function(resolve, reject) {\n        var img = new Image();\n        var is_png = base64.startsWith("data:image/png;");\n        img.onload = function() {\n    \n           var canvas;\n           try {\n           \n                let width = (img.naturalWidth || img.width) * scale;\n                let height = (img.naturalHeight || img.height) * scale;\n                let imgd = imgToImgD(img, width, height, resizer).getImageData(0, 0, width, height);\n                \n                createImageBitmap(imgd).then(function(bmp){\n                \n                    var canvas;\n                        canvas = new OffscreenCanvas(bmp.width, bmp.height);\n                    var ctx = canvas.getContext("bitmaprenderer");\n                        ctx.imageSmoothingEnabled = false;\n                        ctx.transferFromImageBitmap(bmp);\n                    \n                    canvas.convertToBlob({type: is_png ? "image/png": "image/jpeg"}).then(function(blb) {\n                        \n                        try {\n                            resolve(new FileReaderSync().readAsDataURL(blb));\n                        } catch(e2) {\n                            var reader = new FileReader();\n                            reader.onload = function(){ resolve(reader.result)};\n                            reader.readAsDataURL(blb);\n                        }\n                    });\n                });\n                \n            } catch(e){\n                let width = (img.naturalWidth || img.width) * scale;\n                let height = (img.naturalHeight || img.height) * scale;\n                let canvas = imgToImgD(img, width, height, resizer).canvas;\n                resolve(canvas.toDataURL(is_png ? "image/png": "image/jpeg")); \n            }\n        };\n        img.onerror = function() { reject(); };\n        img.src = base64;\n    });\n}; return t;')(),window.base64_to_bitmap_process_function=new a('var t = async function(base64) {\n\n    "use strict";\n\n    return fetch(base64).then(function(res) {\n\n        return res.blob().then(function(blb){\n\n            return createImageBitmap(blb);\n        });\n    });\n\n}; return t;')();const l=(t,e=(()=>{}),n=null)=>{null!==n?n.exec(window.base64_to_bitmap_process_function,[t]).catch((e=>window.base64_to_bitmap_process_function(t))).timeout(5e3).then((t=>{e(t)})):window.base64_to_bitmap_process_function(t).then((t=>{e(t)}))},h=(t,e=2073600,n=(()=>{}))=>{let i=1;for(;Math.round(t.width*i)*Math.round(t.height*i)>e;)i-=.01;try{createImageBitmap(t,0,0,t.width,t.height,{resizeWidth:Math.round(t.width*i),resizeHeight:Math.round(t.height*i),resizeQuality:"pixelated"}).then((function(t){let e;try{e=new OffscreenCanvas(t.width,t.height)}catch(r){e=document.createElement("canvas"),e.width=t.width,e.height=t.height}let i=e.getContext("2d");i.imageSmoothingEnabled=!1,i.drawImage(t,0,0,t.width,t.height),n(i.getImageData(0,0,t.width,t.height))}))}catch(r){let e;try{e=new OffscreenCanvas(Math.round(t.width*i),Math.round(t.height*i))}catch(a){e=document.createElement("canvas"),e.width=Math.round(t.width*i),e.height=Math.round(t.height*i)}let s=e.getContext("2d");s.imageSmoothingEnabled=!1,s.drawImage(t,0,0,e.width,e.height),n(s.getImageData(0,0,e.width,e.height))}};window.imagedata_to_base64_process_function=new s('var t = function(imagedata, type) {\n\n    "use strict"\n    type = type || "image/png";\n    var quality = type.includes("webp") ? 1: type.includes("png") ? undefined: 0.7;\n    try {\n    \n        return new Promise(function(resolve, _) {\n\n            createImageBitmap(imagedata, {\n                premultiplyAlpha: \'premultiply\',\n                resizeQuality: \'pixelated\'\n            }).then((bmp) => {\n            \n                var canvas;\n                    canvas = new OffscreenCanvas(imagedata.width, imagedata.height);\n                var ctx = canvas.getContext("bitmaprenderer");\n                    ctx.imageSmoothingEnabled = false;\n                    ctx.transferFromImageBitmap(bmp);\n                \n                canvas.convertToBlob({type: type, quality: quality}).then((blb) => {\n                    try {\n                        resolve(new FileReaderSync().readAsDataURL(blb));\n                    } catch(e2) {\n                        var reader = new FileReader();\n                        reader.onload = function(){ resolve(reader.result)};\n                        reader.readAsDataURL(blb);\n                    }\n                });\n            });\n        });\n       \n    }catch (e) {\n    \n        return new Promise(function(resolve, _) {\n            var canvas = document.createElement("canvas");\n            canvas.width = imagedata.width;\n            canvas.height = imagedata.height;\n            var ctx = canvas.getContext("2d");\n            ctx.imageSmoothingEnabled = false;\n            ctx.putImageData(imagedata, 0, 0);\n            \n            var base64 = canvas.toDataURL(type, quality);\n            canvas = null;\n            resolve(base64);\n        });\n    }\n\n}; return t;')(),t.exports={file_to_imagedata_resized:(t,e,n=(()=>{}),i=null)=>{Date.now(),t.type,"image/jpg"!==t.type&&t.type,t.type,o(t,(function(t){l(t,(function(t){h(t,e,(function(t){n(t)}))}),i)}),i)},file_to_base64:o,base64_to_bitmap:l,bitmap_to_imagedata:h,imagedata_to_base64:(t,e="image/png",n=(()=>{}),i=null)=>{null!==i?i.exec(window.imagedata_to_base64_process_function,[t,e]).catch((n=>window.imagedata_to_base64_process_function(t,e))).timeout(5e3).then((t=>{n(t)})):window.imagedata_to_base64_process_function(t,e).then((t=>{n(t)}))},base64_sanitize:(t,e=(()=>{}),n=null,i=1,r)=>{null!==n?n.exec(window.base64_sanitize_process_function,[t,i,r]).catch((n=>{window.base64_sanitize_process_function(t,i,r).then((t=>{e(t)}))})).timeout(15e3).then((t=>{e(t)})):window.base64_sanitize_process_function(t,i,r).then((t=>{e(t)}))},file_to_bitmap:(t,e)=>{createImageBitmap(t).then(e)}}},630:function(t,e,n){"use strict";class i{constructor(t){t=t||{},this.canvas=document.createElement("canvas"),this.targetCanvas=document.createElement("canvas"),this.options={despeckleStrength:t.despeckleStrength||t.strength||1,quantizeStrength:t.quantizeStrength||t.strength||1,mergeStrength:t.mergeStrength||t.strength||1,overlapFactor:t.overlapFactor||t.strength||1}}get sizes(){return{finalWidth:this.finalWidth,finalHeight:this.finalHeight,tileWidth:this.tileWidth,tileHeight:this.tileHeight,overlapFactor:this.options.overlapFactor}}updateTilesManager(){this.tilesManager=new u(this.context,this.targetContext,this.targetImageData,this.sizes)}updateFilters(t){this.filters=new a(this.options,this.tilesManager,t,this.finalWidth,this.finalHeight)}initializeTiles(){this.tilesManager.createTiles(),this.tilesManager.computeTiles()}paintTiles(){this.tilesManager.paintTiles()}filterTiles(){this.filters.applyFilters()}setCanvas(t,e,n){t=0|t||1,e=0|e||1,n=n||{width:0,height:0};const i=r.initializeCanvas(n);this.canvas=i.canvas,this.context=i.context;const a=r.initializeCanvas(null,t,e);this.targetCanvas=a.canvas,this.targetContext=a.context,this.targetImageData=new ImageData(t,e),this.finalWidth=t,this.finalHeight=e,this.tileWidth=Math.fround(this.canvas.width/this.targetCanvas.width),this.tileHeight=Math.fround(this.canvas.height/this.targetCanvas.height)}updateThreshold(){const t=this.tilesManager.getTiles();let e=[];for(let r=0;r<this.finalHeight;r++)for(let n=0;n<this.finalWidth;n++){const i=t[n+r*this.finalWidth];this.tilesManager.getNeighbors(n,r).forEach((t=>{e.push(c.colorDifference(i.meanColor,t.meanColor))}))}const n=e.reduce(((t,e)=>t+e),0)/e.length,i=Math.sqrt(e.map((t=>Math.pow(t-n,2))).reduce(((t,e)=>t+e))/e.length);return(n+i)/10}processImage(t,e,n){const i=Date.now();this.setCanvas(e,n,t);const r=Date.now();this.updateTilesManager();const a=Date.now();this.initializeTiles();const s=Date.now();this.updateFilters(this.updateThreshold());const o=Date.now();this.filterTiles();const l=Date.now();this.paintTiles();const h=Date.now();return console.log({setCanvas:r-i,updateTilesManager:a-r,initializeTiles:s-a,"updateFilters+updateThreshold":o-s,filterTiles:l-o,paintTiles:h-o}),this.targetContext}}class r{static initializeCanvas(t,e,n){let i,r;e=(t=t||{width:0,height:0}).width||e||1,n=t.height||n||1;try{i=new OffscreenCanvas(e,n),r=i.getContext("2d",{willReadFrequently:!0,desynchronized:!0})}catch(a){i=document.createElement("canvas"),i.width=e,i.height=n,r=i.getContext("2d",{willReadFrequently:!0})}return t instanceof ImageData?r.putImageData(t,0,0):t.width&&r.drawImage(t,0,0,e,n),{canvas:i,context:r}}static canvasContextToImageData(t){return t.getImageData(0,0,t.canvas.width,t.canvas.height)}}class a{constructor(t,e,n,i,r){this.mergeFilter=new h(n*t.mergeStrength,e,i,r),this.despeckleFilter=new o(n*t.despeckleStrength,e,i,r),this.quantizeFilter=new l(n*t.quantizeStrength,e,i,r)}applyFilters(){this.mergeFilter.apply(),this.despeckleFilter.apply(),this.quantizeFilter.apply()}}class s{constructor(t,e,n,i){this.strength=t,this.tilesManager=e,this.tiles=e.getTiles(),this.width=n,this.height=i}}class o extends s{constructor(t,e,n,i){super(t,e,n,i)}apply(){for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++)this.adaptiveDespeckleTile(e,t,this.strength)}adaptiveDespeckleTile(t,e,n){const i=this.tiles[t+e*this.width],r=this.tilesManager.getExtendedNeighbors(t,e,3),a=n*(1+this.calculateLocalContrast(i,r)),{primaryColor:s,secondaryColor:o,isEdge:l,isArea:h}=this.detectEdge(r,a);h?this.maybeApplyDespeckling(i,a,s,s):l&&this.maybeApplyDespeckling(i,a,s,o)}calculateLocalContrast(t,e){const n=c.averageColor(e.concat([t]).map((t=>t.meanColor))),i=e.concat([t]).reduce(((t,e)=>t+Math.pow(c.colorDifference(e.meanColor,n),2)),0)/e.length;return Math.sqrt(i)}detectEdge(t,e){const n=u.getTilesGroup(t,e),i=(n.length,t.length),r=(n[0]||[]).length||0,a=(n[1]||[]).length||0;return{primaryColor:c.averageColor(n[0].map((t=>t.meanColor))),secondaryColor:(n[1]||[]).length?c.averageColor(n[1].map((t=>t.meanColor))):null,isEdge:.777*i<=r+a,isArea:.666*i<=r}}maybeApplyDespeckling(t,e,n,i){c.colorDifference(t.meanColor,n)>e&&c.colorDifference(t.meanColor,i)>e&&t.meanColor.setRGBA(n.rgba)}}class l extends s{constructor(t,e,n,i){super(t,e,n,i)}apply(){const t=this.tiles.map((t=>t.meanColor.rgba)),e=new d(t,128).run(16);this.tiles.forEach(((t,n)=>{const i=e.clusters[n],r=e.centroids[i];t.meanColor.setRGBA(r)}))}}class h extends s{constructor(t,e,n,i){super(t,e,n,i)}apply(){for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++){const n=e+t*this.width,i=this.tiles[n],r=this.tilesManager.getNeighbors(e,t),a={};r.forEach(((t,e)=>{c.colorDifference(i.meanColor,t.meanColor)<this.strength&&(a[e]=t)})),Object.keys(a).length>=3&&Object.values(a).forEach((function(t){t.meanColor.setRGBA(i.meanColor.rgba)}))}}}class c{static colorDifference(t,e){return Math.sqrt(Math.pow(t.r-e.r,2)+Math.pow(t.g-e.g,2)+Math.pow(t.b-e.b,2)+Math.pow(t.a-e.a,2))}static averageColor(t){const e=new Uint32Array(4);t.forEach((t=>{const n=t.rgba;e[0]=(e[0]+n[0]|0)>>>0,e[1]=(e[1]+n[1]|0)>>>0,e[2]=(e[2]+n[2]|0)>>>0,e[3]=(e[3]+n[3]|0)>>>0}));const n=t.length;return new g(Uint8Array.of(e[0]/n|0,e[1]/n|0,e[2]/n|0,e[3]/n|0))}}class u{constructor(t,e,n,i){this.contextSource=t,this.contextDestination=e,this.imageData=n,this.overlapFactor=i.overlapFactor,this.finalWidth=i.finalWidth,this.finalHeight=i.finalHeight,this.tileWidth=i.tileWidth,this.tileHeight=i.tileHeight,this.tiles=Array(this.finalWidth*this.finalHeight).fill(null),this.tilesColorUint32a=new Uint32Array(this.finalWidth*this.finalHeight),this.tilesColorUint8a=new Uint8ClampedArray(this.tilesColorUint32a.buffer),this.extendedTileWidth=this.tileWidth*this.overlapFactor|0,this.extendedTileHeight=this.tileHeight*this.overlapFactor|0,this.tilePaddingWidth=(this.extendedTileWidth-this.tileWidth)/2|0,this.tilePaddingHeight=(this.extendedTileHeight-this.tileHeight)/2|0}static getTilesGroup(t,e){const n=[];return t.forEach((t=>{let i=!1;n.forEach((n=>{c.colorDifference(t.meanColor,n[0].meanColor)<e&&(n.push(t),i=!0)})),i||n.push([t])})),n.sort(((t,e)=>e.length-t.length)),n}getTiles(){return this.tiles}extractTileData(t,e){const n=Math.imul(t,this.tileWidth)-this.tilePaddingWidth|0,i=Math.imul(e,this.tileHeight)-this.tilePaddingHeight|0;return this.contextSource.getImageData(0|n,0|i,0|this.extendedTileWidth,0|this.extendedTileHeight)}createTiles(){for(let t=0;t<this.finalHeight;t++)for(let e=0;e<this.finalWidth;e++){const n=e+t*this.finalWidth,i=4*n;this.tiles[n]=new f(this.extractTileData(e,t),this.tilesColorUint8a.subarray(i,i+4))}}computeTiles(){for(let t=0;t<this.tiles.length;t++)this.tiles[t].calculateMeanColor()}getNeighbors(t,e){const n=[];for(let i=-1;i<=1;i++)for(let r=-1;r<=1;r++){const a=t+i,s=e+r;0===i&&0===r||a<0||s<0||a>=this.finalWidth||s>=this.finalHeight||a>=0&&a<this.finalWidth&&s>=0&&s<this.finalHeight&&n.push(this.tiles[a+s*this.finalWidth])}return n}getExtendedNeighbors(t,e,n){const i=[];for(let r=-n;r<=n;r++)for(let a=-n;a<=n;a++){const n=t+r,s=e+a;0===r&&0===a||n<0||s<0||n>=this.finalWidth||s>=this.finalHeight||i.push(this.tiles[n+s*this.finalWidth])}return i}paintTiles(){this.imageData.data.set(this.tilesColorUint8a),this.contextDestination.putImageData(this.imageData,0,0)}}class d{constructor(t,e){this.data=t,this.dataConstructor=Object.getPrototypeOf(t[0]).constructor,this.mean=new Uint32Array(t[0].length),this.k=e,this.centroids=Array(e),this.clusters=Array(this.data.length)}initializeCentroids(){for(let t=0;t<this.k;t++){const e=Math.floor(Math.random()*this.data.length);this.centroids[t]=this.dataConstructor.from(this.data[e])}}assignClusters(){this.data.forEach(((t,e)=>{let n=Number.MAX_VALUE,i=-1;this.centroids.forEach(((e,r)=>{const a=this.euclideanDistance(t,e);a<n&&(n=a,i=r)})),this.clusters[e]=i}))}updateCentroids(){let t=Array(this.k).fill(null).map((()=>[]));this.data.forEach(((e,n)=>{const i=this.clusters[n];t[i].push(e)})),this.centroids=t.map((t=>0===t.length?null:this.meanPoint(t))).filter((t=>null!==t))}euclideanDistance(t,e){return Math.sqrt(t.reduce(((t,n,i)=>t+Math.pow(n-e[i],2)),0))}meanPoint(t){var e,n;const i=t.length,r=t[0].length;for(this.mean.fill(0),e=0;e<i;e++)for(n=0;n<r;n++)this.mean[n]+=t[e][n];const a=new this.dataConstructor(r);for(n=0;n<r;n++)a[n]=this.mean[n]/i|0;return a}run(t){t=t||16,this.initializeCentroids();let e=0,n=!1;for(;!n&&e<t;){const t=[...this.centroids];this.assignClusters(),this.updateCentroids(),e++,n=this.centroids.every(((e,n)=>this.euclideanDistance(e,t[n])<1e-5))}return{centroids:this.centroids,clusters:this.clusters}}}class g{constructor(t){this.rgba_=t}get r(){return this.rgba_[0]}get g(){return this.rgba_[1]}get b(){return this.rgba_[2]}get a(){return this.rgba_[3]}get rgba(){return this.rgba_.subarray(0,4)}setRGBA(t){this.rgba_[0]=t[0],this.rgba_[1]=t[1],this.rgba_[2]=t[2],this.rgba_[3]=t[3]}}class f{constructor(t,e){this.imageData=t,this.meanColor=new g(e),this.map=new Uint32Array(0)}extractColorData(t){let e=[];for(let n=0;n<t.length;n+=4)e.push(new g(t.subarray(n,n+4)));return e}quantizeColors(t){t=t||Math.ceil(Math.sqrt(this.imageData.data.length));const e=this.imageData.data,n=this.extractColorData(e).map((function(t){return t.rgba}));return new d(n,7).run(21)}getQuantizedColor(t){t.centroids.length!==this.map.length?this.map=new Uint32Array(t.centroids.length):this.map.fill(0),t.clusters.forEach(((t,e)=>{this.map[t]=(this.map[t]+1|0)>>>0}));let e=0,n=0;return this.map.forEach(((t,i)=>{e<t&&(e=t,n=i)})),t.centroids[n]}calculateMeanColor(){const t=this.getQuantizedColor(this.quantizeColors());this.meanColor.setRGBA(t)}}var p=new i({strength:1.5});t.exports={scaler:p,ImageProcessor:i}},662:function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}var r=i(n(705)),a=i(n(923));t.exports={UJS:(t,e="COMPRESS_OBJECT",n=null)=>new Promise((function(n,i){"COMPRESS_OBJECT"===e?n(new Uint8ClampedArray(r.default.compress(a.default.pack(t)).buffer)):"DECOMPRESS_UINT8A"===e&&n(a.default.unpack(r.default.uncompress(t)))}))}},816:function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}var r=i(n(600)),a=i(n(127)),s=i(n(817));t.exports={base64png_to_xbrz_svg:(t,e,i,o,l=[],h="xbrz",c=!1,u=!1,d=!1)=>{let g=new Image;g.onload=()=>{var t,f,p;let m=document.createElement("canvas"),v=m.getContext("2d");const{width:y,height:w}=g;m.width=y,m.height=w,v.drawImage(g,0,0,y,w);let b=v.getImageData(0,0,y,w);const x=(t,e)=>new Promise((function(e,i){(0,a.default)((()=>n.e(20).then(n.t.bind(null,917,7)))).then((({crt:n})=>{n(t,1).then(e).catch(i)}))})),C=(t,e,i,s,o)=>{c?(0,a.default)((()=>n.e(1).then(n.t.bind(null,625,7)))).then((({oxi_png:l})=>{l(t,3,!1,r.default).then((t=>{o(t,e,i,s)})).catch((()=>{(0,a.default)((()=>n.e(0).then(n.t.bind(null,624,7)))).then((({png_quant:n})=>{n(t,25,50,1,r.default).then((t=>{o(t,e,i,s)})).catch((()=>{o(t,e,i,s)}))})).catch((()=>{o(t,e,i,s)}))}))})).catch((()=>{o(t,e,i,s)})):o(t,e,i,s)},D=(t,e)=>{u?(0,a.default)((()=>n.e(22).then(n.t.bind(null,643,7)))).then((({image_tracer:s})=>{s(t,{pal:l.map((t=>({r:parseInt(t.slice(1,3),16),g:parseInt(t.slice(3,5),16),b:parseInt(t.slice(5,7),16),a:parseInt(t.slice(7,9),16)}))),corsenabled:!1,ltres:e,qtres:e,pathomit:e,rightangleenhance:!1,colorsampling:2,numberofcolors:512,mincolorratio:0,colorquantcycles:1,layering:0,strokewidth:Math.ceil(e/2),linefilter:!0,scale:1,roundcoords:2,viewbox:!0,desc:!1,lcpr:0,qcpr:0,blurradius:e,blurdelta:4*e},r.default).then((t=>{c?(0,a.default)((()=>n.e(5).then(n.bind(null,690)))).then((({optimize:n})=>{t=n(t,{path:"path-to.svg",multipass:!0,mergePaths:!0,mergeStyles:!0,collapseGroups:!0,reusePaths:!0,plugin:["multipass","mergePaths","collapseGroups","reusePaths","mergeStyles"]}).data,i("data:image/svg+xml;base64,"+window.btoa(t),e)})):i("data:image/svg+xml;base64,"+window.btoa(t),e)}))})):i("",0)};if("depixelize"===h){const r=10;f=(t=(0,s.default)(b,u))[0],p=t[1];let l=document.createElement("canvas");l.width=f.width,l.height=f.height;let h=l.getContext("2d");h.putImageData(f,0,0);let g=h.canvas.toDataURL("image/png");d&&x(f).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,r,t.width,t.height,o)})),u&&(c?(0,a.default)((()=>n.e(5).then(n.bind(null,690)))).then((({optimize:t})=>{p=t(p,{path:"path-to.svg",multipass:!0,plugin:["mergePaths"]}).data,i("data:image/svg+xml;base64,"+window.btoa(p),r)})):i("data:image/svg+xml;base64,"+window.btoa(p),r)),C(g,r,f.width,f.height,e)}else"omniscale"===h?(0,a.default)((()=>n.e(23).then(n.t.bind(null,918,7)))).then((({omniscale:t})=>{t(b,8,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,8,t.width,t.height,o)})),D(t,8),C(r,8,t.width,t.height,e)}))})):"hexagon"===h?(0,a.default)((()=>n.e(4).then(n.t.bind(null,691,7)))).then((({hexagonrender:t})=>{t(b,16).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,16,t.width,t.height,o)})),D(t,32/6),C(r,32,t.width,t.height,e)}))})):"kikko"===h?(0,a.default)((()=>n.e(42).then(n.t.bind(null,919,7)))).then((({kikkorender:t})=>{t(b,24,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,24,t.width,t.height,o)})),D(t,6),C(r,48,t.width,t.height,e)}))})):"hqnx"===h?(0,a.default)((()=>n.e(21).then(n.t.bind(null,920,7)))).then((({hqnx:t})=>{t(b,4,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,4,t.width,t.height,o)})),D(t,4),C(r,4,t.width,t.height,e)}))})):"epx"===h?(0,a.default)((()=>n.e(19).then(n.t.bind(null,921,7)))).then((({epx:t})=>{t(b,4,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,4,t.width,t.height,o)})),D(t,4),C(r,4,t.width,t.height,e)}))})):(0,a.default)((()=>n.e(24).then(n.t.bind(null,607,7)))).then((t=>{t.default(b,6,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,6,t.width,t.height,o)})),D(t,6),C(r,6,t.width,t.height,e)}))}))},g.src=t}}},817:function(t,e,n){"use strict";function i(t){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i(t)}function r(){function t(t,e,n){return Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}),t[e]}function e(t,e,n,i){var r=e&&e.prototype instanceof a?e:a,s=Object.create(r.prototype),o=new f(i||[]);return b(s,"_invoke",{value:c(t,n,o)}),s}function n(t,e,n){try{return{type:"normal",arg:t.call(e,n)}}catch(i){return{type:"throw",arg:i}}}function a(){}function s(){}function o(){}function l(e){["next","throw","return"].forEach((function(n){t(e,n,(function(t){return this._invoke(n,t)}))}))}function h(t,e){function r(a,s,o,l){var h,c,u=n(t[a],t,s);if("throw"!==u.type)return(c=(h=u.arg).value)&&"object"==i(c)&&w.call(c,"__await")?e.resolve(c.__await).then((function(t){r("next",t,o,l)}),(function(t){r("throw",t,o,l)})):e.resolve(c).then((function(t){h.value=t,o(h)}),(function(t){return r("throw",t,o,l)}));l(u.arg)}var a;b(this,"_invoke",{value:function(t,n){function i(){return new e((function(e,i){r(t,n,e,i)}))}return a=a?a.then(i,i):i()}})}function c(t,e,i){var r="suspendedStart";return function(a,s){var o,l,h;if("executing"===r)throw Error("Generator is already running");if("completed"===r){if("throw"===a)throw s;return{value:void 0,done:!0}}for(i.method=a,i.arg=s;;){if((o=i.delegate)&&(l=u(o,i))){if(l===M)continue;return l}if("next"===i.method)i.sent=i._sent=i.arg;else if("throw"===i.method){if("suspendedStart"===r)throw r="completed",i.arg;i.dispatchException(i.arg)}else"return"===i.method&&i.abrupt("return",i.arg);if(r="executing","normal"===(h=n(t,e,i)).type){if(r=i.done?"completed":"suspendedYield",h.arg===M)continue;return{value:h.arg,done:i.done}}"throw"===h.type&&(r="completed",i.method="throw",i.arg=h.arg)}}}function u(t,e){var i,r,a=e.method,s=t.iterator[a];return void 0===s?(e.delegate=null,"throw"===a&&t.iterator.return&&(e.method="return",e.arg=void 0,u(t,e),"throw"===e.method)||"return"!==a&&(e.method="throw",e.arg=new TypeError("The iterator does not provide a '"+a+"' method")),M):"throw"===(i=n(s,t.iterator,e.arg)).type?(e.method="throw",e.arg=i.arg,e.delegate=null,M):(r=i.arg)?r.done?(e[t.resultName]=r.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,M):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,M)}function d(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function g(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function f(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(d,this),this.reset(!0)}function p(t){var e,n,i;if(t){if(e=t[C])return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length))return n=-1,(i=function e(){for(;++n<t.length;)if(w.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=void 0,e.done=!0,e}).next=i}return{next:m}}function m(){return{value:void 0,done:!0}}var v,y,w,b,x,C,D,_,M,k,E,T,I;r=function(){return v},v={},w=(y=Object.prototype).hasOwnProperty,b=Object.defineProperty||function(t,e,n){t[e]=n.value},x="function"==typeof Symbol?Symbol:{},C=x.iterator||"@@iterator",D=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag";try{t({},"")}catch(A){t=function(t,e,n){return t[e]=n}}return v.wrap=e,M={},t(k={},C,(function(){return this})),(T=(E=Object.getPrototypeOf)&&E(E(p([]))))&&T!==y&&w.call(T,C)&&(k=T),I=o.prototype=a.prototype=Object.create(k),s.prototype=o,b(I,"constructor",{value:o,configurable:!0}),b(o,"constructor",{value:s,configurable:!0}),s.displayName=t(o,_,"GeneratorFunction"),v.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===s||"GeneratorFunction"===(e.displayName||e.name))},v.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,o):(e.__proto__=o,t(e,_,"GeneratorFunction")),e.prototype=Object.create(I),e},v.awrap=function(t){return{__await:t}},l(h.prototype),t(h.prototype,D,(function(){return this})),v.AsyncIterator=h,v.async=function(t,n,i,r,a){void 0===a&&(a=Promise);var s=new h(e(t,n,i,r),a);return v.isGeneratorFunction(n)?s:s.next().then((function(t){return t.done?t.value:s.next()}))},l(I),t(I,_,"Generator"),t(I,C,(function(){return this})),t(I,"toString",(function(){return"[object Generator]"})),v.keys=function(t){var e,n=Object(t),i=[];for(e in n)i.push(e);return i.reverse(),function t(){for(;i.length;){var e=i.pop();if(e in n)return t.value=e,t.done=!1,t}return t.done=!0,t}},v.values=p,f.prototype={constructor:f,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(g),!t)for(var e in this)"t"===e.charAt(0)&&w.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){function e(e,i){return a.type="throw",a.arg=t,n.next=e,i&&(n.method="next",n.arg=void 0),!!i}var n,i,r,a,s,o;if(this.done)throw t;for(n=this,i=this.tryEntries.length-1;i>=0;--i){if(r=this.tryEntries[i],a=r.completion,"root"===r.tryLoc)return e("end");if(r.tryLoc<=this.prev)if(s=w.call(r,"catchLoc"),o=w.call(r,"finallyLoc"),s&&o){if(this.prev<r.catchLoc)return e(r.catchLoc,!0);if(this.prev<r.finallyLoc)return e(r.finallyLoc)}else if(s){if(this.prev<r.catchLoc)return e(r.catchLoc,!0)}else{if(!o)throw Error("try statement without catch or finally");if(this.prev<r.finallyLoc)return e(r.finallyLoc)}}},abrupt:function(t,e){var n,i,r,a;for(n=this.tryEntries.length-1;n>=0;--n)if((i=this.tryEntries[n]).tryLoc<=this.prev&&w.call(i,"finallyLoc")&&this.prev<i.finallyLoc){r=i;break}return r&&("break"===t||"continue"===t)&&r.tryLoc<=e&&e<=r.finallyLoc&&(r=null),(a=r?r.completion:{}).type=t,a.arg=e,r?(this.method="next",this.next=r.finallyLoc,M):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),M},finish:function(t){var e,n;for(e=this.tryEntries.length-1;e>=0;--e)if((n=this.tryEntries[e]).finallyLoc===t)return this.complete(n.completion,n.afterLoc),g(n),M},catch:function(t){var e,n,i,r;for(e=this.tryEntries.length-1;e>=0;--e)if((n=this.tryEntries[e]).tryLoc===t)return"throw"===(i=n.completion).type&&(r=i.arg,g(n)),r;throw Error("illegal catch attempt")},delegateYield:function(t,e,n){return this.delegate={iterator:p(t),resultName:e,nextLoc:n},"next"===this.method&&(this.arg=void 0),M}},v}function a(t,e){var n,i,r,a,s,o="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!o){if(Array.isArray(t)||(o=g(t))||e&&t&&"number"==typeof t.length)return o&&(t=o),n=0,{s:i=function(){},n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return r=!0,a=!1,{s:function(){o=o.call(t)},n:function(){var t=o.next();return r=t.done,t},e:function(t){a=!0,s=t},f:function(){try{r||null==o.return||o.return()}finally{if(a)throw s}}}}function s(t,e){if(e&&("object"===i(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function o(t){var e="function"==typeof Map?new Map:void 0;return o=function(t){function n(){return l(t,arguments,u(this).constructor)}if(null===t||(i=t,-1===Function.toString.call(i).indexOf("[native code]")))return t;var i;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),c(n,t)},o(t)}function l(t,e,n){return l=h()?Reflect.construct.bind():function(t,e,n){var i,r=[null];return r.push.apply(r,e),i=new(Function.bind.apply(t,r)),n&&c(i,n.prototype),i},l.apply(null,arguments)}function h(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function c(t,e){return c=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},c(t,e)}function u(t){return u=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},u(t)}function d(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n,i,r,a,s,o,l,h=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=h){s=[],o=!0,l=!1;try{if(r=(h=h.call(t)).next,0===e){if(Object(h)!==h)return;o=!1}else for(;!(o=(n=r.call(h)).done)&&(s.push(n.value),s.length!==e);o=!0);}catch(c){l=!0,i=c}finally{try{if(!o&&null!=h.return&&(a=h.return(),Object(a)!==a))return}finally{if(l)throw i}}return s}}(t,e)||g(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function g(t,e){if(t){if("string"==typeof t)return f(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?f(t,e):void 0}}function f(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=Array(e);n<e;n++)i[n]=t[n];return i}function p(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function m(t,e){var n,r,a;for(n=0;n<e.length;n++)(r=e[n]).enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,(a=function(t,e){var n,r;if("object"!==i(t)||null===t)return t;if(void 0!==(n=t[Symbol.toPrimitive])){if("object"!==i(r=n.call(t,"string")))return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return t+""}(r.key),"symbol"===i(a)?a:a+""),r)}function v(t,e,n){return e&&m(t.prototype,e),n&&m(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}Object.defineProperty(e,"__esModule",{value:!0});var y=function(){function t(t,e,n){return[l(t,e,n),g(t,e,n),l(t,e+1,n),g(t,e,n+1)]}function e(t,e,n,i,r){var a,s=Array(r);for(a=0;a<r;++a)s[a]=t[a+n].slice(e,e+i);return s}function n(){this.vertices=[]}var i,l,g,f,m,y,w,b,x,C=function(){function t(e){var n,i=d(e,3),r=i[0],a=i[1],s=i[2];p(this,t),n=.299*r+.587*a+.114*s,this.y=Math.round(n),this.u=Math.round(.492*(s-n)),this.v=Math.round(.877*(r-n)),this.r=r,this.g=a,this.b=s,this.rgb=[r,a,s]}return v(t,[{key:"dissimilar",value:function(t){return Math.abs(this.r-t.r)+Math.abs(this.g-t.g)+Math.abs(this.b-t.b)>=1}},{key:"toString",value:function(){return"rgb("+this.rgb.join()+")"}}]),t}(),D=function(){function t(e,n){p(this,t),this.x=e,this.y=n,this.edges=[]}return v(t,[{key:"split",value:function(e){return new t((this.x+e.x)/2,(this.y+e.y)/2)}},{key:"adjust",value:function(t,e){return this.x+=t,this.y+=e,this}},{key:"clone",value:function(){return new t(this.x,this.y)}},{key:"equals",value:function(t){return this.x===t.x&&this.y===t.y}},{key:"addEdge",value:function(t){-1==this.edges.indexOf(t)&&(this.edges.push(t),t.addEdge(this))}}]),t}(),_=function(t){function e(t){var n;return p(this,e),(n=r.call(this,1))[0]=t,n.circular=!1,n}!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&c(t,e)}(e,t);var n,i,r=(n=e,i=h(),function(){var t,e,r=u(n);return i?(e=u(this).constructor,t=Reflect.construct(r,arguments,e)):t=r.apply(this,arguments),s(this,t)});return v(e,[{key:"splitAt",value:function(t){var n,i,r,s,o;if(1!==this.length){if(this[0]===t)this.shift();else if(this[this.length-1]===t)this.pop();else if(this.circular)for(n=this.shift();n!==t;n=this.shift())this.push(n);else{i=this.indexOf(t),s=a(r=this.slice(i+1));try{for(s.s();!(o=s.n()).done;)o.value.curve=r}catch(l){s.e(l)}finally{s.f()}this.length=i}t.curve=new e(t)}}},{key:"merge",value:function(t){var e,n,i,r,a,s;if(this!==t)for(n=(e=d([this,t].sort((function(t,e){return t.length-e.length})),2))[0],-1!==(i=e[1])[0].edges.indexOf(n[0])?(r=this.shift,a=this.unshift):-1!==i[0].edges.indexOf(n[n.length-1])?(r=this.pop,a=this.unshift):-1!==i[i.length-1].edges.indexOf(n[0])?(r=this.shift,a=this.push):-1!==i[i.length-1].edges.indexOf(n[n.length-1])&&(r=this.pop,a=this.push);n.length;)s=r.call(n),a.call(i,s),s.curve=i;else this.circular=t.length>2}}],[{key:"curve",value:function(t,e){return t.curve===e.curve?t.curve.length:0}}]),e}(o(Array)),M=function(){function t(e,n,i,r){p(this,t),this.x=e,this.y=n,this.edges=[,,,,,,,,],this.vertices=r||[],this.color=i,this.marked=!1,this.curve=new _(this)}return v(t,[{key:"relativePosition",value:function(t){var e=t.x,n=t.y-this.y;return(e-this.x+3*n+8)%9}},{key:"invalidCurve",value:function(){return this.valence()>2&&this.curve.length>1}},{key:"updateCurves",value:function(){this.valence()>2&&this.curve.splitAt(this)}},{key:"equals",value:function(t){return this.x===t.x&&this.y===t.y}},{key:"removeEdge",value:function(e){t.removeEdge(this,e)}},{key:"canReach",value:function(t){return t&&!!this.edges[this.relativePosition(t)]}},{key:"valence",value:function(){return this.edges.filter((function(t){return t})).length}},{key:"toString",value:function(){return"("+[this.x,this.y].join()+") => "+this.edges.filter((function(t){return t})).map((function(t){return"("+[t.x,t.y].join()+")"})).join()}},{key:"edge",value:function(t,e){return this.edges[(t+3*e+8)%9]}},{key:"right",value:function(){return this.edges[0]}},{key:"left",value:function(){return this.edges[7]}},{key:"up",value:function(){return this.edges[5]}},{key:"down",value:function(){return this.edges[2]}},{key:"isEdge",value:function(){return this.edges.filter((function(t){return t})).length<4}},{key:"follow",value:r().mark((function t(e){var n,i,a;return r().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=this;case 1:if(!(n.canReach(e)&&n.valence()<3)){t.next=14;break}return t.next=4,e;case 4:if(!(e.valence()>2)){t.next=6;break}return t.abrupt("break",14);case 6:if(i=e.edges.filter((function(t){return t})),a=i[0]!=n?i[0]:i[1],n=e,(e=a)!=this){t.next=12;break}return t.abrupt("break",14);case 12:t.next=1;break;case 14:case"end":return t.stop()}}),t,this)}))},{key:"square",value:function(){var t=d(this.edges,3),e=t[0],n=t[2],i=e&&n&&e.down()&&n.right();return[this,e,n,i].filter((function(t){return t}))}}],[{key:"addSimilarEdge",value:function(t,e){t.color&&e.color&&!t.color.dissimilar(e.color)&&(t.edges[t.relativePosition(e)]=e,e.edges[e.relativePosition(t)]=t,t.valence()>2&&t.curve.splitAt(t),e.valence()>2&&e.curve.splitAt(e),t.valence()<3&&e.valence()<3&&t.curve.merge(e.curve))}},{key:"removeEdge",value:function(t,e){t.edges[t.relativePosition(e)]=void 0,e.edges[e.relativePosition(t)]=void 0}}]),t}(),k=function(){function t(e,n,i){if(p(this,t),e.length!=n*i*4)throw Error("Wrong dimension of pixel buffer");this.width=n,this.height=i,this.pixels=e}return v(t,[{key:"create",value:r().mark((function t(){var e,n,i,a,s,o,l,h,c,u,d,g,f,p,m;return r().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:for(e=this.width,n=this.height,i=Array(n),(a=Array(n+1))[0]=Array(e+1),s=0;s<e+1;++s)a[0][s]=new D(s,0);o=new M,l=Array(e).fill(o),s=0;case 9:if(!(s<n)){t.next=31;break}h=[o,o],c=i[s]=Array(e),u=a[s],(d=a[s+1]=Array(e+1))[0]=new D(0,s+1),g=0;case 16:if(!(g<e)){t.next=27;break}return d[g+1]=new D(g+1,s+1),f=[u[g],u[g+1],d[g+1],d[g]],p=c[g]=new M(g,s,this.pixel(g,s),f),m=[l[g],p],t.next=23,[h,m];case 23:h=m;case 24:++g,t.next=16;break;case 27:l=c;case 28:++s,t.next=9;break;case 31:this.nodes_old=i,this.vertices=i;case 33:case"end":return t.stop()}}),t,this)}))},{key:"createSimilarityGraph",value:function(){var t,e,n,i,r,s,o,l,h=a(this.create());try{for(h.s();!(t=h.n()).done;)e=d(t.value,2),i=(n=d(e[0],2))[0],r=n[1],o=(s=d(e[1],2))[0],l=s[1],M.addSimilarEdge(o,l),M.addSimilarEdge(r,l),4!==i.square().length&&(M.addSimilarEdge(o,r),M.addSimilarEdge(i,l))}catch(c){h.e(c)}finally{h.f()}return this}},{key:"graph",value:function(){this.height,this.width}},{key:"nodes",value:r().mark((function(){var t,e,n,i,a;return r().wrap((function(r){for(;;)switch(r.prev=r.next){case 0:n=this.width,i=this.height,a=this.nodes_old,e=0;case 2:if(!(e<i)){r.next=13;break}t=0;case 4:if(!(t<n)){r.next=10;break}return r.next=7,a[e][t];case 7:++t,r.next=4;break;case 10:++e,r.next=2;break;case 13:case"end":return r.stop()}}),a,this)}))},{key:"diagonals",value:r().mark((function t(){var e,n,i,a,s,o,l,h,c,u,d;return r().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:s=this.width,o=this.height,l=this.nodes_old,n=1;case 2:if(!(n<o)){t.next=22;break}i=l[n-1],a=l[n],e=1;case 6:if(!(e<s)){t.next=19;break}if(h=i[e-1],c=i[e],u=a[e-1],d=a[e],!(h.canReach(c)||h.canReach(u)||d.canReach(c)||d.canReach(u))){t.next=13;break}return t.abrupt("continue",16);case 13:if(!h.canReach(d)||!c.canReach(u)){t.next=16;break}return t.next=16,[[h,d],[u,c]];case 16:++e,t.next=6;break;case 19:++n,t.next=2;break;case 22:case"end":return t.stop()}}),t,this)}))},{key:"pixel",value:function(t,e){var n=e*this.width*4+4*t;return new C(this.pixels.subarray(n,n+3))}}]),t}();return k.diagonals=function(t){return t[0][0].canReach(t[0][1])+t[1][0].canReach(t[1][1])},l=(i=function(t,e){var n=t,i=e;return function(t,e,r){return[t[r][e],t[r+i][e+n]]}})(0,1),g=i(1,0),f=i(1,1),m=i(1,-1),k.prototype.getDiagonals=function(t,e){return[f(this.nodes_old,t,e),m(this.nodes_old,t,e+1)]},y=function(t){return t[0].canReach(t[1])},w=function(t){return!t},b=function(t,e,n,i){return function(r){var a,s;for(r=r[0].edges.filter((function(t){return t})),a=[];r.length>0;)s=r.pop(),-1==a.indexOf(s)&&s.x>t&&s.x<e&&s.y>n&&s.y<i&&(a.push(s),r=r.concat(s.edges.filter((function(t){return t}))));return a}},k.prototype.linearize=function(){var e,n,i,r,a,s,o,l,h;for(e=1;e<this.width;++e)for(n=1;n<this.height;++n)t(this.nodes_old,e-1,n-1).map(y).every(w)&&(r=[0,0],a=(i=this.getDiagonals(e-1,n-1)).map(b(e-3,e+2,n-3,n+2)),(o=(s=i.map((function(t){return _.curve(t[0],t[1])})))[0]-s[1])>0?r[0]+=o:r[1]-=o,(l=a[0].length-a[1].length)>0?r[1]+=l:r[0]-=l,(h=i.map((function(t){return 1==t[0].valence()||1==t[1].valence()})))[0]&&!h[1]?r[0]+=5:!h[0]&&h[1]&&(r[1]+=5),r[0]>r[1]?M.removeEdge(i[1][0],i[1][1]):r[0]<r[1]?M.removeEdge(i[0][0],i[0][1]):(M.removeEdge(i[0][0],i[0][1]),M.removeEdge(i[1][0],i[1][1])));return this},x=function(t){var e,n,i,r=t[0][1];r.edge(-1,1)&&(i=(n=(e=r.vertices)[3]).clone(),r.down()||n.adjust(.25,.25),r.left()||i.adjust(-.25,-.25),t[0][0].vertices[2]=i,e.splice(4,0,i),i=(e=t[1][0].vertices).splice(0,1,i).pop(),e.push(i)),r.edge(1,1)&&(i=(n=(e=r.vertices)[2]).clone(),r.down()||n.adjust(-.25,.25),r.right()||i.adjust(.25,-.25),t[0][2].vertices[3]=i,e.splice(2,0,i),i=(e=t[1][2].vertices).splice(0,1,i).pop(),e.push(i))},k.prototype.createVoronoiDiagram=function(){var t,n,i,r=this.width-2,a=this.height-1,s=this.nodes_old;for(t=0;t<a;++t){for((n=e(s,0,t,2,2))[0].unshift(new M),n[1].unshift(new M),x(n),i=0;i<r;++i)x(e(s,i,t,3,2));(n=e(s,i,t,2,2))[0].push(new M),n[1].push(new M),x(n)}return this},k.prototype.contour=function(t){var e,n,i,r,a,s,o,l,h,c,u=t,d=[];if(0===u.valence())return u.vertices.slice();if(u.marked||!u.isEdge()||[[-1,-1],[0,-1],[1,-1]].some((function(t){return null!=this.edge.apply(this,t)}),u))return d;for(n=[],i=1,r=0,u.vertices[0],s=null;;){switch(u.marked=!0,n.push(u),e=void 0,i){case 1:if(e=u.edge(1,-1)){i=7;break}case 2:if(e=u.edge(1,0)){i=0;break}case 3:if(e=u.edge(1,1)){i=1;break}case 4:if(e=u.edge(0,1)){i=2;break}case 5:if(e=u.edge(-1,1)){i=3;break}case 6:if(e=u.edge(-1,0)){i=4;break}case 7:if(e=u.edge(-1,-1)){i=5;break}case 0:i=(e=u.edge(0,-1))?6:1}if(e){for(o=r,l=u.vertices.length,s&&e.equals(s)&&(a=u.vertices[o++%l],d.push(a));;){if(a=u.vertices[o++%l],-1!=(h=e.vertices.indexOf(a))){r=h;break}d.push(a)}if(t.equals(e)&&t.edges.filter((function(t){return t})).every((function(t){return t.marked||!t.isEdge()}))){for(o=r,l=e.vertices.length;o<l;)a=e.vertices[o++],d.push(a);break}s=u,u=e}}for(;0!=n.length;)(c=n.pop().edges.filter((function(t){return t&&!t.marked}))).forEach((function(t){t.marked=!0})),n.push.apply(n,c);return d},n.prototype=Object.create(null,{push:{enumerable:!1,value:function(t){this.vertices.push(t),t.addPath(this)}},splitAt:{enumerable:!1,value:function(t){var e=new n;e.vertices=this.vertices.slice(t),this.vertices.length=t+1,e.vertices.forEach((function(t){t.removePath(this),t.addPath(e)}))}}}),k.prototype.paths=function(t){new n},function(t,e,n){return new k(t,e,n)}}();e.default=function(t,e,n){var i,r=y(t.data,t.width,t.height);return r.createSimilarityGraph(),r.createVoronoiDiagram(),r.linearize(),i=function(t,e,n,i){var r,a,s,o,l=t.width,h=t.height,c=(t.nodes,document.createElement("canvas"));c.width=l*e,c.height=h*e,(r=c.getContext("2d")).strokeStyle="black";for(let u of t.nodes()){for(r.strokeStyle=u.color,r.lineWidth=e,a=u.vertices,r.beginPath(),s=a[0],r.moveTo(s.x*e,s.y*e),o=1;o<a.length;++o)s=a[o],r.lineTo(s.x*e,s.y*e);r.closePath(),r.stroke()}for(let u of t.nodes()){for(r.fillStyle=u.color,a=u.vertices,r.beginPath(),s=a[0],r.moveTo(s.x*e,s.y*e),o=1;o<a.length;++o)s=a[o],r.lineTo(s.x*e,s.y*e);r.closePath(),r.fill()}return r}(r,e).canvas.toDataURL("image/jpeg",n),function(t,e){t.width,t.height;var n,i,r,a,s=t.nodes(),o=[],l=[];for(let h of s){for(n="L",r=(i=h.vertices)[0],a=0;a<i.length;++a)r=i[a],n+=`${Math.ceil(r.x*e)},${Math.ceil(r.y*e)} `;o.push(`<path stroke-width="10" stroke="${h.color}" d="M${Math.ceil(i[0].x*e)},${Math.ceil(i[0].y*e)} ${n}Z"/>`),l.push(`<path fill="${h.color}" d="M${Math.ceil(i[0].x*e)},${Math.ceil(i[0].y*e)} ${n}Z"/>`)}o.join("\n\t"),l.join("\n\t")}(r,e),i}},818:function(t,e,n){"use strict";var i=n(819);t.exports={loadJSON:function(t,e){let n=new XMLHttpRequest;try{n=new XMLHttpRequest}catch(i){try{n=new ActiveXObject("Msxml2.XMLHTTP")}catch(i){try{n=new ActiveXObject("Microsoft.XMLHTTP")}catch(i){e("Cannot load data",null)}}}n.open("GET",t,!0),n.onreadystatechange=function(){if(4==n.readyState&&200==n.status)try{let t=JSON.parse(n.responseText);e(null,t)}catch(i){e("Cannot understand response from network.",null)}else 4==n.readyState&&404==n.status&&e("Error 404",null)};try{n.send()}catch(i){e("Failed to fetch",null)}},postJSON:function(t,e,n,r="application/x-www-form-urlencoded"){let a=new Headers;a.append("Content-Type",r);let s="multipart/form-data"===r?new FormData:new URLSearchParams;Object.entries(e).forEach((t=>{const[e,n]=t;s.append(e,n)}));let o={method:"POST",redirect:"follow",headers:a,body:"application/text"===r?e:"application/json"===r?(0,i.clean_json_text)(JSON.stringify(e)):s};fetch(t,o).then((t=>t.text())).then((t=>n(null,t))).catch((t=>n(t,null)))},postDATA:function(t,e,n){let i=new XMLHttpRequest;try{i=new XMLHttpRequest}catch(r){try{i=new ActiveXObject("Msxml2.XMLHTTP")}catch(r){try{i=new ActiveXObject("Microsoft.XMLHTTP")}catch(r){return void n("Cannot load data",null)}}}i.open("POST",t,!0),i.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),i.onreadystatechange=function(){if(4==i.readyState&&200==i.status)try{let t=JSON.parse(i.responseText);n(null,t)}catch(r){n("Cannot understand response from network.",null)}else 4==i.readyState&&404==i.status&&n("Error 404",null)};try{i.send(e)}catch(r){n("Failed to post",null)}}}},819:function(t,e,n){"use strict";t.exports={clean_json_text:function(t){return(t=t.replace(/\\n/g,"\\n").replace(/\\'/g,"\\'").replace(/\\"/g,'\\"').replace(/\\&/g,"\\&").replace(/\\r/g,"\\r").replace(/\\t/g,"\\t").replace(/\\b/g,"\\b").replace(/\\f/g,"\\f")).replace(/[\u0000-\u0019]+/g,"")}}}}]);