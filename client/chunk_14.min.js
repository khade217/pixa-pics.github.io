/*! For license information please see chunk_14.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{600:function(t,e,n){"use strict";var i,r;Object.defineProperty(e,"__esModule",{value:!0}),i=(r=n(626))&&r.__esModule?r:{default:r},e.default=i.default.pool({minWorkers:0,maxWorkers:3})},602:function(t,e,n){"use strict";var i=new(n(610).B64chromium);t.exports={bytesToBase64:i.bytesToBase64.bind(i),base64ToBytes:i.base64ToBytes.bind(i)}},603:function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}var r=i(n(604)),a=i(n(605));t.exports=function(t,e=!1){let n=(0,r.default)(t);if(e){const t=/(?:#)[0-9a-f]{8}|(?:#)[0-9a-f]{6}|(?:#)[0-9a-f]{4}|(?:#)[0-9a-f]{3}/gi;n.match(t).forEach((function(t){const[e,i,r]=t.match(/\w\w/g).map((t=>parseInt(t,16))),a=Math.round((e+i+r)/3),o=function(t,e,n){return t=t.toString(16),e=e.toString(16),n=n.toString(16),1==t.length&&(t="0"+t),1==e.length&&(e="0"+e),1==n.length&&(n="0"+n),"#"+t+e+n}(a,a,a);n=n.replace(t,o)}))}return(0,a.default)(n)}},612:function(t,e,n){"use strict";var i=n(602);t.exports={createLocalBlob:function(t){var e,n,r,a,o=(t.match(/(data\:([a-z]+\/[a-z\+]+)\;base64\,)([a-zA-Z0-9\/\+]+\(\=+)?/)||[,,])[1];return o?(n=(e=o.match(/data\:([a-z]+\/[a-z\+]+)\;base64\,/)[1]).match(/[a-z]+\/([a-z\+]+)/)[1],t=t.replace(o,""),r=(0,i.base64ToBytes)(t),a=new File([r],"name."+n,{type:e}),URL.createObjectURL(a)):""}}},629:function(t,e,n){"use strict";var i,r,a=(i=n(127))&&i.__esModule?i:{default:i},o=n(630);const s=Object.getPrototypeOf((r=function*(){},function(){var t=r.apply(this,arguments);return new Promise((function(e,n){return function i(r,a){var o,s;try{s=(o=t[r](a)).value}catch(h){return void n(h)}if(!o.done)return Promise.resolve(s).then((function(t){i("next",t)}),(function(t){i("throw",t)}));e(s)}("next")}))})).constructor,h=Object.getPrototypeOf((function(){})).constructor;window.file_to_base64_process_function=new h('var t = function(file) {\n    "use strict";\n    \n    try {\n        \n        return new Promise(function(resolve, _) {\n            resolve(new FileReaderSync().readAsDataURL(file));\n        });\n        \n    } catch(error) {\n    \n        return new Promise(function(resolve, _) {\n            var reader = new FileReader();\n            reader.onload = function(){ resolve(reader.result)};\n            reader.readAsDataURL(file);\n        });\n    }\n    \n}; return t;')();const l=(t,e=(()=>{}),n=null)=>{null!==n?n.exec(window.file_to_base64_process_function,[t]).catch((e=>window.file_to_base64_process_function(t))).timeout(5e3).then((t=>{e(t)})):window.file_to_base64_process_function(t).then((t=>{e(t)}))};window.base64_sanitize_process_function=new h('var t = function(base64, scale, ) {\n   /* MIT Licence 2024 Matias Affolter */\n    "use strict";\n    class ImageProcessor {\n        constructor(despeckleStrength, quanitzeStrength, mergeStrength) {\n            this.canvas = document.createElement(\'canvas\');\n            this.targetCanvas = document.createElement(\'canvas\');\n            this.despeckleStrength = despeckleStrength || 1.0;\n            this.quanitzeStrength = quanitzeStrength || 1.0;\n            this.mergeStrength = mergeStrength || 1.0;\n            this.overlapFactor = 1.0;\n         }\n        setCanvas(image, width, height){\n    \n            this.canvas.width = image.width;\n            this.canvas.height = image.height;\n            this.context = this.canvas.getContext(\'2d\', {willReadFrequently: true, powerPreference: "high-performance", alpha: true, desynchronized: true});\n            if(image instanceof ImageData){\n                this.context.putImageData(image, 0, 0);\n            }else {\n                this.context.drawImage(image, 0, 0);\n            }\n    \n            this.targetCanvas.width = width;\n            this.targetCanvas.height = height;\n            this.targetContext = this.targetCanvas.getContext(\'2d\', {willReadFrequently: true, powerPreference: "high-performance", alpha: true, desynchronized: true});\n            this.finalWidth = width;\n            this.finalHeight = height;\n            this.tileWidth = Math.fround(this.canvas.width / width);\n            this.tileHeight = Math.fround(this.canvas.height / height);\n    \n            //this.imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height)\n            this.targetImageData = this.targetContext.getImageData(0, 0, this.targetCanvas.width, this.targetCanvas.height);\n            this.tiles = new Array(this.finalHeight * this.finalHeight);\n        }\n        paintTargetImage(x, y, color) {\n            const targetImageDataData = this.targetImageData.data;\n            const index = (x + y * this.finalWidth)*4;\n            targetImageDataData[index] = color.r;\n            targetImageDataData[index+1] = color.g;\n            targetImageDataData[index+2] = color.b;\n            targetImageDataData[index+3] = color.a;\n        }\n        reconstructImage() {\n            for (let y = 0; y < this.finalHeight; y++) {\n                for (let x = 0; x < this.finalWidth; x++) {\n                    const tile = this.tiles[x+y*this.finalWidth];\n                    this.paintTargetImage(x, y, tile.meanColor)\n                }\n            }\n            this.targetContext.putImageData(this.targetImageData, 0, 0);\n        }\n    \n        createTiles() {\n            for (let y = 0; y < this.finalHeight; y++) {\n                for (let x = 0; x < this.finalWidth; x++) {\n                    const tileId = x+y*this.finalWidth;\n                    const tileData = this.extractTileData(x, y);\n                    const tile = new Tile({x, y},  tileData);\n                    tile.calculateMeanColor();\n                    this.tiles[tileId] = tile;\n                }\n            }\n        }\n    \n        extractTileData(x, y) {\n            // Calculate new width and height with overlap\n            const extendedTileWidth = this.tileWidth * this.overlapFactor;\n            const extendedTileHeight = this.tileHeight * this.overlapFactor;\n    \n            // Adjust x and y to keep tiles centered with the new size\n            const newX = x * this.tileWidth - (extendedTileWidth - this.tileWidth) / 2;\n            const newY = y * this.tileHeight - (extendedTileHeight - this.tileHeight) / 2;\n    \n            return this.context.getImageData(newX|0, newY|0, extendedTileWidth|0, extendedTileHeight|0);\n        }\n    \n        calculateDynamicThreshold() {\n            let colorDifferences = [];\n            for (let y = 0; y < this.finalHeight; y++) {\n                for (let x = 0; x < this.finalWidth; x++) {\n                    const tile = this.tiles[x + y * this.finalWidth];\n                    const neighbors = this.getNeighbors(x, y);\n                    neighbors.forEach(neighbor => {\n                        colorDifferences.push(this.colorDifference(tile.meanColor, neighbor.meanColor));\n                    });\n                }\n            }\n            const mean = colorDifferences.reduce((a, b) => a + b, 0) / colorDifferences.length;\n            const stdDev = Math.sqrt(colorDifferences.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / colorDifferences.length);\n            return (mean + stdDev) / 7; // Example of dynamic threshold\n        }\n    \n        mergeSimilarAreaTiles(threshold) {\n            for (let y = 0; y < this.finalHeight; y++) {\n                for (let x = 0; x < this.finalWidth; x++) {\n                    const tileIndex = x + y * this.finalWidth;\n                    const tile = this.tiles[tileIndex];\n                    const neighbors = this.getNeighbors(x, y);\n                    const map = {};\n                    neighbors.forEach((neighbor, index) => {\n                        const colorDifference = this.colorDifference(tile.meanColor, neighbor.meanColor);\n                        if (colorDifference < threshold) {\n                            map[index] = neighbor;\n                        }\n                    });\n    \n                    if(Object.keys(map).length >= 3){\n                        const averageNeighborColor = this.averageColor(neighbors);\n                        Object.values(map).forEach(function (neighbor){\n                            neighbor.meanColor = tile.meanColor;\n                        });\n                    }\n                }\n            }\n        }\n    \n        despeckle(threshold) {\n            for (let y = 0; y < this.finalHeight; y++) {\n                for (let x = 0; x < this.finalWidth; x++) {\n                    this.adaptiveDespeckleTile(x, y, threshold);\n                }\n            }\n        }\n    \n        adaptiveDespeckleTile(x, y, baseThreshold) {\n            const tile = this.tiles[x + y * this.finalWidth];\n            const neighbors = this.getExtendedNeighbors(x, y, 3); // Larger neighborhood\n    \n            // Calculate local contrast and adjust threshold\n            const localContrast = this.calculateLocalContrast(tile, neighbors);\n            const adjustedThreshold = baseThreshold * (1 + localContrast);\n    \n            // Basic edge detection by checking dominant areas\n            const { primaryColor, secondaryColor, isEdge, isArea } = this.detectEdge(neighbors, adjustedThreshold);\n            if (isArea) {\n                this.maybeApplyDespeckling(tile, adjustedThreshold, primaryColor, primaryColor);\n            } else if(isEdge) {\n                this.maybeApplyDespeckling(tile, adjustedThreshold, primaryColor, secondaryColor);\n            }\n        }\n    \n        getTilesGroup(tiles, threshold) {\n            const group = [];\n            tiles.forEach((tile) => {\n                let foundGroup = false;\n                group.forEach((group) => {\n                    if(this.colorDifference(tile.meanColor, group[0].meanColor) < threshold){\n                        group.push(tile);\n                        foundGroup = true;\n                    }\n                });\n                if(!foundGroup){\n                    group.push([tile]);\n                }\n            });\n    \n            group.sort((g1, g2) => g2.length-g1.length);\n            return group;\n        }\n    \n        detectEdge(neighbors, threshold) {\n    \n            const neighborGroup = this.getTilesGroup(neighbors, threshold);\n            const areaNumber = neighborGroup.length;\n            const colorNumber = neighbors.length;\n    \n            const primaryGroupNumber = (neighborGroup[0] || []).length || 0;\n            const secondaryGroupNumber = (neighborGroup[1] || []).length || 0;\n    \n            const primaryColor = this.averageColor(neighborGroup[0]);\n            const secondaryColor = (neighborGroup[1] || []).length ? this.averageColor(neighborGroup[1]): null;\n            const isEdge = colorNumber * 2/3 <= primaryGroupNumber + secondaryGroupNumber;\n            const isArea = colorNumber * 2/3 <= primaryGroupNumber;\n    \n            return { primaryColor, secondaryColor, isEdge, isArea };\n        }\n    \n        maybeApplyDespeckling(tile, adjustedThreshold, primaryColor, secondaryColor) {\n    \n            if(\n                this.colorDifference(tile.meanColor, primaryColor) > adjustedThreshold &&\n                this.colorDifference(tile.meanColor, secondaryColor) > adjustedThreshold\n            ){\n                tile.meanColor = primaryColor;\n            }\n        }\n    \n        getExtendedNeighbors(x, y, range) {\n            const neighbors = [];\n            for (let dx = -range; dx <= range; dx++) {\n                for (let dy = -range; dy <= range; dy++) {\n                    const nx = x + dx;\n                    const ny = y + dy;\n                    if (dx === 0 && dy === 0) continue;\n                    if (nx < 0 || ny < 0) continue;\n                    if (nx >= this.finalWidth || ny >= this.finalHeight) continue;\n    \n                    neighbors.push(this.tiles[nx + ny * this.finalWidth]);\n                }\n            }\n            return neighbors;\n        }\n    \n        calculateLocalContrast(tile, neighbors) {\n            // Example: Simple contrast calculation based on color variance\n            const meanColor = this.averageColor(neighbors.concat([tile]));\n            const variance = neighbors.concat([tile]).reduce((variance, neighbor) => {\n                return variance + Math.pow(this.colorDifference(neighbor.meanColor, meanColor), 2);\n            }, 0) / neighbors.length;\n            return Math.sqrt(variance);\n        }\n    \n    \n        getNeighbors(x, y) {\n            const neighbors = [];\n            for (let dx = -1; dx <= 1; dx++) {\n                for (let dy = -1; dy <= 1; dy++) {\n    \n                    const nx = x + dx;\n                    const ny = y + dy;\n    \n                    if (dx === 0 && dy === 0) continue;\n                    if (nx < 0 || ny < 0) continue;\n                    if (nx >= this.finalWidth || ny >= this.finalHeight) continue;\n    \n                    if (nx >= 0 && nx < this.finalWidth && ny >= 0 && ny < this.finalHeight) {\n                        neighbors.push(this.tiles[nx + ny * this.finalWidth]);\n                    }\n                }\n            }\n            return neighbors;\n        }\n    \n        averageColor(tiles) {\n            const sumColor = new Uint32Array(4);\n            tiles.forEach(tile => {\n                const rgba = tile.meanColor.rgba;\n                sumColor[0] += rgba[0];\n                sumColor[1] += rgba[1];\n                sumColor[2] += rgba[2];\n                sumColor[3] += rgba[3];\n            });\n    \n            const numTiles = tiles.length;\n            return new Pixel(sumColor[0] / numTiles|0, sumColor[1] / numTiles | 0, sumColor[2] / numTiles | 0, sumColor[3] / numTiles | 0, 0);\n        }\n    \n        colorDifference(color1, color2) {\n            return Math.sqrt(\n                Math.pow(color1.r - color2.r, 2) +\n                Math.pow(color1.g - color2.g, 2) +\n                Math.pow(color1.b - color2.b, 2) +\n                Math.pow(color1.a - color2.a, 2)\n            );\n        }\n    \n        processImage(image, width, height) {\n    \n            this.setCanvas(image, width, height);\n            if(image.width === width && image.height === height){ return this.context; }\n            this.createTiles();\n            const threshold = this.calculateDynamicThreshold();\n            this.mergeSimilarAreaTiles(threshold*this.mergeStrength);\n            this.mergeSimilarTilesColor(threshold*this.quanitzeStrength)\n            this.despeckle(threshold*this.despeckleStrength);\n    \n            this.reconstructImage();\n            return this.targetContext;\n        }\n    \n        mergeSimilarTilesColor(threshold) {\n            const groups = this.getTilesGroup(this.tiles, threshold);\n            const colors = groups.map((group) => this.averageColor(group));\n            this.tiles.forEach((tile) => {\n                colors.forEach((color) => {\n                    if(this.colorDifference(tile.meanColor, color) < threshold) {\n                        tile.meanColor = color;\n                    }\n                })\n            });\n        }\n    }\n    \n    class KMeans {\n        constructor(data, k) {\n            this.data = data;\n            this.k = k;\n            this.centroids = [];\n            this.clusters = new Array(this.data.length);\n        }\n    \n        // Step 1: Initialize centroids\n        initializeCentroids() {\n            // Simple random initialization. For KMeans++, the initialization is more complex.\n            for (let i = 0; i < this.k; i++) {\n                const idx = Math.floor(Math.random() * this.data.length);\n                this.centroids.push(this.data[idx]);\n            }\n        }\n    \n        // Step 2: Assign points to the nearest centroid\n        assignClusters() {\n            this.data.forEach((point, idx) => {\n                let minDist = Number.MAX_VALUE;\n                let cluster = -1;\n    \n                this.centroids.forEach((centroid, centroidIdx) => {\n                    const dist = this.euclideanDistance(point, centroid);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        cluster = centroidIdx;\n                    }\n                });\n    \n                this.clusters[idx] = cluster;\n            });\n        }\n    \n        // Step 3: Update centroids\n        updateCentroids() {\n            let newCentroids = new Array(this.k).fill(null).map(() => []);\n    \n            this.data.forEach((point, idx) => {\n                const clusterIdx = this.clusters[idx];\n                newCentroids[clusterIdx].push(point);\n            });\n    \n            this.centroids = newCentroids.map(cluster => {\n                if (cluster.length === 0) return null; // Handle empty cluster\n                return this.meanPoint(cluster);\n            }).filter(centroid => centroid !== null);\n        }\n    \n        // Euclidean distance between two points\n        euclideanDistance(point1, point2) {\n            return Math.sqrt(point1.reduce((sum, val, idx) => sum + Math.pow(val - point2[idx], 2), 0));\n        }\n    \n        // Calculate the mean point of a cluster\n        meanPoint(points) {\n            const numPoints = points.length;\n            const dimensions = points[0].length;\n            let mean = new Array(dimensions).fill(0);\n    \n            points.forEach(point => {\n                point.forEach((val, idx) => {\n                    mean[idx] += val;\n                });\n            });\n    \n            return mean.map(val => val / numPoints);\n        }\n    \n        // Run the KMeans algorithm\n        run(maxIterations = 16) {\n            this.initializeCentroids();\n            let iterations = 0;\n            let hasConverged = false;\n    \n            while (!hasConverged && iterations < maxIterations) {\n                const oldCentroids = [...this.centroids];\n                this.assignClusters();\n                this.updateCentroids();\n                iterations++;\n    \n                hasConverged = this.centroids.every((centroid, idx) => {\n                    return this.euclideanDistance(centroid, oldCentroids[idx]) < 1e-5;\n                });\n            }\n    \n            return { centroids: this.centroids, clusters: this.clusters };\n        }\n    }\n    \n    class Pixel {\n        constructor(r, g, b, a, id) {\n            this.storage_ = new ArrayBuffer(6);\n            this.rgba_ = new Uint8Array(this.storage_, 0, 4);\n            this.rgba_[0] = r; this.rgba_[1] = g; this.rgba_[2] = b; this.rgba_[3] = a;\n            this.id_ = new Uint16Array(this.storage_, 4, 1);\n            this.id_[0] = id;\n        }\n        get r(){return this.rgba_[0];}\n        get g(){return this.rgba_[1];}\n        get b(){return this.rgba_[2];}\n        get a(){return this.rgba_[3];}\n        get rgba(){return this.rgba_;}\n        get uint(){return new Uint32Array(this.storage_, 0, 1)[0]; }\n        get id(){return this.id_[0];}\n        set id(v){this.id_[0] = (v|0) & 0xFFFF;}\n    }\n    \n    \n    class Tile {\n        constructor(position, imageData) {\n            this.position = position;\n            this.imageData = imageData;\n            this.meanColor = new Pixel(0, 0, 0, 0, 0);\n        }\n    \n    \n        extractColorData() {\n            const data = this.imageData.data;\n            let colors = [];\n            for (let i = 0; i < data.length; i += 4) {\n                colors.push(new Pixel(data[i], data[i+1], data[i+2], data[i+3], i));\n            }\n            return colors;\n        }\n        quantizeColors(k) {\n            k = k || Math.ceil(Math.sqrt(this.imageData.data.length))+2;\n            const colors = this.extractColorData();\n            const colorsArray = colors.map(function (c){return c.rgba; });\n            return new KMeans(colorsArray, k).run(Math.ceil(k/1.5));\n        }\n    \n        getQuantizedColors(quantizedResult) {\n    \n            const map = new Array(quantizedResult.centroids.length).fill(0);\n            quantizedResult.clusters.forEach((clusterId, index) => {\n                map[clusterId]++;\n                /*\n                const color = quantizedResult.centroids[clusterId];\n                this.imageData.data[index * 4] = color[0];\n                this.imageData.data[index * 4 + 1] = color[1];\n                this.imageData.data[index * 4 + 2] = color[2];\n                this.imageData.data[index * 4 + 3] = color[3];*/\n            });\n            let dominantClusterPopulation = 0, dominantClusterId = 0;\n            map.forEach((population, clusterId) => {\n                if(dominantClusterPopulation < population){\n                    dominantClusterPopulation = population;\n                    dominantClusterId = clusterId;\n                }\n            });\n    \n            return quantizedResult.centroids[dominantClusterId];\n        }\n    \n        calculateMeanColor() {\n            const color = this.getQuantizedColors(this.quantizeColors());\n            this.meanColor = new Pixel(color[0]|0, color[1]|0, color[2]|0, color[3]|0, 0);\n        }\n    }\n    \n    var scaler = new ImageProcessor();\n    \n    function imgToImgD(img, width, height, resizer) {\n        \n        let ctx;\n        if(resizer === "pixelize" || resizer === "normal") {\n            let canvas = document.createElement("canvas");\n            let canvas2 = document.createElement("canvas");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            canvas2.width = width;\n            canvas2.height = height;\n            let context = canvas.getContext("2d");\n            let context2 = canvas2.getContext("2d");\n                context.imageSmoothingEnabled = Boolean(resizer === "normal");\n                context2.imageSmoothingEnabled = Boolean(resizer === "normal");\n            context.drawImage(img, 0, 0, img.width, img.height);\n            context2.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas2.width, canvas2.height);\n            ctx = context2;\n        }else if(resizer === "doppel") {\n            ctx = scaler.processImage(imgd, width, height);\n        }\n        return ctx;\n    }\n\n    return new Promise(function(resolve, reject) {\n        var img = new Image();\n        var is_png = base64.startsWith("data:image/png;");\n        img.onload = function() {\n    \n           var canvas;\n           try {\n           \n                let width = (img.naturalWidth || img.width) * scale;\n                let height = (img.naturalHeight || img.height) * scale;\n                let imgd = imgToImgD(img, width, height, resizer).getImageData(0, 0, width, height);\n                \n                createImageBitmap(imgd).then(function(bmp){\n                \n                    var canvas;\n                        canvas = new OffscreenCanvas(bmp.width, bmp.height);\n                    var ctx = canvas.getContext("bitmaprenderer");\n                        ctx.imageSmoothingEnabled = false;\n                        ctx.transferFromImageBitmap(bmp);\n                    \n                    canvas.convertToBlob({type: is_png ? "image/png": "image/jpeg"}).then(function(blb) {\n                        \n                        try {\n                            resolve(new FileReaderSync().readAsDataURL(blb));\n                        } catch(e2) {\n                            var reader = new FileReader();\n                            reader.onload = function(){ resolve(reader.result)};\n                            reader.readAsDataURL(blb);\n                        }\n                    });\n                });\n                \n            } catch(e){\n                let width = (img.naturalWidth || img.width) * scale;\n                let height = (img.naturalHeight || img.height) * scale;\n                let canvas = imgToImgD(img, width, height, resizer).canvas;\n                resolve(canvas.toDataURL(is_png ? "image/png": "image/jpeg")); \n            }\n        };\n        img.onerror = function() { reject(); };\n        img.src = base64;\n    });\n}; return t;')();const c=(t,e=(()=>{}),n=null,i=1,r)=>{null!==n?n.exec(window.base64_sanitize_process_function,[t,i,r]).catch((n=>{window.base64_sanitize_process_function(t,i,r).then((t=>{e(t)}))})).timeout(15e3).then((t=>{e(t)})):window.base64_sanitize_process_function(t,i,r).then((t=>{e(t)}))};window.base64_to_bitmap_process_function=new s('var t = async function(base64) {\n\n    "use strict";\n\n    return fetch(base64).then(function(res) {\n\n        return res.blob().then(function(blb){\n\n            return createImageBitmap(blb);\n        });\n    });\n\n}; return t;')();const u=(t,e=(()=>{}),n=null)=>{null!==n?n.exec(window.base64_to_bitmap_process_function,[t]).catch((e=>window.base64_to_bitmap_process_function(t))).timeout(5e3).then((t=>{e(t)})):window.base64_to_bitmap_process_function(t).then((t=>{e(t)}))},d=(t,e=2073600,n=(()=>{}))=>{let i=1;for(;Math.round(t.width*i)*Math.round(t.height*i)>e;)i-=.01;try{createImageBitmap(t,0,0,t.width,t.height,{resizeWidth:Math.round(t.width*i),resizeHeight:Math.round(t.height*i),resizeQuality:"pixelated"}).then((function(t){let e;try{e=new OffscreenCanvas(t.width,t.height)}catch(r){e=document.createElement("canvas"),e.width=t.width,e.height=t.height}let i=e.getContext("2d");i.imageSmoothingEnabled=!1,i.drawImage(t,0,0,t.width,t.height),n(i.getImageData(0,0,t.width,t.height))}))}catch(r){let e;try{e=new OffscreenCanvas(Math.round(t.width*i),Math.round(t.height*i))}catch(a){e=document.createElement("canvas"),e.width=Math.round(t.width*i),e.height=Math.round(t.height*i)}let o=e.getContext("2d");o.imageSmoothingEnabled=!1,o.drawImage(t,0,0,e.width,e.height),n(o.getImageData(0,0,e.width,e.height))}};window.imagedata_to_base64_process_function=new h('var t = function(imagedata, type) {\n\n    "use strict"\n    type = type || "image/png";\n    var quality = type.includes("webp") ? 1: type.includes("png") ? undefined: 0.7;\n    try {\n    \n        return new Promise(function(resolve, _) {\n\n            createImageBitmap(imagedata, {\n                premultiplyAlpha: \'premultiply\',\n                resizeQuality: \'pixelated\'\n            }).then((bmp) => {\n            \n                var canvas;\n                    canvas = new OffscreenCanvas(imagedata.width, imagedata.height);\n                var ctx = canvas.getContext("bitmaprenderer");\n                    ctx.imageSmoothingEnabled = false;\n                    ctx.transferFromImageBitmap(bmp);\n                \n                canvas.convertToBlob({type: type, quality: quality}).then((blb) => {\n                    try {\n                        resolve(new FileReaderSync().readAsDataURL(blb));\n                    } catch(e2) {\n                        var reader = new FileReader();\n                        reader.onload = function(){ resolve(reader.result)};\n                        reader.readAsDataURL(blb);\n                    }\n                });\n            });\n        });\n       \n    }catch (e) {\n    \n        return new Promise(function(resolve, _) {\n            var canvas = document.createElement("canvas");\n            canvas.width = imagedata.width;\n            canvas.height = imagedata.height;\n            var ctx = canvas.getContext("2d");\n            ctx.imageSmoothingEnabled = false;\n            ctx.putImageData(imagedata, 0, 0);\n            \n            var base64 = canvas.toDataURL(type, quality);\n            canvas = null;\n            resolve(base64);\n        });\n    }\n\n}; return t;')(),t.exports={file_to_imagedata_resized:(t,e,i=(()=>{}),r=null,s="pixelize")=>{function h(){l(t,(function(t){c(t,(function(t){u(t,(function(t){d(t,e,(function(t){i(t)}))}),r)}),r)}),r)}var g,f;Date.now();const p=!("image/png"!==t.type);"image/jpg"!==t.type&&t.type,t.type,p?(g=t.arrayBuffer(),f=Promise.resolve(),p&&(f=(0,a.default)((()=>n.e(42).then(n.t.bind(null,692,7))))),Promise.allSettled([g,f]).then((function(t){var n,r;try{n=t[0].value,(r=t[1].value).default().then((function(t){!function(t){let n=1;for(;Math.round(t.width*n)*Math.round(t.height*n)>e;)n-=.01;let r,a=Math.round(t.width*n),h=Math.round(t.height*n);if("pixelize"===s||"normal"===s){let e=document.createElement("canvas"),n=document.createElement("canvas");e.width=t.width,e.height=t.height,n.width=a,n.height=h;let i=e.getContext("2d"),o=n.getContext("2d");i.imageSmoothingEnabled=!("normal"!==s),o.imageSmoothingEnabled=!("normal"!==s),i.putImageData(t,0,0),o.drawImage(e,0,0,e.width,e.height,0,0,n.width,n.height),r=o.getImageData(0,0,a,h)}else"doppel"===s&&(r=o.scaler.processImage(t,a,h).getImageData(0,0,a,h));i(r)}(r.decode(new Uint8Array(n)))}))}catch(a){h()}})).catch(h)):h()},file_to_base64:l,base64_to_bitmap:u,bitmap_to_imagedata:d,imagedata_to_base64:(t,e="image/png",n=(()=>{}),i=null)=>{null!==i?i.exec(window.imagedata_to_base64_process_function,[t,e]).catch((n=>window.imagedata_to_base64_process_function(t,e))).timeout(5e3).then((t=>{n(t)})):window.imagedata_to_base64_process_function(t,e).then((t=>{n(t)}))},base64_sanitize:c,file_to_bitmap:(t,e)=>{createImageBitmap(t).then(e)}}},630:function(t,e,n){"use strict";class i{constructor(t){t=t||{},this.canvas=document.createElement("canvas"),this.targetCanvas=document.createElement("canvas"),this.options={despeckleStrength:t.despeckleStrength||1,quanitzeStrength:t.quanitzeStrength||1,mergeStrength:t.mergeStrength||1,overlapFactor:t.overlapFactor||1}}get sizes(){return{finalWidth:this.finalWidth,finalHeight:this.finalHeight,tileWidth:this.tileWidth,tileHeight:this.tileHeight,overlapFactor:this.options.overlapFactor}}updateTilesManager(){this.tilesManager=new u(this.context,this.targetContext,this.targetImageData,this.sizes)}updateFilters(t){this.filters=new a(this.options,this.tilesManager,t,this.finalWidth,this.finalHeight)}initializeTiles(){this.tilesManager.createTiles(),this.tilesManager.computeTiles()}paintTiles(){this.tilesManager.paintTiles()}filterTiles(){this.filters.applyFilters()}setCanvas(t,e,n){t=t||1,e=e||1,n=n||{width:0,height:0};const i=r.initializeCanvas(n);this.canvas=i.canvas,this.context=i.context;const a=r.initializeCanvas(null,t,e);this.targetCanvas=a.canvas,this.targetContext=a.context,this.targetImageData=r.canvasContextToImageData(this.targetContext),this.finalWidth=t,this.finalHeight=e,this.tileWidth=Math.fround(this.canvas.width/this.targetCanvas.width),this.tileHeight=Math.fround(this.canvas.height/this.targetCanvas.height)}updateThreshold(){const t=this.tilesManager.getTiles();let e=[];for(let r=0;r<this.finalHeight;r++)for(let n=0;n<this.finalWidth;n++){const i=t[n+r*this.finalWidth];this.tilesManager.getNeighbors(n,r).forEach((t=>{e.push(c.colorDifference(i.meanColor,t.meanColor))}))}const n=e.reduce(((t,e)=>t+e),0)/e.length,i=Math.sqrt(e.map((t=>Math.pow(t-n,2))).reduce(((t,e)=>t+e))/e.length);return(n+i)/7}processImage(t,e,n){return this.setCanvas(e,n,t),this.updateTilesManager(),this.initializeTiles(),this.updateFilters(this.updateThreshold()),this.filterTiles(),this.paintTiles(),this.targetContext}}class r{static initializeCanvas(t,e,n){e=(t=t||{width:0,height:0}).width||e||1,n=t.height||n||1;const i=document.createElement("canvas"),r=i.getContext("2d",{willReadFrequently:!0,powerPreference:"high-performance",alpha:!0,desynchronized:!0});return i.width=e,i.height=n,t instanceof ImageData?r.putImageData(t,0,0):t.width&&r.drawImage(t,0,0,e,n),{canvas:i,context:r}}static canvasContextToImageData(t){return t.getImageData(0,0,t.canvas.width,t.canvas.height)}}class a{constructor(t,e,n,i,r){this.despeckleFilter=new s(n*t.despeckleStrength,e,i,r),this.quantizeFilter=new h(n*t.quantizeStrength,e,i,r),this.mergeFilter=new l(n*t.mergeStrength,e,i,r)}applyFilters(){this.despeckleFilter.apply(),this.quantizeFilter.apply(),this.mergeFilter.apply()}}class o{constructor(t,e,n,i){this.strength=t,this.tilesManager=e,this.tiles=e.getTiles(),this.width=n,this.height=i}}class s extends o{constructor(t,e,n,i){super(t,e,n,i)}apply(){for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++)this.adaptiveDespeckleTile(e,t,this.strength)}adaptiveDespeckleTile(t,e,n){const i=this.tiles[t+e*this.width],r=this.tilesManager.getExtendedNeighbors(t,e,3),a=n*(1+this.calculateLocalContrast(i,r)),{primaryColor:o,secondaryColor:s,isEdge:h,isArea:l}=this.detectEdge(r,a);l?this.maybeApplyDespeckling(i,a,o,o):h&&this.maybeApplyDespeckling(i,a,o,s)}calculateLocalContrast(t,e){const n=c.averageColor(e.concat([t]).map((t=>t.meanColor))),i=e.concat([t]).reduce(((t,e)=>t+Math.pow(c.colorDifference(e.meanColor,n),2)),0)/e.length;return Math.sqrt(i)}detectEdge(t,e){const n=u.getTilesGroup(t,e),i=(n.length,t.length),r=(n[0]||[]).length||0,a=(n[1]||[]).length||0;return{primaryColor:c.averageColor(n[0].map((t=>t.meanColor))),secondaryColor:(n[1]||[]).length?c.averageColor(n[1].map((t=>t.meanColor))):null,isEdge:2*i/3<=r+a,isArea:2*i/3<=r}}maybeApplyDespeckling(t,e,n,i){c.colorDifference(t.meanColor,n)>e&&c.colorDifference(t.meanColor,i)>e&&(t.meanColor=n)}}class h extends o{constructor(t,e,n,i){super(t,e,n,i)}apply(){const t=u.getTilesGroup(this.tiles,this.strength).map((t=>c.averageColor(t.map((t=>t.meanColor)))));this.tiles.forEach((e=>{t.forEach((t=>{c.colorDifference(e.meanColor,t)<this.strength&&(e.meanColor=t)}))}))}}class l extends o{constructor(t,e,n,i){super(t,e,n,i)}apply(){for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++){const n=e+t*this.width,i=this.tiles[n],r=this.tilesManager.getNeighbors(e,t),a={};r.forEach(((t,e)=>{c.colorDifference(i.meanColor,t.meanColor)<this.strength&&(a[e]=t)})),Object.keys(a).length>=3&&Object.values(a).forEach((function(t){t.meanColor=i.meanColor}))}}}class c{static colorDifference(t,e){return Math.sqrt(Math.pow(t.r-e.r,2)+Math.pow(t.g-e.g,2)+Math.pow(t.b-e.b,2)+Math.pow(t.a-e.a,2))}static averageColor(t){const e=new Uint32Array(4);t.forEach((t=>{const n=t.rgba;e[0]+=n[0],e[1]+=n[1],e[2]+=n[2],e[3]+=n[3]}));const n=t.length;return new g(e[0]/n|0,e[1]/n|0,e[2]/n|0,e[3]/n|0,0)}}class u{constructor(t,e,n,i){this.contextSource=t,this.contextDestination=e,this.imageData=n,this.overlapFactor=i.overlapFactor,this.finalWidth=i.finalWidth,this.finalHeight=i.finalHeight,this.tileWidth=i.tileWidth,this.tileHeight=i.tileHeight,this.tiles=Array(this.finalWidth*this.finalHeight).fill(null)}static getTilesGroup(t,e){const n=[];return t.forEach((t=>{let i=!1;n.forEach((n=>{c.colorDifference(t.meanColor,n[0].meanColor)<e&&(n.push(t),i=!0)})),i||n.push([t])})),n.sort(((t,e)=>e.length-t.length)),n}getTiles(){return this.tiles}extractTileData(t,e){const n=this.tileWidth*this.overlapFactor,i=this.tileHeight*this.overlapFactor,r=t*this.tileWidth-(n-this.tileWidth)/2,a=e*this.tileHeight-(i-this.tileHeight)/2;return this.contextSource.getImageData(0|r,0|a,0|n,0|i)}createTiles(){for(let t=0;t<this.finalHeight;t++)for(let e=0;e<this.finalWidth;e++){const n=e+t*this.finalWidth,i=this.extractTileData(e,t);this.tiles[n]=new f({x:e,y:t},i)}}computeTiles(){for(let t=0;t<this.finalHeight;t++)for(let e=0;e<this.finalWidth;e++){const n=e+t*this.finalWidth;this.tiles[n].calculateMeanColor()}}getNeighbors(t,e){const n=[];for(let i=-1;i<=1;i++)for(let r=-1;r<=1;r++){const a=t+i,o=e+r;0===i&&0===r||a<0||o<0||a>=this.finalWidth||o>=this.finalHeight||a>=0&&a<this.finalWidth&&o>=0&&o<this.finalHeight&&n.push(this.tiles[a+o*this.finalWidth])}return n}getExtendedNeighbors(t,e,n){const i=[];for(let r=-n;r<=n;r++)for(let a=-n;a<=n;a++){const n=t+r,o=e+a;0===r&&0===a||n<0||o<0||n>=this.finalWidth||o>=this.finalHeight||i.push(this.tiles[n+o*this.finalWidth])}return i}paintTargetImage(t,e,n){const i=4*t;n[i]=e.r,n[i+1]=e.g,n[i+2]=e.b,n[i+3]=e.a}paintTiles(){const t=this.imageData.data;for(let e=0;e<this.finalHeight;e++)for(let n=0;n<this.finalWidth;n++){const i=n+e*this.finalWidth,r=this.tiles[i];this.paintTargetImage(i,r.meanColor,t)}this.contextDestination.putImageData(this.imageData,0,0)}}class d{constructor(t,e){this.data=t,this.k=e,this.centroids=Array(e),this.clusters=Array(this.data.length)}initializeCentroids(){for(let t=0;t<this.k;t++){const e=Math.floor(Math.random()*this.data.length);this.centroids[t]=this.data[e]}}assignClusters(){this.data.forEach(((t,e)=>{let n=Number.MAX_VALUE,i=-1;this.centroids.forEach(((e,r)=>{const a=this.euclideanDistance(t,e);a<n&&(n=a,i=r)})),this.clusters[e]=i}))}updateCentroids(){let t=Array(this.k).fill(null).map((()=>[]));this.data.forEach(((e,n)=>{const i=this.clusters[n];t[i].push(e)})),this.centroids=t.map((t=>0===t.length?null:this.meanPoint(t))).filter((t=>null!==t))}euclideanDistance(t,e){return Math.sqrt(t.reduce(((t,n,i)=>t+Math.pow(n-e[i],2)),0))}meanPoint(t){const e=t.length,n=t[0].length;let i=Array(n).fill(0);return t.forEach((t=>{t.forEach(((t,e)=>{i[e]+=t}))})),i.map((t=>t/e))}run(t=16){this.initializeCentroids();let e=0,n=!1;for(;!n&&e<t;){const t=[...this.centroids];this.assignClusters(),this.updateCentroids(),e++,n=this.centroids.every(((e,n)=>this.euclideanDistance(e,t[n])<1e-5))}return{centroids:this.centroids,clusters:this.clusters}}}class g{constructor(t,e,n,i,r){this.storage_=new ArrayBuffer(6),this.rgba_=new Uint8Array(this.storage_,0,4),this.rgba_[0]=t,this.rgba_[1]=e,this.rgba_[2]=n,this.rgba_[3]=i,this.id_=new Uint16Array(this.storage_,4,1),this.id_[0]=r}get r(){return this.rgba_[0]}get g(){return this.rgba_[1]}get b(){return this.rgba_[2]}get a(){return this.rgba_[3]}get rgba(){return this.rgba_}get uint(){return new Uint32Array(this.storage_,0,1)[0]}get id(){return this.id_[0]}set id(t){this.id_[0]=65535&(0|t)}}class f{constructor(t,e){this.position=t,this.imageData=e,this.meanColor=new g(0,0,0,0,0)}extractColorData(){const t=this.imageData.data;let e=[];for(let n=0;n<t.length;n+=4)e.push(new g(t[n],t[n+1],t[n+2],t[n+3],n));return e}quantizeColors(t){t=t||Math.ceil(Math.sqrt(this.imageData.data.length+100));const e=this.extractColorData().map((function(t){return t.rgba}));return new d(e,t).run()}getQuantizedColor(t){const e=new Uint8Array(t.centroids.length);t.clusters.forEach(((t,n)=>{e[t]++}));let n=0,i=0;return e.forEach(((t,e)=>{n<t&&(n=t,i=e)})),t.centroids[i]}calculateMeanColor(){const t=this.getQuantizedColor(this.quantizeColors());this.meanColor=new g(0|t[0],0|t[1],0|t[2],0|t[3],0)}}var p=new i;t.exports={scaler:p,ImageProcessor:i}},662:function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}var r=i(n(706)),a=i(n(924));t.exports={UJS:(t,e="COMPRESS_OBJECT",n=null)=>new Promise((function(n,i){"COMPRESS_OBJECT"===e?n(new Uint8ClampedArray(r.default.compress(a.default.pack(t)).buffer)):"DECOMPRESS_UINT8A"===e&&n(a.default.unpack(r.default.uncompress(t)))}))}},817:function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}var r=i(n(600)),a=i(n(127)),o=i(n(818));t.exports={base64png_to_xbrz_svg:(t,e,i,s,h=[],l="xbrz",c=!1,u=!1,d=!1)=>{let g=new Image;g.onload=()=>{var t,f,p;let m=document.createElement("canvas"),v=m.getContext("2d");const{width:y,height:w}=g;m.width=y,m.height=w,v.drawImage(g,0,0,y,w);let b=v.getImageData(0,0,y,w);const x=(t,e)=>new Promise((function(e,i){(0,a.default)((()=>n.e(20).then(n.t.bind(null,918,7)))).then((({crt:n})=>{n(t,1).then(e).catch(i)}))})),C=(t,e,i,o,s)=>{c?(0,a.default)((()=>n.e(1).then(n.t.bind(null,625,7)))).then((({oxi_png:h})=>{h(t,3,!1,r.default).then((t=>{s(t,e,i,o)})).catch((()=>{(0,a.default)((()=>n.e(0).then(n.t.bind(null,624,7)))).then((({png_quant:n})=>{n(t,25,50,1,r.default).then((t=>{s(t,e,i,o)})).catch((()=>{s(t,e,i,o)}))})).catch((()=>{s(t,e,i,o)}))}))})).catch((()=>{s(t,e,i,o)})):s(t,e,i,o)},_=(t,e)=>{u?(0,a.default)((()=>n.e(22).then(n.t.bind(null,643,7)))).then((({image_tracer:o})=>{o(t,{pal:h.map((t=>({r:parseInt(t.slice(1,3),16),g:parseInt(t.slice(3,5),16),b:parseInt(t.slice(5,7),16),a:parseInt(t.slice(7,9),16)}))),corsenabled:!1,ltres:e,qtres:e,pathomit:e,rightangleenhance:!1,colorsampling:2,numberofcolors:512,mincolorratio:0,colorquantcycles:1,layering:0,strokewidth:Math.ceil(e/2),linefilter:!0,scale:1,roundcoords:2,viewbox:!0,desc:!1,lcpr:0,qcpr:0,blurradius:e,blurdelta:4*e},r.default).then((t=>{c?(0,a.default)((()=>n.e(5).then(n.bind(null,690)))).then((({optimize:n})=>{t=n(t,{path:"path-to.svg",multipass:!0,mergePaths:!0,mergeStyles:!0,collapseGroups:!0,reusePaths:!0,plugin:["multipass","mergePaths","collapseGroups","reusePaths","mergeStyles"]}).data,i("data:image/svg+xml;base64,"+window.btoa(t),e)})):i("data:image/svg+xml;base64,"+window.btoa(t),e)}))})):i("",0)};if("depixelize"===l){const r=10;f=(t=(0,o.default)(b,u))[0],p=t[1];let h=document.createElement("canvas");h.width=f.width,h.height=f.height;let l=h.getContext("2d");l.putImageData(f,0,0);let g=l.canvas.toDataURL("image/png");d&&x(f).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,r,t.width,t.height,s)})),u&&(c?(0,a.default)((()=>n.e(5).then(n.bind(null,690)))).then((({optimize:t})=>{p=t(p,{path:"path-to.svg",multipass:!0,plugin:["mergePaths"]}).data,i("data:image/svg+xml;base64,"+window.btoa(p),r)})):i("data:image/svg+xml;base64,"+window.btoa(p),r)),C(g,r,f.width,f.height,e)}else"omniscale"===l?(0,a.default)((()=>n.e(23).then(n.t.bind(null,919,7)))).then((({omniscale:t})=>{t(b,8,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,8,t.width,t.height,s)})),_(t,8),C(r,8,t.width,t.height,e)}))})):"hexagon"===l?(0,a.default)((()=>n.e(4).then(n.t.bind(null,691,7)))).then((({hexagonrender:t})=>{t(b,16).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,16,t.width,t.height,s)})),_(t,32/6),C(r,32,t.width,t.height,e)}))})):"kikko"===l?(0,a.default)((()=>n.e(43).then(n.t.bind(null,920,7)))).then((({kikkorender:t})=>{t(b,24,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,24,t.width,t.height,s)})),_(t,6),C(r,48,t.width,t.height,e)}))})):"hqnx"===l?(0,a.default)((()=>n.e(21).then(n.t.bind(null,921,7)))).then((({hqnx:t})=>{t(b,4,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,4,t.width,t.height,s)})),_(t,4),C(r,4,t.width,t.height,e)}))})):"epx"===l?(0,a.default)((()=>n.e(19).then(n.t.bind(null,922,7)))).then((({epx:t})=>{t(b,4,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,4,t.width,t.height,s)})),_(t,4),C(r,4,t.width,t.height,e)}))})):(0,a.default)((()=>n.e(24).then(n.t.bind(null,608,7)))).then((t=>{t.default(b,6,r.default).then((t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.putImageData(t,0,0);let r=i.canvas.toDataURL("image/png");d&&x(t).then((function(t){let e=document.createElement("canvas");e.width=t.width,e.height=t.height,e.getContext("2d").putImageData(t,0,0);let n=e.toDataURL("image/png");C(n,6,t.width,t.height,s)})),_(t,6),C(r,6,t.width,t.height,e)}))}))},g.src=t}}},818:function(t,e,n){"use strict";function i(t){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i(t)}function r(){function t(t,e,n){return Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}),t[e]}function e(t,e,n,i){var r=e&&e.prototype instanceof a?e:a,o=Object.create(r.prototype),s=new f(i||[]);return b(o,"_invoke",{value:c(t,n,s)}),o}function n(t,e,n){try{return{type:"normal",arg:t.call(e,n)}}catch(i){return{type:"throw",arg:i}}}function a(){}function o(){}function s(){}function h(e){["next","throw","return"].forEach((function(n){t(e,n,(function(t){return this._invoke(n,t)}))}))}function l(t,e){function r(a,o,s,h){var l,c,u=n(t[a],t,o);if("throw"!==u.type)return(c=(l=u.arg).value)&&"object"==i(c)&&w.call(c,"__await")?e.resolve(c.__await).then((function(t){r("next",t,s,h)}),(function(t){r("throw",t,s,h)})):e.resolve(c).then((function(t){l.value=t,s(l)}),(function(t){return r("throw",t,s,h)}));h(u.arg)}var a;b(this,"_invoke",{value:function(t,n){function i(){return new e((function(e,i){r(t,n,e,i)}))}return a=a?a.then(i,i):i()}})}function c(t,e,i){var r="suspendedStart";return function(a,o){var s,h,l;if("executing"===r)throw Error("Generator is already running");if("completed"===r){if("throw"===a)throw o;return{value:void 0,done:!0}}for(i.method=a,i.arg=o;;){if((s=i.delegate)&&(h=u(s,i))){if(h===E)continue;return h}if("next"===i.method)i.sent=i._sent=i.arg;else if("throw"===i.method){if("suspendedStart"===r)throw r="completed",i.arg;i.dispatchException(i.arg)}else"return"===i.method&&i.abrupt("return",i.arg);if(r="executing","normal"===(l=n(t,e,i)).type){if(r=i.done?"completed":"suspendedYield",l.arg===E)continue;return{value:l.arg,done:i.done}}"throw"===l.type&&(r="completed",i.method="throw",i.arg=l.arg)}}}function u(t,e){var i,r,a=e.method,o=t.iterator[a];return void 0===o?(e.delegate=null,"throw"===a&&t.iterator.return&&(e.method="return",e.arg=void 0,u(t,e),"throw"===e.method)||"return"!==a&&(e.method="throw",e.arg=new TypeError("The iterator does not provide a '"+a+"' method")),E):"throw"===(i=n(o,t.iterator,e.arg)).type?(e.method="throw",e.arg=i.arg,e.delegate=null,E):(r=i.arg)?r.done?(e[t.resultName]=r.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,E):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,E)}function d(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function g(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function f(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(d,this),this.reset(!0)}function p(t){var e,n,i;if(t){if(e=t[C])return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length))return n=-1,(i=function e(){for(;++n<t.length;)if(w.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=void 0,e.done=!0,e}).next=i}return{next:m}}function m(){return{value:void 0,done:!0}}var v,y,w,b,x,C,_,D,E,k,T,I,M;r=function(){return v},v={},w=(y=Object.prototype).hasOwnProperty,b=Object.defineProperty||function(t,e,n){t[e]=n.value},x="function"==typeof Symbol?Symbol:{},C=x.iterator||"@@iterator",_=x.asyncIterator||"@@asyncIterator",D=x.toStringTag||"@@toStringTag";try{t({},"")}catch(S){t=function(t,e,n){return t[e]=n}}return v.wrap=e,E={},t(k={},C,(function(){return this})),(I=(T=Object.getPrototypeOf)&&T(T(p([]))))&&I!==y&&w.call(I,C)&&(k=I),M=s.prototype=a.prototype=Object.create(k),o.prototype=s,b(M,"constructor",{value:s,configurable:!0}),b(s,"constructor",{value:o,configurable:!0}),o.displayName=t(s,D,"GeneratorFunction"),v.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===o||"GeneratorFunction"===(e.displayName||e.name))},v.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,t(e,D,"GeneratorFunction")),e.prototype=Object.create(M),e},v.awrap=function(t){return{__await:t}},h(l.prototype),t(l.prototype,_,(function(){return this})),v.AsyncIterator=l,v.async=function(t,n,i,r,a){void 0===a&&(a=Promise);var o=new l(e(t,n,i,r),a);return v.isGeneratorFunction(n)?o:o.next().then((function(t){return t.done?t.value:o.next()}))},h(M),t(M,D,"Generator"),t(M,C,(function(){return this})),t(M,"toString",(function(){return"[object Generator]"})),v.keys=function(t){var e,n=Object(t),i=[];for(e in n)i.push(e);return i.reverse(),function t(){for(;i.length;){var e=i.pop();if(e in n)return t.value=e,t.done=!1,t}return t.done=!0,t}},v.values=p,f.prototype={constructor:f,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(g),!t)for(var e in this)"t"===e.charAt(0)&&w.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){function e(e,i){return a.type="throw",a.arg=t,n.next=e,i&&(n.method="next",n.arg=void 0),!!i}var n,i,r,a,o,s;if(this.done)throw t;for(n=this,i=this.tryEntries.length-1;i>=0;--i){if(r=this.tryEntries[i],a=r.completion,"root"===r.tryLoc)return e("end");if(r.tryLoc<=this.prev)if(o=w.call(r,"catchLoc"),s=w.call(r,"finallyLoc"),o&&s){if(this.prev<r.catchLoc)return e(r.catchLoc,!0);if(this.prev<r.finallyLoc)return e(r.finallyLoc)}else if(o){if(this.prev<r.catchLoc)return e(r.catchLoc,!0)}else{if(!s)throw Error("try statement without catch or finally");if(this.prev<r.finallyLoc)return e(r.finallyLoc)}}},abrupt:function(t,e){var n,i,r,a;for(n=this.tryEntries.length-1;n>=0;--n)if((i=this.tryEntries[n]).tryLoc<=this.prev&&w.call(i,"finallyLoc")&&this.prev<i.finallyLoc){r=i;break}return r&&("break"===t||"continue"===t)&&r.tryLoc<=e&&e<=r.finallyLoc&&(r=null),(a=r?r.completion:{}).type=t,a.arg=e,r?(this.method="next",this.next=r.finallyLoc,E):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),E},finish:function(t){var e,n;for(e=this.tryEntries.length-1;e>=0;--e)if((n=this.tryEntries[e]).finallyLoc===t)return this.complete(n.completion,n.afterLoc),g(n),E},catch:function(t){var e,n,i,r;for(e=this.tryEntries.length-1;e>=0;--e)if((n=this.tryEntries[e]).tryLoc===t)return"throw"===(i=n.completion).type&&(r=i.arg,g(n)),r;throw Error("illegal catch attempt")},delegateYield:function(t,e,n){return this.delegate={iterator:p(t),resultName:e,nextLoc:n},"next"===this.method&&(this.arg=void 0),E}},v}function a(t,e){var n,i,r,a,o,s="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!s){if(Array.isArray(t)||(s=g(t))||e&&t&&"number"==typeof t.length)return s&&(t=s),n=0,{s:i=function(){},n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return r=!0,a=!1,{s:function(){s=s.call(t)},n:function(){var t=s.next();return r=t.done,t},e:function(t){a=!0,o=t},f:function(){try{r||null==s.return||s.return()}finally{if(a)throw o}}}}function o(t,e){if(e&&("object"===i(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}function s(t){var e="function"==typeof Map?new Map:void 0;return s=function(t){function n(){return h(t,arguments,u(this).constructor)}if(null===t||(i=t,-1===Function.toString.call(i).indexOf("[native code]")))return t;var i;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),c(n,t)},s(t)}function h(t,e,n){return h=l()?Reflect.construct.bind():function(t,e,n){var i,r=[null];return r.push.apply(r,e),i=new(Function.bind.apply(t,r)),n&&c(i,n.prototype),i},h.apply(null,arguments)}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function c(t,e){return c=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},c(t,e)}function u(t){return u=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},u(t)}function d(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n,i,r,a,o,s,h,l=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=l){o=[],s=!0,h=!1;try{if(r=(l=l.call(t)).next,0===e){if(Object(l)!==l)return;s=!1}else for(;!(s=(n=r.call(l)).done)&&(o.push(n.value),o.length!==e);s=!0);}catch(c){h=!0,i=c}finally{try{if(!s&&null!=l.return&&(a=l.return(),Object(a)!==a))return}finally{if(h)throw i}}return o}}(t,e)||g(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function g(t,e){if(t){if("string"==typeof t)return f(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?f(t,e):void 0}}function f(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=Array(e);n<e;n++)i[n]=t[n];return i}function p(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function m(t,e){var n,r,a;for(n=0;n<e.length;n++)(r=e[n]).enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,(a=function(t,e){var n,r;if("object"!==i(t)||null===t)return t;if(void 0!==(n=t[Symbol.toPrimitive])){if("object"!==i(r=n.call(t,"string")))return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return t+""}(r.key),"symbol"===i(a)?a:a+""),r)}function v(t,e,n){return e&&m(t.prototype,e),n&&m(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}Object.defineProperty(e,"__esModule",{value:!0});var y=function(){function t(t,e,n){return[h(t,e,n),g(t,e,n),h(t,e+1,n),g(t,e,n+1)]}function e(t,e,n,i,r){var a,o=Array(r);for(a=0;a<r;++a)o[a]=t[a+n].slice(e,e+i);return o}function n(){this.vertices=[]}var i,h,g,f,m,y,w,b,x,C=function(){function t(e){var n,i=d(e,3),r=i[0],a=i[1],o=i[2];p(this,t),n=.299*r+.587*a+.114*o,this.y=Math.round(n),this.u=Math.round(.492*(o-n)),this.v=Math.round(.877*(r-n)),this.r=r,this.g=a,this.b=o,this.rgb=[r,a,o]}return v(t,[{key:"dissimilar",value:function(t){return Math.abs(this.r-t.r)+Math.abs(this.g-t.g)+Math.abs(this.b-t.b)>=1}},{key:"toString",value:function(){return"rgb("+this.rgb.join()+")"}}]),t}(),_=function(){function t(e,n){p(this,t),this.x=e,this.y=n,this.edges=[]}return v(t,[{key:"split",value:function(e){return new t((this.x+e.x)/2,(this.y+e.y)/2)}},{key:"adjust",value:function(t,e){return this.x+=t,this.y+=e,this}},{key:"clone",value:function(){return new t(this.x,this.y)}},{key:"equals",value:function(t){return this.x===t.x&&this.y===t.y}},{key:"addEdge",value:function(t){-1==this.edges.indexOf(t)&&(this.edges.push(t),t.addEdge(this))}}]),t}(),D=function(t){function e(t){var n;return p(this,e),(n=r.call(this,1))[0]=t,n.circular=!1,n}!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&c(t,e)}(e,t);var n,i,r=(n=e,i=l(),function(){var t,e,r=u(n);return i?(e=u(this).constructor,t=Reflect.construct(r,arguments,e)):t=r.apply(this,arguments),o(this,t)});return v(e,[{key:"splitAt",value:function(t){var n,i,r,o,s;if(1!==this.length){if(this[0]===t)this.shift();else if(this[this.length-1]===t)this.pop();else if(this.circular)for(n=this.shift();n!==t;n=this.shift())this.push(n);else{i=this.indexOf(t),o=a(r=this.slice(i+1));try{for(o.s();!(s=o.n()).done;)s.value.curve=r}catch(h){o.e(h)}finally{o.f()}this.length=i}t.curve=new e(t)}}},{key:"merge",value:function(t){var e,n,i,r,a,o;if(this!==t)for(n=(e=d([this,t].sort((function(t,e){return t.length-e.length})),2))[0],-1!==(i=e[1])[0].edges.indexOf(n[0])?(r=this.shift,a=this.unshift):-1!==i[0].edges.indexOf(n[n.length-1])?(r=this.pop,a=this.unshift):-1!==i[i.length-1].edges.indexOf(n[0])?(r=this.shift,a=this.push):-1!==i[i.length-1].edges.indexOf(n[n.length-1])&&(r=this.pop,a=this.push);n.length;)o=r.call(n),a.call(i,o),o.curve=i;else this.circular=t.length>2}}],[{key:"curve",value:function(t,e){return t.curve===e.curve?t.curve.length:0}}]),e}(s(Array)),E=function(){function t(e,n,i,r){p(this,t),this.x=e,this.y=n,this.edges=[,,,,,,,,],this.vertices=r||[],this.color=i,this.marked=!1,this.curve=new D(this)}return v(t,[{key:"relativePosition",value:function(t){var e=t.x,n=t.y-this.y;return(e-this.x+3*n+8)%9}},{key:"invalidCurve",value:function(){return this.valence()>2&&this.curve.length>1}},{key:"updateCurves",value:function(){this.valence()>2&&this.curve.splitAt(this)}},{key:"equals",value:function(t){return this.x===t.x&&this.y===t.y}},{key:"removeEdge",value:function(e){t.removeEdge(this,e)}},{key:"canReach",value:function(t){return t&&!!this.edges[this.relativePosition(t)]}},{key:"valence",value:function(){return this.edges.filter((function(t){return t})).length}},{key:"toString",value:function(){return"("+[this.x,this.y].join()+") => "+this.edges.filter((function(t){return t})).map((function(t){return"("+[t.x,t.y].join()+")"})).join()}},{key:"edge",value:function(t,e){return this.edges[(t+3*e+8)%9]}},{key:"right",value:function(){return this.edges[0]}},{key:"left",value:function(){return this.edges[7]}},{key:"up",value:function(){return this.edges[5]}},{key:"down",value:function(){return this.edges[2]}},{key:"isEdge",value:function(){return this.edges.filter((function(t){return t})).length<4}},{key:"follow",value:r().mark((function t(e){var n,i,a;return r().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=this;case 1:if(!(n.canReach(e)&&n.valence()<3)){t.next=14;break}return t.next=4,e;case 4:if(!(e.valence()>2)){t.next=6;break}return t.abrupt("break",14);case 6:if(i=e.edges.filter((function(t){return t})),a=i[0]!=n?i[0]:i[1],n=e,(e=a)!=this){t.next=12;break}return t.abrupt("break",14);case 12:t.next=1;break;case 14:case"end":return t.stop()}}),t,this)}))},{key:"square",value:function(){var t=d(this.edges,3),e=t[0],n=t[2],i=e&&n&&e.down()&&n.right();return[this,e,n,i].filter((function(t){return t}))}}],[{key:"addSimilarEdge",value:function(t,e){t.color&&e.color&&!t.color.dissimilar(e.color)&&(t.edges[t.relativePosition(e)]=e,e.edges[e.relativePosition(t)]=t,t.valence()>2&&t.curve.splitAt(t),e.valence()>2&&e.curve.splitAt(e),t.valence()<3&&e.valence()<3&&t.curve.merge(e.curve))}},{key:"removeEdge",value:function(t,e){t.edges[t.relativePosition(e)]=void 0,e.edges[e.relativePosition(t)]=void 0}}]),t}(),k=function(){function t(e,n,i){if(p(this,t),e.length!=n*i*4)throw Error("Wrong dimension of pixel buffer");this.width=n,this.height=i,this.pixels=e}return v(t,[{key:"create",value:r().mark((function t(){var e,n,i,a,o,s,h,l,c,u,d,g,f,p,m;return r().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:for(e=this.width,n=this.height,i=Array(n),(a=Array(n+1))[0]=Array(e+1),o=0;o<e+1;++o)a[0][o]=new _(o,0);s=new E,h=Array(e).fill(s),o=0;case 9:if(!(o<n)){t.next=31;break}l=[s,s],c=i[o]=Array(e),u=a[o],(d=a[o+1]=Array(e+1))[0]=new _(0,o+1),g=0;case 16:if(!(g<e)){t.next=27;break}return d[g+1]=new _(g+1,o+1),f=[u[g],u[g+1],d[g+1],d[g]],p=c[g]=new E(g,o,this.pixel(g,o),f),m=[h[g],p],t.next=23,[l,m];case 23:l=m;case 24:++g,t.next=16;break;case 27:h=c;case 28:++o,t.next=9;break;case 31:this.nodes_old=i,this.vertices=i;case 33:case"end":return t.stop()}}),t,this)}))},{key:"createSimilarityGraph",value:function(){var t,e,n,i,r,o,s,h,l=a(this.create());try{for(l.s();!(t=l.n()).done;)e=d(t.value,2),i=(n=d(e[0],2))[0],r=n[1],s=(o=d(e[1],2))[0],h=o[1],E.addSimilarEdge(s,h),E.addSimilarEdge(r,h),4!==i.square().length&&(E.addSimilarEdge(s,r),E.addSimilarEdge(i,h))}catch(c){l.e(c)}finally{l.f()}return this}},{key:"graph",value:function(){this.height,this.width}},{key:"nodes",value:r().mark((function(){var t,e,n,i,a;return r().wrap((function(r){for(;;)switch(r.prev=r.next){case 0:n=this.width,i=this.height,a=this.nodes_old,e=0;case 2:if(!(e<i)){r.next=13;break}t=0;case 4:if(!(t<n)){r.next=10;break}return r.next=7,a[e][t];case 7:++t,r.next=4;break;case 10:++e,r.next=2;break;case 13:case"end":return r.stop()}}),a,this)}))},{key:"diagonals",value:r().mark((function t(){var e,n,i,a,o,s,h,l,c,u,d;return r().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:o=this.width,s=this.height,h=this.nodes_old,n=1;case 2:if(!(n<s)){t.next=22;break}i=h[n-1],a=h[n],e=1;case 6:if(!(e<o)){t.next=19;break}if(l=i[e-1],c=i[e],u=a[e-1],d=a[e],!(l.canReach(c)||l.canReach(u)||d.canReach(c)||d.canReach(u))){t.next=13;break}return t.abrupt("continue",16);case 13:if(!l.canReach(d)||!c.canReach(u)){t.next=16;break}return t.next=16,[[l,d],[u,c]];case 16:++e,t.next=6;break;case 19:++n,t.next=2;break;case 22:case"end":return t.stop()}}),t,this)}))},{key:"pixel",value:function(t,e){var n=e*this.width*4+4*t;return new C(this.pixels.subarray(n,n+3))}}]),t}();return k.diagonals=function(t){return t[0][0].canReach(t[0][1])+t[1][0].canReach(t[1][1])},h=(i=function(t,e){var n=t,i=e;return function(t,e,r){return[t[r][e],t[r+i][e+n]]}})(0,1),g=i(1,0),f=i(1,1),m=i(1,-1),k.prototype.getDiagonals=function(t,e){return[f(this.nodes_old,t,e),m(this.nodes_old,t,e+1)]},y=function(t){return t[0].canReach(t[1])},w=function(t){return!t},b=function(t,e,n,i){return function(r){var a,o;for(r=r[0].edges.filter((function(t){return t})),a=[];r.length>0;)o=r.pop(),-1==a.indexOf(o)&&o.x>t&&o.x<e&&o.y>n&&o.y<i&&(a.push(o),r=r.concat(o.edges.filter((function(t){return t}))));return a}},k.prototype.linearize=function(){var e,n,i,r,a,o,s,h,l;for(e=1;e<this.width;++e)for(n=1;n<this.height;++n)t(this.nodes_old,e-1,n-1).map(y).every(w)&&(r=[0,0],a=(i=this.getDiagonals(e-1,n-1)).map(b(e-3,e+2,n-3,n+2)),(s=(o=i.map((function(t){return D.curve(t[0],t[1])})))[0]-o[1])>0?r[0]+=s:r[1]-=s,(h=a[0].length-a[1].length)>0?r[1]+=h:r[0]-=h,(l=i.map((function(t){return 1==t[0].valence()||1==t[1].valence()})))[0]&&!l[1]?r[0]+=5:!l[0]&&l[1]&&(r[1]+=5),r[0]>r[1]?E.removeEdge(i[1][0],i[1][1]):r[0]<r[1]?E.removeEdge(i[0][0],i[0][1]):(E.removeEdge(i[0][0],i[0][1]),E.removeEdge(i[1][0],i[1][1])));return this},x=function(t){var e,n,i,r=t[0][1];r.edge(-1,1)&&(i=(n=(e=r.vertices)[3]).clone(),r.down()||n.adjust(.25,.25),r.left()||i.adjust(-.25,-.25),t[0][0].vertices[2]=i,e.splice(4,0,i),i=(e=t[1][0].vertices).splice(0,1,i).pop(),e.push(i)),r.edge(1,1)&&(i=(n=(e=r.vertices)[2]).clone(),r.down()||n.adjust(-.25,.25),r.right()||i.adjust(.25,-.25),t[0][2].vertices[3]=i,e.splice(2,0,i),i=(e=t[1][2].vertices).splice(0,1,i).pop(),e.push(i))},k.prototype.createVoronoiDiagram=function(){var t,n,i,r=this.width-2,a=this.height-1,o=this.nodes_old;for(t=0;t<a;++t){for((n=e(o,0,t,2,2))[0].unshift(new E),n[1].unshift(new E),x(n),i=0;i<r;++i)x(e(o,i,t,3,2));(n=e(o,i,t,2,2))[0].push(new E),n[1].push(new E),x(n)}return this},k.prototype.contour=function(t){var e,n,i,r,a,o,s,h,l,c,u=t,d=[];if(0===u.valence())return u.vertices.slice();if(u.marked||!u.isEdge()||[[-1,-1],[0,-1],[1,-1]].some((function(t){return null!=this.edge.apply(this,t)}),u))return d;for(n=[],i=1,r=0,u.vertices[0],o=null;;){switch(u.marked=!0,n.push(u),e=void 0,i){case 1:if(e=u.edge(1,-1)){i=7;break}case 2:if(e=u.edge(1,0)){i=0;break}case 3:if(e=u.edge(1,1)){i=1;break}case 4:if(e=u.edge(0,1)){i=2;break}case 5:if(e=u.edge(-1,1)){i=3;break}case 6:if(e=u.edge(-1,0)){i=4;break}case 7:if(e=u.edge(-1,-1)){i=5;break}case 0:i=(e=u.edge(0,-1))?6:1}if(e){for(s=r,h=u.vertices.length,o&&e.equals(o)&&(a=u.vertices[s++%h],d.push(a));;){if(a=u.vertices[s++%h],-1!=(l=e.vertices.indexOf(a))){r=l;break}d.push(a)}if(t.equals(e)&&t.edges.filter((function(t){return t})).every((function(t){return t.marked||!t.isEdge()}))){for(s=r,h=e.vertices.length;s<h;)a=e.vertices[s++],d.push(a);break}o=u,u=e}}for(;0!=n.length;)(c=n.pop().edges.filter((function(t){return t&&!t.marked}))).forEach((function(t){t.marked=!0})),n.push.apply(n,c);return d},n.prototype=Object.create(null,{push:{enumerable:!1,value:function(t){this.vertices.push(t),t.addPath(this)}},splitAt:{enumerable:!1,value:function(t){var e=new n;e.vertices=this.vertices.slice(t),this.vertices.length=t+1,e.vertices.forEach((function(t){t.removePath(this),t.addPath(e)}))}}}),k.prototype.paths=function(t){new n},function(t,e,n){return new k(t,e,n)}}();e.default=function(t,e,n){var i,r=y(t.data,t.width,t.height);return r.createSimilarityGraph(),r.createVoronoiDiagram(),r.linearize(),i=function(t,e,n,i){var r,a,o,s,h=t.width,l=t.height,c=(t.nodes,document.createElement("canvas"));c.width=h*e,c.height=l*e,(r=c.getContext("2d")).strokeStyle="black";for(let u of t.nodes()){for(r.strokeStyle=u.color,r.lineWidth=e,a=u.vertices,r.beginPath(),o=a[0],r.moveTo(o.x*e,o.y*e),s=1;s<a.length;++s)o=a[s],r.lineTo(o.x*e,o.y*e);r.closePath(),r.stroke()}for(let u of t.nodes()){for(r.fillStyle=u.color,a=u.vertices,r.beginPath(),o=a[0],r.moveTo(o.x*e,o.y*e),s=1;s<a.length;++s)o=a[s],r.lineTo(o.x*e,o.y*e);r.closePath(),r.fill()}return r}(r,e).canvas.toDataURL("image/jpeg",n),function(t,e){t.width,t.height;var n,i,r,a,o=t.nodes(),s=[],h=[];for(let l of o){for(n="L",r=(i=l.vertices)[0],a=0;a<i.length;++a)r=i[a],n+=`${Math.ceil(r.x*e)},${Math.ceil(r.y*e)} `;s.push(`<path stroke-width="10" stroke="${l.color}" d="M${Math.ceil(i[0].x*e)},${Math.ceil(i[0].y*e)} ${n}Z"/>`),h.push(`<path fill="${l.color}" d="M${Math.ceil(i[0].x*e)},${Math.ceil(i[0].y*e)} ${n}Z"/>`)}s.join("\n\t"),h.join("\n\t")}(r,e),i}},819:function(t,e,n){"use strict";var i=n(820);t.exports={loadJSON:function(t,e){let n=new XMLHttpRequest;try{n=new XMLHttpRequest}catch(i){try{n=new ActiveXObject("Msxml2.XMLHTTP")}catch(i){try{n=new ActiveXObject("Microsoft.XMLHTTP")}catch(i){e("Cannot load data",null)}}}n.open("GET",t,!0),n.onreadystatechange=function(){if(4==n.readyState&&200==n.status)try{let t=JSON.parse(n.responseText);e(null,t)}catch(i){e("Cannot understand response from network.",null)}else 4==n.readyState&&404==n.status&&e("Error 404",null)};try{n.send()}catch(i){e("Failed to fetch",null)}},postJSON:function(t,e,n,r="application/x-www-form-urlencoded"){let a=new Headers;a.append("Content-Type",r);let o="multipart/form-data"===r?new FormData:new URLSearchParams;Object.entries(e).forEach((t=>{const[e,n]=t;o.append(e,n)}));let s={method:"POST",redirect:"follow",headers:a,body:"application/text"===r?e:"application/json"===r?(0,i.clean_json_text)(JSON.stringify(e)):o};fetch(t,s).then((t=>t.text())).then((t=>n(null,t))).catch((t=>n(t,null)))},postDATA:function(t,e,n){let i=new XMLHttpRequest;try{i=new XMLHttpRequest}catch(r){try{i=new ActiveXObject("Msxml2.XMLHTTP")}catch(r){try{i=new ActiveXObject("Microsoft.XMLHTTP")}catch(r){return void n("Cannot load data",null)}}}i.open("POST",t,!0),i.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),i.onreadystatechange=function(){if(4==i.readyState&&200==i.status)try{let t=JSON.parse(i.responseText);n(null,t)}catch(r){n("Cannot understand response from network.",null)}else 4==i.readyState&&404==i.status&&n("Error 404",null)};try{i.send(e)}catch(r){n("Failed to post",null)}}}},820:function(t,e,n){"use strict";t.exports={clean_json_text:function(t){return(t=t.replace(/\\n/g,"\\n").replace(/\\'/g,"\\'").replace(/\\"/g,'\\"').replace(/\\&/g,"\\&").replace(/\\r/g,"\\r").replace(/\\t/g,"\\t").replace(/\\b/g,"\\b").replace(/\\f/g,"\\f")).replace(/[\u0000-\u0019]+/g,"")}}}}]);