/*! For license information please see chunk_40.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{1177:function(e,t,n){"use strict";var a,r,s,o;n.d(t,"a",(function(){return c})),a=n(620),r=n(617),s=n(619),o=n(618);const c=Object(o.b)({gatherND_:function(e,t){const n=Object(s.a)(t,"indices","gatherND","int32"),o={params:Object(s.a)(e,"x","gatherND","string_or_numeric"),indices:n};return a.a.runKernel(r.qb,o)}})},1280:function(e,t,n){"use strict";var a,r,s,o,c,i,u,l,d,b,h,p,f,O,j,g,m,v,k;n.r(t),a=n(620),r=n(677),s=n(617),o=n(643),c=n(619),i=n(661),u=n(641),l=n(637),d=n(742),b=n(979),h=n(948),p=n(658),f=n(747),O=n(618),j=n(623);const x=Object(O.b)({fusedConv2d_:function({x:e,filter:t,strides:n,pad:O,dataFormat:g="NHWC",dilations:m=[1,1],dimRoundingMode:v,bias:k,activation:x="linear",preluActivationWeights:w,leakyreluAlpha:$}){if(x=x||"linear",!1===Object(f.d)(a.a.state.gradientDepth,x)){i.c("NHWC"===g,(()=>`Error in fused conv2d: got dataFormat of ${g} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let a=Object(d.a)(e,t,n,O,g,m,v);return null!=k&&(a=Object(u.a)(a,k)),Object(f.a)(a,x,w,$)}const y=Object(c.a)(e,"x","conv2d","float32"),E=Object(c.a)(t,"filter","conv2d","float32");let A=y,M=!1;3===y.rank&&(M=!0,A=Object(j.a)(y,[1,y.shape[0],y.shape[1],y.shape[2]])),i.c(4===A.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+A.rank+".")),i.c(4===E.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+E.rank+".")),p.a("fused conv2d",O,v);const S="NHWC"===g?A.shape[3]:A.shape[1];i.c(E.shape[2]===S,(()=>`Error in conv2d: depth of input (${S}) must match input depth for filter ${E.shape[2]}.`)),i.c(p.i(n,m),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${m}'`));const T=p.b(A.shape,E.shape,n,m,O,v);let C,_;if(null!=k&&(C=Object(c.a)(k,"bias","fused conv2d"),[C]=Object(o.makeTypesMatch)(C,y),"NHWC"===g?l.assertAndGetBroadcastShape(T.outShape,C.shape):(i.c(C.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${C.shape.length}.`)),i.c(0===C.shape.length||C.shape[0]===T.outChannels||1===C.shape[0],(()=>`Error in fused conv2d: bias shape (${C.shape}) is not compatible with the number of output channels (${T.outChannels})`)))),null!=w){const e=w.shape;if(i.c(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)i.c(1===e[0]||e[0]===T.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${T.outChannels}).`));else if(3===e.length)try{l.assertAndGetBroadcastShape(e,T.outShape)}catch(K){const t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${T.outShape}).`;throw Error(t)}_=Object(c.a)(w,"prelu weights","fused conv2d")}const R=(e,t)=>{i.c("NHWC"===g,(()=>`Error in gradient of fused conv2D: got dataFormat of ${g} but only NHWC is currently supported.`));const[a,r,s,o]=t,c=Object(f.c)(e,s,x);i.c(p.k(m),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${m}'`));const u=[Object(h.a)(r.shape,c,a,n,O),Object(b.a)(r,c,a.shape,n,O)];if(null!=o){const e=Object(f.b)(o,c);u.push(e)}return u},z={x:A,filter:E,bias:C,preluActivationWeights:_},D={strides:n,pad:O,dataFormat:g,dilations:m,dimRoundingMode:v,activation:x,leakyreluAlpha:$};if(null==k){const e=Object(r.a)(((e,t,n)=>{let r=a.a.runKernel(s.ob,z,D);return n([t,e,r]),M&&(r=Object(j.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:R}}));return e(A,E)}{const e=Object(r.a)(((e,t,n,r)=>{let o=a.a.runKernel(s.ob,z,D);return r([t,e,o,n]),M&&(o=Object(j.a)(o,[o.shape[1],o.shape[2],o.shape[3]])),{value:o,gradFunc:R}}));return e(A,E,C)}}});g=n(801),m=n(1184),v=n(1183);const w=Object(O.b)({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:d,dataFormat:b="NHWC",dilations:h=[1,1],dimRoundingMode:O,bias:k,activation:x="linear",preluActivationWeights:w,leakyreluAlpha:$}){if(!1===Object(f.d)(a.a.state.gradientDepth,x)){let a=Object(g.a)(e,t,n,d,b,h,O);return null!=k&&(a=Object(u.a)(a,k)),Object(f.a)(a,x,w,$)}const y=Object(c.a)(e,"x","depthwiseConv2d","float32"),E=Object(c.a)(t,"filter","depthwiseConv2d","float32");let A=y,M=!1;3===y.rank&&(M=!0,A=Object(j.a)(y,[1,y.shape[0],y.shape[1],y.shape[2]])),i.c(4===A.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${A.rank}.`)),i.c(4===E.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${E.rank}.`)),i.c(A.shape[3]===E.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${A.shape[3]}) must match the inChannels dimension in filter ${E.shape[2]}.`)),null==h&&(h=[1,1]),i.c(p.i(n,h),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`)),p.a("fused depthwiseConv2d",d,O);const S=p.b(A.shape,E.shape,n,h,d,O,!0);let T,C;null!=k&&(T=Object(c.a)(k,"bias","fused conv2d"),[T]=Object(o.makeTypesMatch)(T,y),l.assertAndGetBroadcastShape(S.outShape,T.shape)),null!=w&&(C=Object(c.a)(w,"prelu weights","fused depthwiseConv2d"));const _=(e,t)=>{i.c(p.k(h),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${h}'`));const[a,r,s,o]=t,c=Object(f.c)(e,s,x),u=Object(v.a)(r.shape,c,a,n,d,h,O),l=Object(m.a)(r,c,a.shape,n,d,h,O);return null!=o?[u,l,Object(f.b)(T,c)]:[u,l]},R={x:A,filter:E,bias:T,preluActivationWeights:C},z={strides:n,pad:d,dataFormat:b,dilations:h,dimRoundingMode:O,activation:x,leakyreluAlpha:$};if(null==k){const e=Object(r.a)(((e,t,n)=>{let r=a.a.runKernel(s.pb,R,z);return n([t,e,r]),M&&(r=Object(j.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:_}}));return e(A,E)}{const e=Object(r.a)(((e,t,n,r)=>{let o=a.a.runKernel(s.pb,R,z);return r([t,e,o,n]),M&&(o=Object(j.a)(o,[o.shape[1],o.shape[2],o.shape[3]])),{value:o,gradFunc:_}}));return e(A,E,T)}}});k=n(688);const $=Object(O.b)({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:d=!1,bias:b,activation:h="linear",preluActivationWeights:p,leakyreluAlpha:O=.2}){if(!1===Object(f.d)(a.a.state.gradientDepth,h)){let a=Object(k.a)(e,t,n,d);return null!=b&&(a=Object(u.a)(a,b)),Object(f.a)(a,h,p,O)}let g=Object(c.a)(e,"a","fused matMul"),m=Object(c.a)(t,"b","fused matMul");[g,m]=Object(o.makeTypesMatch)(g,m);const v=n?g.shape[g.rank-2]:g.shape[g.rank-1],x=d?m.shape[m.rank-1]:m.shape[m.rank-2],w=n?g.shape[g.rank-1]:g.shape[g.rank-2],$=d?m.shape[m.rank-2]:m.shape[m.rank-1],y=g.shape.slice(0,-2),E=m.shape.slice(0,-2),A=i.O(y),M=i.O(E);i.c(v===x,(()=>`Error in fused matMul: inner shapes (${v}) and (${x}) of Tensors with shapes ${g.shape} and ${m.shape} and transposeA=${n} and transposeB=${d} must match.`));const S=l.assertAndGetBroadcastShape(g.shape.slice(0,-2),m.shape.slice(0,-2)).concat([w,$]),T=n?Object(j.a)(g,[A,v,w]):Object(j.a)(g,[A,w,v]),C=d?Object(j.a)(m,[M,$,x]):Object(j.a)(m,[M,x,$]);let _,R;null!=b&&(_=Object(c.a)(b,"bias","fused matMul"),[_]=Object(o.makeTypesMatch)(_,g),l.assertAndGetBroadcastShape(S,_.shape)),null!=p&&(R=Object(c.a)(p,"prelu weights","fused matMul"));const z=(e,t)=>{const[a,r,s,o]=t,c=Object(f.c)(Object(j.a)(e,s.shape),s,h);let i,u;return n||d?!n&&d?(i=Object(k.a)(c,r,!1,!1),u=Object(k.a)(c,a,!0,!1)):n&&!d?(i=Object(k.a)(r,c,!1,!0),u=Object(k.a)(a,c,!1,!1)):(i=Object(k.a)(r,c,!0,!0),u=Object(k.a)(c,a,!0,!0)):(i=Object(k.a)(c,r,!1,!0),u=Object(k.a)(a,c,!0,!1)),null!=b?[i,u,Object(f.b)(o,c)]:[i,u]},D={a:T,b:C,bias:_,preluActivationWeights:R},K={transposeA:n,transposeB:d,activation:h,leakyreluAlpha:O};if(null==b){const e=Object(r.a)(((e,t,n)=>{const r=a.a.runKernel(s.xd,D,K);return n([e,t,r]),{value:Object(j.a)(r,S),gradFunc:z}}));return e(T,C)}{const e=Object(r.a)(((e,t,n,r)=>{const o=a.a.runKernel(s.xd,D,K);return r([e,t,o,n]),{value:Object(j.a)(o,S),gradFunc:z}}));return e(T,C,_)}}});n.d(t,"conv2d",(function(){return x})),n.d(t,"depthwiseConv2d",(function(){return w})),n.d(t,"matMul",(function(){return $}))},1519:function(e,t,n){"use strict";var a,r,s,o,c;n.d(t,"a",(function(){return i})),a=n(620),r=n(617),s=n(619),o=n(661),c=n(618);const i=Object(c.b)({flipLeftRight_:function(e){const t=Object(s.a)(e,"image","flipLeftRight","float32");o.c(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return a.a.runKernel(r.jb,n,{})}})},1520:function(e,t,n){"use strict";var a,r,s,o;n.d(t,"a",(function(){return c})),a=n(619),r=n(661),s=n(618),o=n(771);const c=Object(s.b)({grayscaleToRGB_:function(e){const t=Object(a.a)(e,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];r.c(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),r.c(1===s,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`));const c=Array(t.rank);return c.fill(1,0,n),c[n]=3,Object(o.a)(t,c)}})},1523:function(e,t,n){"use strict";var a,r,s,o,c;n.d(t,"a",(function(){return i})),a=n(620),r=n(617),s=n(619),o=n(661),c=n(618);const i=Object(c.b)({cropAndResize_:function(e,t,n,c,i="bilinear",u=0){const l=Object(s.a)(e,"image","cropAndResize"),d=Object(s.a)(t,"boxes","cropAndResize","float32"),b=Object(s.a)(n,"boxInd","cropAndResize","int32"),h=d.shape[0];o.c(4===l.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${l.rank}.`)),o.c(2===d.rank&&4===d.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${d.shape}.`)),o.c(1===b.rank&&b.shape[0]===h,(()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${d.shape}.`)),o.c(2===c.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${c.length}.`)),o.c(c[0]>=1&&c[1]>=1,(()=>"cropSize must be atleast [1,1], but was "+c)),o.c("bilinear"===i||"nearest"===i,(()=>"method must be bilinear or nearest, but was "+i));const p={image:l,boxes:d,boxInd:b},f={method:i,extrapolationValue:u,cropSize:c};return a.a.runKernel(r.M,p,f)}})},1524:function(e,t,n){"use strict";var a,r,s,o,c;n.d(t,"a",(function(){return i})),a=n(620),r=n(617),s=n(619),o=n(778),c=n(618);const i=Object(c.b)({nonMaxSuppression_:function(e,t,n,c=.5,i=-1/0){const u=Object(s.a)(e,"boxes","nonMaxSuppression","float32"),l=Object(s.a)(t,"scores","nonMaxSuppression","float32"),d=Object(o.a)(u,l,n,c,i),b={maxOutputSize:n=d.maxOutputSize,iouThreshold:c=d.iouThreshold,scoreThreshold:i=d.scoreThreshold};return a.a.runKernel(r.ec,{boxes:u,scores:l},b)}})},1525:function(e,t,n){"use strict";var a,r,s,o;n.d(t,"a",(function(){return c})),a=n(762),r=n(619),s=n(778),o=n(722);const c=async function(e,t,n,c=.5,i=-1/0){const u=Object(r.a)(e,"boxes","nonMaxSuppressionAsync"),l=Object(r.a)(t,"scores","nonMaxSuppressionAsync"),d=Object(s.a)(u,l,n,c,i);n=d.maxOutputSize,c=d.iouThreshold,i=d.scoreThreshold;const b=await Promise.all([u.data(),l.data()]),h=b[0],p=b[1],{selectedIndices:f}=Object(a.a)(h,p,n,c,i);return u!==e&&u.dispose(),l!==t&&l.dispose(),Object(o.a)(f,"int32")}},1528:function(e,t,n){"use strict";var a,r,s,o,c;n.d(t,"a",(function(){return i})),a=n(620),r=n(617),s=n(619),o=n(778),c=n(618);const i=Object(c.b)({nonMaxSuppressionPadded_:function(e,t,n,c=.5,i=-1/0,u=!1){const l=Object(s.a)(e,"boxes","nonMaxSuppression"),d=Object(s.a)(t,"scores","nonMaxSuppression"),b=Object(o.a)(l,d,n,c,i,null),h={boxes:l,scores:d},p={maxOutputSize:b.maxOutputSize,iouThreshold:b.iouThreshold,scoreThreshold:b.scoreThreshold,padToMaxOutputSize:u},f=a.a.runKernel(r.fc,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}})},1529:function(e,t,n){"use strict";var a,r,s,o,c;n.d(t,"a",(function(){return i})),a=n(762),r=n(619),s=n(778),o=n(639),c=n(722);const i=async function(e,t,n,i=.5,u=-1/0,l=!1){const d=Object(r.a)(e,"boxes","nonMaxSuppressionAsync"),b=Object(r.a)(t,"scores","nonMaxSuppressionAsync"),h=Object(s.a)(d,b,n,i,u,null),p=h.maxOutputSize,f=h.iouThreshold,O=h.scoreThreshold,[j,g]=await Promise.all([d.data(),b.data()]),{selectedIndices:m,validOutputs:v}=Object(a.b)(j,g,p,f,O,l);return d!==e&&d.dispose(),b!==t&&b.dispose(),{selectedIndices:Object(c.a)(m,"int32"),validOutputs:Object(o.a)(v,"int32")}}},696:function(e,t,n){"use strict";var a,r,s,o,c,i;n.d(t,"a",(function(){return u})),a=n(620),r=n(617),s=n(643),o=n(619),c=n(637),i=n(618);const u=Object(i.b)({greater_:function(e,t){let n=Object(o.a)(e,"a","greater","string_or_numeric"),i=Object(o.a)(t,"b","greater","string_or_numeric");[n,i]=Object(s.makeTypesMatch)(n,i),Object(c.assertAndGetBroadcastShape)(n.shape,i.shape);const u={a:n,b:i};return a.a.runKernel(r.sb,u)}})},743:function(e,t,n){"use strict";var a,r,s,o,c,i;n.d(t,"a",(function(){return u})),a=n(620),r=n(617),s=n(643),o=n(619),c=n(637),i=n(618);const u=Object(i.b)({greaterEqual_:function(e,t){let n=Object(o.a)(e,"a","greaterEqual","string_or_numeric"),i=Object(o.a)(t,"b","greaterEqual","string_or_numeric");[n,i]=Object(s.makeTypesMatch)(n,i),Object(c.assertAndGetBroadcastShape)(n.shape,i.shape);const u={a:n,b:i};return a.a.runKernel(r.tb,u)}})},747:function(e,t,n){"use strict";function a(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Object(u.a)(e,Object(f.a)(t));throw Error(`Cannot compute gradient for fused activation ${n}.`)}function r(e,t){let n=t;const a=o.getReductionAxes(e.shape,t.shape);return a.length>0&&(n=Object(O.a)(n,a)),Object(h.a)(n,e.shape)}function s(e,t,n,a){if("linear"===t)return e;if("relu"===t)return Object(d.a)(e);if("elu"===t)return Object(c.a)(e);if("relu6"===t)return Object(b.a)(e);if("prelu"===t)return Object(l.a)(e,n);if("leakyrelu"===t)return Object(i.a)(e,a);if("sigmoid"===t)return Object(p.a)(e);throw Error(`Unknown fused activation ${t}.`)}var o,c,i,u,l,d,b,h,p,f,O;n.d(t,"c",(function(){return a})),n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return s})),n.d(t,"d",(function(){return j})),o=n(637),c=n(862),i=n(865),u=n(625),l=n(872),d=n(774),b=n(877),h=n(623),p=n(768),f=n(775),O=n(647);const j=(e,t)=>!(e>0)||"linear"===t},767:function(e,t,n){"use strict";function a(e,t,n){Object(o.d)(e);const a={shape:e,value:t,dtype:n=n||Object(o.s)(t)};return r.a.runKernel(s.ib,{},a)}var r,s,o;n.d(t,"a",(function(){return a})),r=n(620),s=n(617),o=n(661)},804:function(e,t,n){"use strict";var a,r,s,o;n.d(t,"a",(function(){return c})),a=n(620),r=n(617),s=n(619),o=n(618);const c=Object(o.b)({gather_:function(e,t,n=0,o=0){const c={x:Object(s.a)(e,"x","gather"),indices:Object(s.a)(t,"indices","gather","int32")},i={axis:n,batchDims:o};return a.a.runKernel(r.rb,c,i)}})},805:function(e,t,n){"use strict";var a,r,s,o;n.d(t,"a",(function(){return c})),a=n(620),r=n(617),s=n(619),o=n(618);const c=Object(o.b)({imag_:function(e){const t={input:Object(s.a)(e,"input","imag")};return a.a.runKernel(r.wb,t)}})},851:function(e,t,n){"use strict";var a,r,s,o,c;n.d(t,"a",(function(){return i})),a=n(620),r=n(617),s=n(643),o=n(619),c=n(618);const i=Object(c.b)({floorDiv_:function(e,t){let n=Object(o.a)(e,"a","floorDiv"),c=Object(o.a)(t,"b","floorDiv");[n,c]=Object(s.makeTypesMatch)(n,c);const i={a:n,b:c};return a.a.runKernel(r.lb,i)}})},864:function(e,t,n){"use strict";var a,r,s,o;n.d(t,"a",(function(){return c})),a=n(620),r=n(617),s=n(619),o=n(618);const c=Object(o.b)({floor_:function(e){const t={x:Object(s.a)(e,"x","floor","float32")};return a.a.runKernel(r.kb,t)}})},884:function(e,t,n){"use strict";function a(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if("int32"!==t.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(0===Object(r.O)(e.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,o=s[s.length-1];let c=1;for(let r=0;r<s.length-1;++r)c*=s[r];const i=e.shape,u=s.slice();u.pop();let l=1;for(let r=o;r<n;++r)l*=i[r],u.push(i[r]);const d=[...Object(r.k)(e.shape).map((e=>e/l)),1].slice(0,o);return[u,c,l,d]}n.r(t),n.d(t,"prepareAndValidate",(function(){return a}));var r=n(661)}}]);