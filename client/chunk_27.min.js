/*! For license information please see chunk_27.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{1246:function(e,n,t){"use strict";t.d(n,"a",(function(){return a})),t.d(n,"b",(function(){return s}));class a{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,t=e.strideWidth,a=e.dilationHeight,s=e.effectiveFilterHeight,r=e.effectiveFilterWidth,o=s-1-e.padInfo.top,i=r-1-e.padInfo.left,c=s*r-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${n}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${r} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class s{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,t=e.strideHeight,a=e.strideWidth,s=e.dilationDepth,r=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,u=i-1-e.padInfo.front,p=c-1-e.padInfo.top,l=d-1-e.padInfo.left,h=i*c*d-1;this.userCode=`\n      const ivec3 pads = ivec3(${u}, ${p}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${n}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${r}) {\n            float dyR = float(dyRCorner + wR) / ${t}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${d} +\n                  wR * ${d} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},1248:function(e,n,t){"use strict";var a,s,r;t.d(n,"a",(function(){return i})),t.d(n,"b",(function(){return c})),a=t(616),s=t(626),r=t(628);const o="return a - b;",i=Object(s.b)({opSnippet:o,packedOpSnippet:o,supportsComplex:!0,cpuKernelImpl:r.S}),c={kernelName:a.zd,backendName:"webgl",kernelFunc:i}},1250:function(e,n,t){"use strict";function a(e){const{inputs:n,backend:t}=e,{x:s}=n;if("complex64"===s.dtype){const e=Object(c.a)({inputs:{input:s},backend:t}),n=a({inputs:{x:e},backend:t}),o=Object(i.a)({inputs:{input:s},backend:t}),d=a({inputs:{x:o},backend:t}),u=Object(r.a)({inputs:{real:n,imag:d},backend:t});return t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(d),u}return Object(o.a)({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:t})}var s,r,o,i,c;t.d(n,"a",(function(){return a})),t.d(n,"b",(function(){return d})),s=t(616),r=t(730),o=t(828),i=t(897),c=t(827);const d={kernelName:s.Pd,backendName:"webgl",kernelFunc:a}},1253:function(e,n,t){"use strict";function a(e){const{inputs:n,backend:t,attrs:a}=e,{x:i}=n,{reps:c}=a;if("string"===i.dtype||i.shape.length>5){const e=t.readSync(i.dataId),n="string"===i.dtype?e.map((e=>s.Si.decodeString(e))):e,a=Object(s.we)(i.shape,i.dtype,n),o=Object(r.T)(a,c);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const d=new o.a(i.shape,c);return t.runWebGLProgram(d,[i],i.dtype)}var s,r,o;t.d(n,"a",(function(){return a})),t.d(n,"b",(function(){return i})),s=t(616),r=t(628),o=t(2123);const i={kernelName:s.Gd,backendName:"webgl",kernelFunc:a}},1934:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return r})),a=t(616),s=t(1033);const r={kernelName:a.Qd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{a:r,b:o,bias:i,preluActivationWeights:c}=n,{transposeA:d,transposeB:u,activation:p,leakyreluAlpha:l}=a;return Object(s.b)({a:r,b:o,transposeA:d,transposeB:u,backend:t,bias:i,preluActivationWeights:c,leakyreluAlpha:l,activation:p})}}},2039:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));class a{constructor(e,n,t,a,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const r=n,o=e[3]-1;let i;this.outputShape=e;const c=`float(${t}) + float(${a}) * sum`;i=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${r};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${r}; j <= ${r}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}},2040:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));class a{constructor(e,n,t,a,s){this.variableNames=["x"],this.outputShape=[];const r=n,o=e[3]-1;let i;this.outputShape=e;const c=`float(${t}) + float(${a}) * sum`;i=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${r}; j <= ${r}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}},2042:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));class a{constructor(e,n,t,a,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=t,this.alpha=a,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${n})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${n} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${t});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}},2110:function(e,n,t){"use strict";var a,s,r;t.d(n,"a",(function(){return c})),a=t(616),s=t(626),r=t(628);const o="return sqrt(x);",i=Object(s.d)({opSnippet:o,packedOpSnippet:o,cpuKernelImpl:r.M}),c={kernelName:a.qd,backendName:"webgl",kernelFunc:i}},2111:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return o})),a=t(616),s=t(626);const r=Object(s.d)({opSnippet:"return x * x;"}),o={kernelName:a.rd,backendName:"webgl",kernelFunc:r}},2112:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return i})),a=t(616),s=t(626);const r="return (a - b) * (a - b);",o=Object(s.b)({opSnippet:r,packedOpSnippet:r}),i={kernelName:a.sd,backendName:"webgl",kernelFunc:o}},2113:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return r})),a=t(616),s=t(628);const r={kernelName:a.td,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o}=n;if("string"!==o.dtype)throw Error("Input must be of datatype string");const i=t.readSync(o.dataId),c=a.ie.fromUint8ToStringArray(i),d=Object(s.N)(c,"string",r);return t.makeTensorInfo(o.shape,"string",d)}}},2114:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return r})),a=t(616),s=t(667);const r={kernelName:a.ud,backendName:"webgl",kernelFunc:function({inputs:e,attrs:n,backend:t}){const{x:a}=e,r=s.b+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,o=new s.i(a.shape,r);return t.runWebGLProgram(o,[a],a.dtype)}}},2115:function(e,n,t){"use strict";var a,s,r,o,i;t.d(n,"a",(function(){return c})),a=t(616),s=t(628),r=t(2116),o=t(636),i=t(782);const c={kernelName:a.vd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:c}=e,{x:d}=n,{begin:u,end:p,strides:l,beginMask:h,endMask:f,ellipsisMask:b,newAxisMask:m,shrinkAxisMask:k}=c,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:v,isSimpleSlice:I,begin:C,end:w,strides:O}=a.Zh.sliceInfo(d.shape,u,p,l,h,f,b,m,k);let N;if(x)N=Object(o.a)({inputs:{x:d},backend:t,attrs:{shape:y}});else if(v||I){a.Si.assert(d.shape.length>=1,(()=>"Input must have rank at least 1, got: "+d.shape.length));const e=a.Zh.computeOutShape(C,w,O),n=Object(i.a)({inputs:{x:d},backend:t,attrs:{begin:C,size:e}});N=Object(o.a)({inputs:{x:n},backend:t,attrs:{shape:y}}),t.disposeIntermediateTensorInfo(n)}else if(t.shouldExecuteOnCPU([d])){const e=t.readSync(d.dataId),n=Object(a.we)(d.shape,d.dtype,e),r=Object(s.O)(g,n,O,C);N=t.makeTensorInfo(y,d.dtype,r.values)}else{const e=new r.a(C,O,g);N=t.runWebGLProgram(e,[d],d.dtype)}const S=Object(o.a)({inputs:{x:N},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(N),S}}},2117:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return r})),a=t(616),s=t(628);const r={kernelName:a.wd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:i,rightPad:c,padWidth:d,preserveShortSequences:u}=a,{data:p,dataSplits:l}=n,h=t.readSync(p.dataId),f=t.readSync(l.dataId),[b,m]=Object(s.P)(h,f,r,o,i,c,d,u);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(l.shape,"int32",m)]}}},2118:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return r})),a=t(616),s=t(628);const r={kernelName:a.xd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw Error("Input must be of datatype string");if(1!==o.shape.length)throw Error("Input must be a vector, got shape: "+o.shape);if(0!==i.shape.length)throw Error("Delimiter must be a scalar, got shape: "+i.shape);const c=t.readSync(o.dataId),d=t.readSync(i.dataId)[0],[u,p,l]=Object(s.Q)(c,d,r),h=p.length;return[t.makeTensorInfo([h,2],"int32",u),t.makeTensorInfo([h],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(l))]}}},2119:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return r})),a=t(616),s=t(628);const r={kernelName:a.yd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{numBuckets:r}=a,{input:o}=n;if("string"!==o.dtype)throw Error("Input must be of datatype string");if(r<=0)throw Error("Number of buckets must be at least 1");const i=t.readSync(o.dataId),c=Object(s.R)(i,r);return t.makeTensorInfo(o.shape,"int32",c)}}},2120:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return o})),a=t(616),s=t(626);const r=Object(s.d)({opSnippet:"return tan(x);"}),o={kernelName:a.Bd,backendName:"webgl",kernelFunc:r}},2121:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return o})),a=t(616),s=t(626);const r=Object(s.d)({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),o={kernelName:a.Cd,backendName:"webgl",kernelFunc:r}},2122:function(e,n,t){"use strict";var a,s,r;t.d(n,"a",(function(){return o})),a=t(616),s=t(1037),r=t(636);const o={kernelName:a.Fd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{tensor:i,indices:c,updates:d}=n,{}=o,{sliceRank:u,numUpdates:p,sliceSize:l,strides:h,outputSize:f}=a.ie.calculateShapes(d,c,i.shape),b=[f/l,l];if(0===f)return t.makeTensorInfo(i.shape,c.dtype);const m=Object(r.a)({inputs:{x:c},backend:t,attrs:{shape:[p,u]}}),k=Object(r.a)({inputs:{x:d},backend:t,attrs:{shape:[p,l]}}),g=Object(r.a)({inputs:{x:i},backend:t,attrs:{shape:b}}),y=new s.a(p,u,m.shape.length,k.shape.length,h,b,!1,!0),x=t.runWebGLProgram(y,[k,m,g],g.dtype),v=Object(r.a)({inputs:{x},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),v}}},2124:function(e,n,t){"use strict";function a(e,n){null!==n&&e.disposeIntermediateTensorInfo(n)}function s(e){let n=1;for(;n<e;)n*=2;return n}var r,o,i,c,d,u,p;t.d(n,"a",(function(){return l})),r=t(616),o=t(628),i=t(2125),c=t(828),d=t(1245),u=t(636),p=t(782);const l={kernelName:r.Hd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:l}=e,{x:h}=n,{k:f,sorted:b}=l,m=Object(r.of)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),k=Object(r.of)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),g=h.shape,y=g[g.length-1];if(t.shouldExecuteOnCPU([h])||y<m||f>k){const e=t.readSync(h.dataId),[n,a]=Object(o.U)(e,g,h.dtype,f,b);return[t.makeTensorInfo(n.shape,n.dtype,n.values),t.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===f)return g[g.length-1]=0,[t.makeTensorInfo(g,h.dtype,[]),t.makeTensorInfo(g,"int32",[])];if(1===y)return[h,Object(c.a)({attrs:{shape:g,dtype:"int32",value:0},backend:t})];const x=t.texData.get(h.dataId),v=null!==x&&x.isPacked,I=v?t.unpackTensor(h):h,C=r.Si.sizeFromShape(g)/y,w=Object(u.a)({inputs:{x:I},attrs:{shape:[C,y]},backend:t});v&&a(t,I);const O=s(f),N=s(y);let S=null;const $=()=>null===S?[w,w]:[w,S],j=(e,n,s)=>{const r=$(),o=new i.b(s),c=[[y],[null===S?1:0],[-1/0],[e],[n]],d=S;S=t.runWebGLProgram(o,r,"int32",c),a(t,d)};for(let a=1;a<O;a*=2){const e=2*a;for(let n=a;n>=1;n/=2)j(e,n,[C,N])}for(let s=N;s>O;s/=2){const e=$(),n=new i.a([C,s/2]),r=[[y],[null===S?1:0],[O]],o=S;S=t.runWebGLProgram(n,e,"int32",r),a(t,o);const c=O/2,d=2*c;for(let t=c;t>=1;t/=2)j(d,t,S.shape)}let R=S;S=Object(p.a)({inputs:{x:S},backend:t,attrs:{begin:0,size:[C,f]}}),a(t,R);let P=Object(d.a)({inputs:{x:w,indices:S},backend:t,attrs:{axis:1,batchDims:1}});a(t,w);const T=g.slice(0,-1);T.push(f),R=S,S=Object(u.a)({inputs:{x:S},attrs:{shape:T},backend:t}),a(t,R);const D=P;return P=Object(u.a)({inputs:{x:P},attrs:{shape:T},backend:t}),a(t,D),[P,S]}}},2126:function(e,n,t){"use strict";var a,s;t.d(n,"a",(function(){return r})),a=t(616),s=t(2127);const r={kernelName:a.Id,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{image:r,transforms:o}=n,{interpolation:i,fillMode:c,fillValue:d,outputShape:u}=a,[p,l,h,f]=r.shape,[b,m]=null!=u?u:[l,h],k=[p,b,m,f],g=new s.a(l,h,i,c,d,k);return t.runWebGLProgram(g,[r,o],"float32")}}},2128:function(e,n,t){"use strict";var a,s,r;t.d(n,"a",(function(){return o})),a=t(616),s=t(628),r=t(674);const o={kernelName:a.Kd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,attrs:t,backend:a}=e,{axis:o}=t,{x:i}=n;Object(r.assertNotComplex)(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const c=a.readSync(i.dataId),{outputValues:d,outputShape:u,indices:p}=Object(s.W)(c,o,i.shape,i.dtype);return[a.makeTensorInfo(u,i.dtype,d),a.makeTensorInfo([p.length],"int32",p)]}}},2129:function(e,n,t){"use strict";var a,s,r;t.d(n,"a",(function(){return o})),a=t(616),s=t(636),r=t(782);const o={kernelName:a.Ld,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{value:o}=n;let{axis:i}=a;i<0&&(i+=o.shape.length);const c=o,d=c.shape.length,u=o.shape[i],p=Array(d-1);let l=0;for(let s=0;s<d;s++)s!==i&&(p[l++]=c.shape[s]);const h=[],f=Array(d).fill(0),b=c.shape.slice();b[i]=1;const m=Array(u);for(let k=0;k<m.length;k++){f[i]=k;const e=Object(r.a)({inputs:{x:c},backend:t,attrs:{begin:f,size:b}}),n=Object(s.a)({inputs:{x:e},backend:t,attrs:{shape:p}});m[k]=n,h.push(e)}return h.forEach((e=>t.disposeIntermediateTensorInfo(e))),m}}},2130:function(e,n,t){"use strict";var a,s,r,o,i,c;t.d(n,"a",(function(){return d})),a=t(616),s=t(2131),r=t(1252),o=t(636),i=t(1253),c=t(684);const d={kernelName:a.Md,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:d}=e,{x:u,segmentIds:p}=n,{numSegments:l}=d,h=u.shape.length,f=[];let b=0;const m=a.ie.getAxesPermutation([b],h);let k=u;null!=m&&(k=Object(c.a)({inputs:{x:u},backend:t,attrs:{perm:m}}),f.push(k),b=a.ie.getInnerMostAxes(1,h)[0]);const g=a.ie.segment_util.computeOutShape(k.shape,b,l),y=a.Si.sizeFromShape([k.shape[b]]),x=Object(o.a)({inputs:{x:k},backend:t,attrs:{shape:[-1,y]}});f.push(x);const v=Object(a.ri)(u.dtype),I=(e,n,o,c,d)=>{const u=e.shape[0],p=e.shape[1],l=a.ie.segment_util.segOpComputeOptimalWindowSize(p,d),h={windowSize:l,inSize:p,batchSize:u,numSegments:d},b=new s.a(h,n),m=t.compileAndRun(b,[e,o],c);if(f.push(m),m.shape[1]===d)return m;const k=Object(r.a)({backend:t,attrs:{start:0,stop:d,step:1,dtype:"float32"}}),g=Object(i.a)({inputs:{x:k},backend:t,attrs:{reps:[p/l]}});return f.push(k),f.push(g),I(m,n,g,c,d)},C=I(x,"unsortedSegmentSum",p,v,l),w=Object(o.a)({inputs:{x:C},backend:t,attrs:{shape:g}});let O=w;if(null!=m){f.push(w);const e=a.ie.getUndoAxesPermutation(m);O=Object(c.a)({inputs:{x:O},backend:t,attrs:{perm:e}})}return f.forEach((e=>t.disposeIntermediateTensorInfo(e))),O}}},684:function(e,n,t){"use strict";function a(e){const{inputs:n,backend:t,attrs:a}=e,{x:s}=n,{perm:i}=a,c=t,d=s.shape.length,u=Array(d);for(let r=0;r<u.length;r++)u[r]=s.shape[i[r]];let p;if(c.shouldExecuteOnCPU([s])){const e=c.texData.get(s.dataId).values,n=Object(o.V)(e,s.shape,s.dtype,i,u);p=c.makeTensorInfo(u,s.dtype),c.texData.get(p.dataId).values=n}else p=Object(r.a)(s,i,c);return p}var s,r,o;t.d(n,"a",(function(){return a})),t.d(n,"b",(function(){return i})),s=t(616),r=t(826),o=t(628);const i={kernelName:s.Jd,backendName:"webgl",kernelFunc:a}},826:function(e,n,t){"use strict";function a(e,n,t){const a=Object(s.of)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new o.a(e.shape,n):new r.a(e.shape,n);return t.runWebGLProgram(a,[e],e.dtype)}var s,r,o;t.d(n,"a",(function(){return a})),s=t(616),r=t(1937),o=t(1936)},908:function(e,n,t){"use strict";function a(e){const{inputs:n,backend:t,attrs:a}=e,{x:c}=n,{axis:d,keepDims:u}=a;return function(e,n,t,a){const c=n,d=e.shape.length,u=s.Si.parseAxisParam(c,e.shape);let p=u;const l=s.ie.getAxesPermutation(p,d),h=null!=l;let f=e;h&&(f=Object(i.a)(e,l,a),p=s.ie.getInnerMostAxes(p.length,d)),s.ie.assertAxesAreInnerMostDims("sum",p,d);const[b,m]=s.ie.computeOutAndReduceShapes(f.shape,p);let k=b;t&&(k=s.ie.expandShapeToKeepDim(b,u));const g=s.Si.sizeFromShape(m),y=s.Si.sizeFromShape(e.shape)/g,x=Object(o.a)({inputs:{x:f},attrs:{shape:[y,g]},backend:a}),v=Object(s.ri)(e.dtype),I=Object(r.a)(x,v,"sum",a),C=Object(o.a)({inputs:{x:I},attrs:{shape:k},backend:a});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(I),h&&a.disposeIntermediateTensorInfo(f),C}(c,d,u,t)}var s=t(616),r=t(754),o=t(636),i=t(826);t.d(n,"a",(function(){return a})),t.d(n,"b",(function(){return c}));const c={kernelName:s.Ad,backendName:"webgl",kernelFunc:a}}}]);