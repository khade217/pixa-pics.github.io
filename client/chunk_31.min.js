/*! For license information please see chunk_31.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{1159:function(e,t,n){"use strict";var r,s,i;n.d(t,"a",(function(){return a})),r=n(622),s=n(619),i=n(661);const a=async function(e,t){const n=Object(s.a)(e,"x","setdiff1d"),a=Object(s.a)(t,"y","setdiff1d");i.c(n.dtype===a.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`)),i.c(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),i.c(1===a.rank,(()=>`y should be 1D tensor, but got y (${a.shape}).`));const o=await n.data(),c=await a.data(),u=new Set(c);let l=0;for(let r=0;r<o.length;r++)u.has(o[r])||l++;const h=new r.b([l],n.dtype),d=new r.b([l],"int32");for(let r=0,s=0;r<o.length;r++)u.has(o[r])||(h.values[s]=o[r],d.values[s]=r,s++);return[h.toTensor(),d.toTensor()]}},1160:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({sign_:function(e){const t={x:Object(i.a)(e,"x","sign")};return r.a.runKernel(s.Nc,t)}})},1161:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(619),s=n(661),i=n(618),a=n(673);const o=Object(i.b)({slice1d_:function(e,t,n){const i=Object(r.a)(e,"x","slice1d");return s.c(1===i.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`)),Object(a.a)(i,[t],[n])}})},1162:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(619),s=n(661),i=n(618),a=n(673);const o=Object(i.b)({slice2d_:function(e,t,n){const i=Object(r.a)(e,"x","slice2d");return s.c(2===i.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`)),Object(a.a)(i,t,n)}})},1163:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(619),s=n(661),i=n(618),a=n(673);const o=Object(i.b)({slice3d_:function(e,t,n){const i=Object(r.a)(e,"x","slice3d");return s.c(3===i.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`)),Object(a.a)(i,t,n)}})},1164:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(619),s=n(661),i=n(618),a=n(673);const o=Object(i.b)({slice4d_:function(e,t,n){const i=Object(r.a)(e,"x","slice4d");return s.c(4===i.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`)),Object(a.a)(i,t,n)}})},1165:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({softmax_:function(e,t=-1){const n=Object(i.a)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const a={logits:n},o={dim:t};return r.a.runKernel(s.Rc,a,o)}})},1176:function(e,t,n){"use strict";var r,s,i,a,o,c;n.d(t,"a",(function(){return u})),r=n(620),s=n(617),i=n(619),a=n(661),o=n(618),c=n(776);const u=Object(o.b)({scatterND_:function(e,t,n){Object(a.d)(n);const o=Object(i.a)(e,"indices","scatterND","int32"),u=Object(i.a)(t,"updates","scatterND");c.validateInput(u,o,n);const l={indices:o,updates:u},h={shape:n};return r.a.runKernel(s.Ic,l,h)}})},1179:function(e,t,n){"use strict";var r,s;n.d(t,"a",(function(){return i})),r=n(618),s=n(813);const i=Object(r.b)({hannWindow_:function(e){return Object(s.a)(e,.5,.5)}})},1180:function(e,t,n){"use strict";var r,s,i,a,o,c;n.d(t,"a",(function(){return u})),r=n(680),s=n(767),i=n(618),a=n(623),o=n(673),c=n(882);const u=Object(i.b)({frame_:function(e,t,n,i=!1,u=0){let l=0;const h=[];for(;l+t<=e.size;)h.push(Object(o.a)(e,l,t)),l+=n;if(i)for(;l<e.size;){const i=l+t-e.size,a=Object(r.a)([Object(o.a)(e,l,t-i),Object(s.a)([i],u)]);h.push(a),l+=n}return 0===h.length?Object(c.a)([],[0,t]):Object(a.a)(Object(r.a)(h),[h.length,t])}})},1200:function(e,t,n){"use strict";function r(e,t){let n,r=!1;for(e<=o.a?(n=e,r=!0):n=Object(a.G)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Object(a.G)(e,n+1);return n}function s(e,t,n){const r=[],s=e.length;for(let i=0;i<s;i++)i!==t?r.push(e[i]):r.push(n);return r}function i(e,t,n,r){const s=t.shape.length,i=e.shape.length;if(0!==r&&(r<-s||r>s))throw Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(n<r)throw Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const a=e.shape[n],o=[];let c=1,u=1,l=1;for(let h=0;h<r;++h)o.push(e.shape[h]),c*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<i;h++)o.push(e.shape[h]),l*=e.shape[h];return{batchSize:c,sliceSize:l,outerSize:u,dimSize:a,outputShape:o}}var a,o;n.r(t),n.d(t,"segOpComputeOptimalWindowSize",(function(){return r})),n.d(t,"computeOutShape",(function(){return s})),n.d(t,"collectGatherOpShapeInfo",(function(){return i})),a=n(661),o=n(980)},1517:function(e,t,n){"use strict";var r,s;n.d(t,"a",(function(){return i})),r=n(618),s=n(813);const i=Object(r.b)({hammingWindow_:function(e){return Object(s.a)(e,.54,.46)}})},1518:function(e,t,n){"use strict";var r,s,i,a,o,c;n.d(t,"a",(function(){return u})),r=n(625),s=n(618),i=n(813),a=n(880),o=n(1180),c=n(1179);const u=Object(s.b)({stft_:function(e,t,n,s,u=c.a){null==s&&(s=Object(i.b)(t));const l=Object(o.a)(e,t,n),h=Object(r.a)(l,u(t));return Object(a.a)(h,s)}})},639:function(e,t,n){"use strict";function r(e,t){if((Object(s.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Object(s.isTypedArray)(e)&&!(e instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(i.a)(e,[],[],t)}var s,i;n.d(t,"a",(function(){return r})),s=n(621),i=n(715)},673:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({slice_:function(e,t,n){const a=Object(i.a)(e,"x","slice","string_or_numeric");if(0===a.rank)throw Error("Slicing scalar is not possible");const o={x:a},c={begin:t,size:n};return r.a.runKernel(s.Qc,o,c)}})},768:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({sigmoid_:function(e){const t={x:Object(i.a)(e,"x","sigmoid","float32")};return r.a.runKernel(s.Mc,t)}})},776:function(e,t,n){"use strict";function r(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,i="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+`, indices.shape: ${t.shape}, shape: ${e}`+`, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw Error(i+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw Error(i+" Output shape length < "+(r+(n.rank-s)));if(n.rank!==s+e.length-r)throw Error(i+" update.rank != "+(s+e.length-r));for(let a=0;a<s;++a)if(n.shape[a]!==t.shape[a])throw Error(i+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<n.rank-s;++a)if(n.shape[a+s]!==e[a+r])throw Error(i+` updates.shape[${a+s}] (${n.shape[a+s]}) != shape[${a+s}] (${e[a+s]})`)}function s(e,t,n){if(t.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw Error("The dtype of 'indices' should be int32, but got dtype: "+t.dtype);if(n.length<1)throw Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===t.size)throw Error("Indices specified for empty output. indices shape: "+t.shape);if(0===e.size)throw Error("Updates specified for empty output. updates shape: "+e.shape)}r(n,t,e)}function i(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=n.length;let o=1;for(let a=s;a<i;++a)o*=n[a];const c=s<1?1:s;return{sliceRank:s,numUpdates:Object(a.O)(t.shape)/c,sliceSize:o,strides:[...Object(a.k)(n.slice(0,s)),1],outputSize:Object(a.O)(n)}}n.r(t),n.d(t,"validateUpdateShape",(function(){return r})),n.d(t,"validateInput",(function(){return s})),n.d(t,"calculateShapes",(function(){return i}));var a=n(661)},813:function(e,t,n){"use strict";function r(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function s(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let i=0;i<e;++i){const a=2*Math.PI*i/(e+r-1);s[i]=t-n*Math.cos(a)}return Object(i.a)(s,"float32")}n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return s}));var i=n(722)},814:function(e,t,n){"use strict";function r(e,t,n){const r=e.shape.length;j.c(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),j.c(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)j.c(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function s(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function i(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function a(e,t,n,r){const s=[...e];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<n;i++)0===i?s[t]=1:(s.splice(t,0,1),s.pop());return s}function o(e,t,n){return n<=e?n:n-(t-1)}function c(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function u(e,t,n,r,s,i,o,c,u){const b=e.length;let g=Array(b),m=Array(b),k=Array(b);if(t.length&&n>0){const u=t[0],d=n+1;g=l(o,u,d,r,e),m=h(c,u,d,s,e),k=a(i,u,d,e)}else for(let a=0;a<b;a++)g[a]=f(o,r,i,e,a,u),m[a]=p(c,s,i,e,a,u),k[a]=d(i,a,u);return{begin:g,end:m,strides:k}}function l(e,t,n,r,s){const i=[...s],a=c(n,t);for(let c=0;c<i.length;c++)if(a.indexOf(c)>-1)i[c]=0;else{const s=o(t,n,c);let a=r[s];e&1<<s&&(a=0),i[c]=a}return i}function h(e,t,n,r,s){const i=[...s],a=c(n,t);for(let c=0;c<i.length;c++)if(a.indexOf(c)>-1)i[c]=Number.MAX_SAFE_INTEGER;else{const s=o(t,n,c);let a=r[s];e&1<<s&&(a=Number.MAX_SAFE_INTEGER),i[c]=a}for(let o=0;o<i.length;o++){const e=s[o];i[o]<0&&(i[o]+=e),i[o]=j.j(0,i[o],s[o])}return i}function d(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function f(e,t,n,r,s,i){let a=t[s];const o=n[s]||1;(e&1<<s||i&1<<s||null==a)&&(a=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=r[s];return a<0&&(a+=c),a=j.j(0,a,c-1),a}function p(e,t,n,r,s,i){let a=t[s];const o=n[s]||1;(e&1<<s||i&1<<s||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=r[s];return a<0&&(a+=c),a=o>0?j.j(0,a,c):j.j(-1,a,c-1),a}function b(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function g(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function m(e,t,n){let r;const s=e.shape.length;let i;return r="number"==typeof t?[t,...Array(s-1).fill(0)]:t.length<s?t.concat(Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{j.c(-1!==e,(()=>"slice() does not support negative begin indexing."))})),i=null==n?Array(s).fill(-1):"number"==typeof n?[n,...Array(s-1).fill(-1)]:n.length<s?n.concat(Array(s-n.length).fill(-1)):n,i=i.map(((t,n)=>t>=0?t:(j.c(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,i]}function k(e,t,n,r,s,i,a,o,c){let u;if(null==r?(u=Array(t.length),u.fill(1)):u=r,null!=a&&0!=(a&a-1))throw Error("Multiple ellipses in slice is not allowed.");let l=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:c};for(let k=0;k<h.dims;k++)l&&0!=(1<<k&o)&&h.numAddAxisAfterEllipsis++,1<<k&a&&(l=!0);l||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=Array(t.dims),t.end=Array(t.dims),t.strides=Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(E),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(w),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let f=!0,p=!0,b=!0;const g=[],m=[];for(let k=0;k<e.length;++k){if(0===d.strides[k])throw Error(`strides[${k}] must be non-zero`);const t=!!(d.shrinkAxisMask&1<<k),n=e[k];if(-1===n){g.push(t?1:-1);continue}const r=[d.beginMask&1<<k,d.endMask&1<<k],s=[d.strides[k]>0?0:-1,d.strides[k]>0?n:n-1];if(t&&d.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&1===d.strides[k];const i=!!(d.beginMask&1<<k&&d.endMask&1<<k);if(d.beginValid&&d.endValid){if(t){const e=d.begin[k]<0?n+d.begin[k]:d.begin[k];if(d.begin[k]=e,d.end[k]=d.begin[k]+1,e<0||e>=n)throw Error(`slice index ${d.begin[k]} of dimension ${k} out of bounds.`)}else d.begin[k]=O(d.begin[k],0,d.strides[k],n,r,s),d.end[k]=O(d.end[k],1,d.strides[k],n,r,s);const e=1===d.strides[k]&&0===d.begin[k]&&d.end[k]===n;f=f&&e,p=p&&(0===k&&1===d.strides[k]||e)}else f=f&&1===d.strides[k]&&i,p=p&&(0===k&&1===d.strides[k]||i);let a,o=!1;if(d.beginValid&&d.endValid?(a=d.end[k]-d.begin[k],o=!0):t?(a=1,o=!0):i&&n>=0&&(a=d.strides[k]<0?-n:n,o=!0),o){let e;e=0===a||a<0!=d.strides[k]<0?0:Math.trunc(a/d.strides[k])+(a%d.strides[k]!=0?1:0),g.push(e)}else g.push(-1)}for(let k=0;k<d.finalShapeGatherIndices.length;++k){const e=d.finalShapeGatherIndices[k];e>=0?m.push(g[e]):e===E&&m.push(1)}return{finalShapeSparse:m.filter(((e,t)=>d.finalShapeGatherIndices[t]!==E)),finalShape:m,isIdentity:f,sliceDim0:p,isSimpleSlice:b,begin:d.begin,end:d.end,strides:d.strides}}function O(e,t,n,r,s,i){if(s[t])return n>0?i[t]:i[t+1&1];{const t=e<0?r+e:e;return t<i[0]?i[0]:t>i[1]?i[1]:t}}n.r(t),n.d(t,"assertParamsValid",(function(){return r})),n.d(t,"maskToAxes",(function(){return s})),n.d(t,"computeOutShape",(function(){return i})),n.d(t,"stridesWithElidedDims",(function(){return a})),n.d(t,"getNormalizedAxes",(function(){return u})),n.d(t,"startIndicesWithElidedDims",(function(){return l})),n.d(t,"stopIndicesWithElidedDims",(function(){return h})),n.d(t,"stridesForAxis",(function(){return d})),n.d(t,"startForAxis",(function(){return f})),n.d(t,"stopForAxis",(function(){return p})),n.d(t,"isSliceContinous",(function(){return b})),n.d(t,"computeFlatOffset",(function(){return g})),n.d(t,"parseSliceParams",(function(){return m})),n.d(t,"sliceInfo",(function(){return k}));var j=n(661);const E=-2,w=-1},868:function(e,t,n){"use strict";var r,s,i,a,o,c;n.d(t,"a",(function(){return l})),r=n(620),s=n(617),i=n(619),a=n(661),o=n(618),c=n(623);const u=2147483648,l=Object(o.b)({searchSorted_:function(e,t,n="left"){const o=Object(i.a)(e,"sortedSequence","searchSorted"),l=Object(i.a)(t,"values","searchSorted"),h=o.shape[o.shape.length-1],d=l.shape[l.shape.length-1],f=Object(c.a)(o,[-1,h]),p=Object(c.a)(l,[-1,d]);if(f.rank<2)throw Error("Sorted input argument must be at least 2-dimensional");if(f.shape[0]!==p.shape[0])throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Object(a.O)(p.shape)>=u)throw Error("values tensor size must less than 2147483648");if(f.shape[1]>=u)throw Error("trailing dim_size must less than 2147483648 for int32 output type, was "+f.shape[1]);const b={sortedSequence:f,values:p},g={side:n};return r.a.runKernel(s.Jc,b,g)}})},959:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({softplus_:function(e){const t={x:Object(i.a)(e,"x","softplus")};return r.a.runKernel(s.Sc,t)}})},969:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({selu_:function(e){const t={x:Object(i.a)(e,"x","selu")};return r.a.runKernel(s.Lc,t)}})},970:function(e,t,n){"use strict";var r,s,i,a,o,c;n.d(t,"a",(function(){return u})),r=n(619),s=n(661),i=n(742),a=n(801),o=n(618),c=n(623);const u=Object(o.b)({separableConv2d_:function(e,t,n,o,u,l=[1,1],h="NHWC"){const d=Object(r.a)(e,"x","separableConv2d"),f=Object(r.a)(t,"depthwiseFilter","separableConv2d"),p=Object(r.a)(n,"pointwiseFilter","separableConv2d");let b=d,g=!1;if(3===d.rank&&(g=!0,b=Object(c.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),"NCHW"===h)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");s.c(4===b.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${b.rank}.`)),s.c(4===f.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${f.rank}.`)),s.c(4===p.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${f.rank}.`)),s.c(1===p.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`)),s.c(1===p.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`));const m=f.shape[2],k=f.shape[3];s.c(p.shape[2]===m*k,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*k}, but got ${p.shape[2]}.`));const O=Object(a.a)(b,f,o,u,h,l),j=Object(i.a)(O,p,1,"valid",h);return g?Object(c.a)(j,[j.shape[1],j.shape[2],j.shape[3]]):j}})},971:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({sin_:function(e){const t={x:Object(i.a)(e,"x","sin","float32")};return r.a.runKernel(s.Oc,t)}})},972:function(e,t,n){"use strict";var r,s,i,a;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),i=n(619),a=n(618);const o=Object(a.b)({sinh_:function(e){const t={x:Object(i.a)(e,"x","sinh")};return r.a.runKernel(s.Pc,t)}})},981:function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return s}));const r=1.7580993408473768,s=1.0507009873554805}}]);