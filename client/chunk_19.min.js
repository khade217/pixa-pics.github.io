/*! For license information please see chunk_19.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{1100:function(t,e,a){"use strict";function n(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}a.d(e,"a",(function(){return n}))},1167:function(t,e,a){"use strict";var n,r,s,i;a.d(e,"a",(function(){return c})),n=a(620),r=a(617),s=a(619),i=a(618);const c=Object(i.b)({tan_:function(t){const e={x:Object(s.a)(t,"x","tan","float32")};return n.a.runKernel(r.ld,e)}})},1168:function(t,e,a){"use strict";function n(t,e,a){if(Object(s.e)(t),null!=e&&4!==e.length)throw Error("tensor4d() requires shape to have four numbers");const n=Object(r.c)(t,a);if(4!==n.length&&1!==n.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===n.length&&null==e)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return Object(i.a)(t,e,n,a)}var r,s,i;a.d(e,"a",(function(){return n})),r=a(619),s=a(661),i=a(715)},1169:function(t,e,a){"use strict";function n(t,e,a){if(Object(s.e)(t),null!=e&&5!==e.length)throw Error("tensor5d() requires shape to have five numbers");const n=Object(r.c)(t,a);if(5!==n.length&&1!==n.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===n.length&&null==e)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return Object(i.a)(t,e,n,a)}var r,s,i;a.d(e,"a",(function(){return n})),r=a(619),s=a(661),i=a(715)},1170:function(t,e,a){"use strict";function n(t,e,a){if(Object(s.e)(t),null!=e&&6!==e.length)throw Error("tensor6d() requires shape to have six numbers");const n=Object(r.c)(t,a);if(6!==n.length&&1!==n.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===n.length&&null==e)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,Object(i.a)(t,e,n,a)}var r,s,i;a.d(e,"a",(function(){return n})),r=a(619),s=a(661),i=a(715)},1171:function(t,e,a){"use strict";var n,r,s,i,c;a.d(e,"a",(function(){return o})),n=a(620),r=a(617),s=a(619),i=a(618),c=a(776);const o=Object(i.b)({tensorScatterUpdate_:function(t,e,a){const i=Object(s.a)(t,"tensor","tensorScatterupdate"),o=Object(s.a)(e,"indices","tensorScatterupdate","int32"),u=Object(s.a)(a,"updates","tensorScatterupdate");if(c.validateInput(u,o,i.shape),i.dtype!==u.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${i.dtype} and ${u.dtype}.`);const l={tensor:i,indices:o,updates:u};return n.a.runKernel(r.nd,l,{})}})},1172:function(t,e,a){"use strict";var n,r,s,i;a.d(e,"a",(function(){return c})),n=a(661),r=a(704),s=a(618),i=a(873);const c=Object(s.b)({truncatedNormal_:function(t,e=0,a=1,s,c){if(Object(n.d)(t),null!=s&&"bool"===s)throw Error("Unsupported data type $ { dtype }");const o=new i.a(e,a,s,!0,c),u=Object(r.a)(t,s);for(let n=0;n<u.values.length;n++)u.values[n]=o.nextValue();return u.toTensor()}})},1173:function(t,e,a){"use strict";function n(t,e){return Object(r.a)(t,e,"right")}a.d(e,"a",(function(){return n}));var r=a(868)},1174:function(t,e,a){"use strict";function n(t,e=!0,a,n){return r.a.makeVariable(t,e,a,n)}a.d(e,"a",(function(){return n}));var r=a(620)},1504:function(t,e,a){"use strict";a(795);var n=a(657),r=a(1102),s=a(1104),i=a(765),c=a(1100);class o{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw Error("Browser's encoder only supports utf-8, but got "+e);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!=typeof window&&Object(n.c)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{t.source===window&&t.data.name===this.messageName&&(t.stopPropagation(),(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(t,e)}isTypedArray(t){return Object(c.a)(t)}}if(Object(n.c)().get("IS_BROWSER")){Object(n.c)().setPlatform("browser",new o);try{i.a.registerManager(s.a.URL_SCHEME,new s.b)}catch(u){}try{i.a.registerManager(r.a.URL_SCHEME,new r.b)}catch(u){}}},1505:function(t,e,a){"use strict";!function(t){var e=a(657);let n;Object(e.c)().get("IS_NODE")&&!Object(e.c)().get("IS_BROWSER")&&Object(e.c)().setPlatform("node",new class{constructor(){this.util=a(1507),this.textEncoder=new this.util.TextEncoder}fetch(t,r){return null!=Object(e.c)().global.fetch?Object(e.c)().global.fetch(t,r):(null==n&&(n=a(1506)),n(t,r))}now(){const e=t.hrtime();return 1e3*e[0]+e[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw Error("Node built-in encoder only supports utf-8, but got "+e);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}})}(a(47))},1508:function(t,e,a){"use strict";function n(){for(const t of b)Object(h.registerClass)(t)}var r,s,i,c,o,u,l,h;a.d(e,"a",(function(){return n})),r=a(849),s=a(852),i=a(853),c=a(854),o=a(855),u=a(856),l=a(798),h=a(850);const b=[r.a,s.a,i.a,c.a,o.a,u.a,l.a]},635:function(t,e,a){"use strict";var n,r,s,i,c;a.d(e,"a",(function(){return o})),n=a(620),r=a(617),s=a(643),i=a(619),c=a(618);const o=Object(c.b)({sub_:function(t,e){let a=Object(i.a)(t,"a","sub"),c=Object(i.a)(e,"b","sub");[a,c]=Object(s.makeTypesMatch)(a,c);const o={a,b:c};return n.a.runKernel(r.jd,o)}})},640:function(t,e,a){"use strict";var n,r,s,i;a.d(e,"a",(function(){return c})),n=a(620),r=a(617),s=a(619),i=a(618);const c=Object(i.b)({zerosLike_:function(t){const e={x:Object(s.a)(t,"x","zerosLike")};return n.a.runKernel(r.wd,e)}})},647:function(t,e,a){"use strict";var n,r,s,i,c;a.d(e,"a",(function(){return o})),n=a(620),r=a(617),s=a(619),i=a(629),c=a(618);const o=Object(c.b)({sum_:function(t,e=null,a=!1){let c=Object(s.a)(t,"x","sum");"bool"===c.dtype&&(c=Object(i.a)(c,"int32"));const o={x:c},u={axis:e,keepDims:a};return n.a.runKernel(r.kd,o,u)}})},681:function(t,e,a){"use strict";var n,r,s,i,c,o;a.d(e,"a",(function(){return u})),n=a(620),r=a(617),s=a(619),i=a(858),c=a(637),o=a(618);const u=Object(o.b)({where_:function(t,e,a){const o=Object(s.a)(e,"a","where"),u=Object(s.a)(a,"b","where"),l=Object(s.a)(t,"condition","where","bool"),h=Object(c.assertAndGetBroadcastShape)(Object(c.assertAndGetBroadcastShape)(l.shape,o.shape),u.shape),b={condition:Object(i.a)(l,h),t:Object(i.a)(o,h),e:Object(i.a)(u,h)};return n.a.runKernel(r.Kc,b)}})},706:function(t,e,a){"use strict";var n,r,s,i,c,o,u,l,h,b;a.d(e,"a",(function(){return d})),n=a(620),r=a(676),s=a(617),i=a(619),c=a(661),o=a(716),u=a(805),l=a(662),h=a(618),b=a(811);const d=Object(h.b)({transpose_:function(t,e,a){const h=Object(i.a)(t,"x","transpose");if(null==e&&(e=h.shape.map(((t,e)=>e)).reverse()),c.c(h.rank===e.length,(()=>`Error in transpose: rank of input ${h.rank} must match length of perm ${e}.`)),e.forEach((t=>{c.c(t>=0&&t<h.rank,(()=>"All entries in 'perm' must be between 0 and "+(h.rank-1)+" but got "+e))})),h.rank<=1)return h.clone();const d={x:h},m={perm:e};return"complex64"===h.dtype?Object(r.t)((()=>{let t=Object(b.a)(h),e=Object(u.a)(h);return t=n.a.runKernel(s.rd,{x:t},m),e=n.a.runKernel(s.rd,{x:e},m),a&&(e=Object(l.a)(e)),Object(o.a)(t,e)})):n.a.runKernel(s.rd,d,m)}})},715:function(t,e,a){"use strict";function n(t,e,a,n){if(null==n)n=Object(i.s)(t);else if("complex64"===n)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Object(s.c)(t)||Object(s.b)(t)){if("float32"!==n&&"int32"!==n)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return r.a.backend.createTensorFromGPUData(t,e||a,n)}if(!Object(c.isTypedArray)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Object(i.d)(e);const t=Object(i.O)(e),n=Object(i.O)(a);Object(i.c)(t===n,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${n}`));for(let r=0;r<a.length;++r){const t=a[r],n=r!==a.length-1||t!==Object(i.O)(e.slice(r));Object(i.c)(a[r]===e[r]||!n,(()=>`Error creating a new Tensor. Inferred shape (${a}) does not match the provided shape (${e}). `))}}return Object(c.isTypedArray)(t)||Array.isArray(t)||(t=[t]),e=e||a,t="string"!==n?Object(c.toTypedArray)(t,n):Object(c.flatten)(t,[],!0),r.a.makeTensor(t,e,n)}var r,s,i,c;a.d(e,"a",(function(){return n})),r=a(620),s=a(703),i=a(661),c=a(621)},717:function(t,e,a){"use strict";var n,r,s,i;a.d(e,"a",(function(){return c})),n=a(676),r=a(677),s=a(639),i=a(850);class c extends i.Serializable{minimize(t,e=!1,a){const{value:r,grads:s}=this.computeGradients(t,a);if(null!=a){const t=a.map((t=>({name:t.name,tensor:s[t.name]})));this.applyGradients(t)}else this.applyGradients(s);return Object(n.d)(s),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return Object(r.f)(t,e)}dispose(){null!=this.iterations_&&Object(n.d)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Object(s.a)(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(c,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients})},722:function(t,e,a){"use strict";function n(t,e){Object(s.e)(t);const a=Object(r.c)(t,e);if(1!==a.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return Object(i.a)(t,null,a,e)}var r,s,i;a.d(e,"a",(function(){return n})),r=a(619),s=a(661),i=a(715)},771:function(t,e,a){"use strict";var n,r,s,i,c;a.d(e,"a",(function(){return o})),n=a(620),r=a(617),s=a(619),i=a(661),c=a(618);const o=Object(c.b)({tile_:function(t,e){const a=Object(s.a)(t,"x","tile","string_or_numeric");i.c(a.rank===e.length,(()=>`Error in transpose: rank of input ${a.rank} must match length of reps ${e}.`));const c={x:a},o={reps:e};return n.a.runKernel(r.od,c,o)}})},773:function(t,e,a){"use strict";function n(t,e="float32"){if(Object(s.d)(t),"complex64"===e){const e=n(t,"float32"),a=n(t,"float32");return Object(i.a)(e,a)}const a=Object(s.F)(Object(s.O)(t),e);return r.a.makeTensor(a,t,e)}var r,s,i;a.d(e,"a",(function(){return n})),r=a(620),s=a(661),i=a(716)},777:function(t,e,a){"use strict";var n,r,s,i,c;a.d(e,"a",(function(){return o})),n=a(620),r=a(617),s=a(619),i=a(661),c=a(618);const o=Object(c.b)({unstack_:function(t,e=0){const a=Object(s.a)(t,"x","unstack","string_or_numeric");i.c(e>=-a.shape.length&&e<a.shape.length,(()=>`Axis = ${e} is not in [-${a.shape.length}, ${a.shape.length})`));const c={value:a},o={axis:e};return n.a.runKernel(r.td,c,o)}})},796:function(t,e,a){"use strict";function n(t,e,a){const n=Object(r.c)(t,a);return Object(s.a)(t,e,n,a)}var r,s;a.d(e,"a",(function(){return n})),r=a(619),s=a(715)},798:function(t,e,a){"use strict";var n,r,s,i,c,o;a.d(e,"a",(function(){return u})),n=a(620),r=a(676),s=a(641),i=a(625),c=a(639),o=a(717);class u extends o.a{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const c=Array.isArray(t)?t[a].tensor:t[e];if(null==c)return;const o=n.a.registeredVariables[e];Object(r.t)((()=>{const t=Object(s.a)(Object(i.a)(this.c,c),o);o.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Object(r.l)(Object(c.a)(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}},849:function(t,e,a){"use strict";var n,r,s,i,c,o,u,l,h;a.d(e,"a",(function(){return b})),n=a(620),r=a(676),s=a(641),i=a(634),c=a(625),o=a(687),u=a(653),l=a(640),h=a(717);class b extends h.a{static get className(){return"Adadelta"}constructor(t,e,a=null){super(),this.learningRate=t,this.rho=e,this.epsilon=a,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==a&&(this.epsilon=n.a.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const h=n.a.registeredVariables[e];null==this.accumulatedGrads[a]&&(this.accumulatedGrads[a]={originalName:e+"/accum_grad",variable:Object(r.t)((()=>Object(l.a)(h).variable(!1)))}),null==this.accumulatedUpdates[a]&&(this.accumulatedUpdates[a]={originalName:e+"/accum_var",variable:Object(r.t)((()=>Object(l.a)(h).variable(!1)))});const b=Array.isArray(t)?t[a].tensor:t[e];if(null==b)return;const d=this.accumulatedGrads[a].variable,m=this.accumulatedUpdates[a].variable;Object(r.t)((()=>{const t=Object(s.a)(Object(c.a)(d,this.rho),Object(c.a)(Object(u.a)(b),1-this.rho)),e=Object(c.a)(Object(i.a)(Object(o.a)(Object(s.a)(m,this.epsilon)),Object(o.a)(Object(s.a)(d,this.epsilon))),b),a=Object(s.a)(Object(c.a)(m,this.rho),Object(c.a)(Object(u.a)(e),1-this.rho));d.assign(t),m.assign(a);const n=Object(s.a)(Object(c.a)(e,-this.learningRate),h);h.assign(n)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Object(r.d)(this.accumulatedGrads.map((t=>t.variable))),Object(r.d)(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}},852:function(t,e,a){"use strict";var n,r,s,i,c,o,u,l,h;a.d(e,"a",(function(){return b})),n=a(620),r=a(676),s=a(641),i=a(634),c=a(767),o=a(625),u=a(687),l=a(653),h=a(717);class b extends h.a{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const h=n.a.registeredVariables[e];if(null==this.accumulatedGrads[a]){const t=!1;this.accumulatedGrads[a]={originalName:e+"/accumulator",variable:Object(r.t)((()=>Object(c.a)(h.shape,this.initialAccumulatorValue).variable(t)))}}const b=Array.isArray(t)?t[a].tensor:t[e];if(null==b)return;const d=this.accumulatedGrads[a].variable;Object(r.t)((()=>{const t=Object(s.a)(d,Object(l.a)(b));d.assign(t);const e=Object(s.a)(Object(o.a)(Object(i.a)(b,Object(u.a)(Object(s.a)(t,n.a.backend.epsilon()))),-this.learningRate),h);h.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Object(r.d)(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}},853:function(t,e,a){"use strict";var n,r,s,i,c,o,u,l,h,b,d,m;a.d(e,"a",(function(){return O})),n=a(620),r=a(676),s=a(641),i=a(634),c=a(625),o=a(718),u=a(639),l=a(687),h=a(653),b=a(635),d=a(640),m=a(717);class O extends m.a{static get className(){return"Adam"}constructor(t,e,a,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Object(r.t)((()=>{this.accBeta1=Object(u.a)(e).variable(),this.accBeta2=Object(u.a)(a).variable()})),null==s&&(this.epsilon=n.a.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Object(r.t)((()=>{const a=Object(b.a)(1,this.accBeta1),o=Object(b.a)(1,this.accBeta2);e.forEach(((e,u)=>{const b=n.a.registeredVariables[e];null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:e+"/m",variable:Object(r.t)((()=>Object(d.a)(b).variable(!1)))}),null==this.accumulatedSecondMoment[u]&&(this.accumulatedSecondMoment[u]={originalName:e+"/v",variable:Object(r.t)((()=>Object(d.a)(b).variable(!1)))});const m=Array.isArray(t)?t[u].tensor:t[e];if(null==m)return;const O=this.accumulatedFirstMoment[u].variable,f=this.accumulatedSecondMoment[u].variable,p=Object(s.a)(Object(c.a)(O,this.beta1),Object(c.a)(m,1-this.beta1)),j=Object(s.a)(Object(c.a)(f,this.beta2),Object(c.a)(Object(h.a)(m),1-this.beta2)),g=Object(i.a)(p,a),v=Object(i.a)(j,o);O.assign(p),f.assign(j);const y=Object(s.a)(Object(c.a)(Object(i.a)(g,Object(s.a)(Object(l.a)(v),this.epsilon)),-this.learningRate),b);b.assign(y)})),this.accBeta1.assign(Object(c.a)(this.accBeta1,this.beta1)),this.accBeta2.assign(Object(c.a)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Object(r.d)(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&Object(r.d)(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),Object(r.t)((()=>{this.accBeta1.assign(Object(o.a)(this.beta1,this.iterations_+1)),this.accBeta2.assign(Object(o.a)(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}},854:function(t,e,a){"use strict";var n,r,s,i,c,o,u,l,h,b,d;a.d(e,"a",(function(){return m})),n=a(620),r=a(676),s=a(741),i=a(641),c=a(634),o=a(797),u=a(625),l=a(639),h=a(635),b=a(640),d=a(717);class m extends d.a{static get className(){return"Adamax"}constructor(t,e,a,s=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Object(r.t)((()=>{this.iteration=Object(l.a)(0).variable(),this.accBeta1=Object(l.a)(e).variable()})),null==s&&(this.epsilon=n.a.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Object(r.t)((()=>{const a=Object(h.a)(1,this.accBeta1),r=Object(c.a)(-this.learningRate,Object(i.a)(Object(u.a)(this.iteration,this.decay),1));e.forEach(((e,l)=>{const h=n.a.registeredVariables[e];null==this.accumulatedFirstMoment[l]&&(this.accumulatedFirstMoment[l]={originalName:e+"/m",variable:Object(b.a)(h).variable(!1)}),null==this.accumulatedWeightedInfNorm[l]&&(this.accumulatedWeightedInfNorm[l]={originalName:e+"/v",variable:Object(b.a)(h).variable(!1)});const d=Array.isArray(t)?t[l].tensor:t[e];if(null==d)return;const m=this.accumulatedFirstMoment[l].variable,O=this.accumulatedWeightedInfNorm[l].variable,f=Object(i.a)(Object(u.a)(m,this.beta1),Object(u.a)(d,1-this.beta1)),p=Object(u.a)(O,this.beta2),j=Object(s.a)(d),g=Object(o.a)(p,j);m.assign(f),O.assign(g);const v=Object(i.a)(Object(u.a)(Object(c.a)(r,a),Object(c.a)(f,Object(i.a)(g,this.epsilon))),h);h.assign(v)})),this.iteration.assign(Object(i.a)(this.iteration,1)),this.accBeta1.assign(Object(u.a)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Object(r.d)(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&Object(r.d)(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}},855:function(t,e,a){"use strict";var n,r,s,i,c,o,u;a.d(e,"a",(function(){return l})),n=a(620),r=a(676),s=a(641),i=a(625),c=a(639),o=a(640),u=a(798);class l extends u.a{static get className(){return"Momentum"}constructor(t,e,a=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=a,this.accumulations=[],this.m=Object(c.a)(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const c=n.a.registeredVariables[e];if(null==this.accumulations[a]){const t=!1;this.accumulations[a]={originalName:e+"/momentum",variable:Object(r.t)((()=>Object(o.a)(c).variable(t)))}}const u=this.accumulations[a].variable,l=Array.isArray(t)?t[a].tensor:t[e];null!=l&&Object(r.t)((()=>{let t;const e=Object(s.a)(Object(i.a)(this.m,u),l);t=this.useNesterov?Object(s.a)(Object(i.a)(this.c,Object(s.a)(l,Object(i.a)(e,this.m))),c):Object(s.a)(Object(i.a)(this.c,e),c),u.assign(e),c.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Object(r.d)(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}},856:function(t,e,a){"use strict";var n,r,s,i,c,o,u,l,h,b;a.d(e,"a",(function(){return d})),n=a(620),r=a(676),s=a(641),i=a(634),c=a(625),o=a(687),u=a(653),l=a(635),h=a(640),b=a(717);class d extends b.a{static get className(){return"RMSProp"}constructor(t,e=.9,a=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=a,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=n.a.backend.epsilon()),null==t)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const b=n.a.registeredVariables[e],d=!1;null==this.accumulatedMeanSquares[a]&&(this.accumulatedMeanSquares[a]={originalName:e+"/rms",variable:Object(r.t)((()=>Object(h.a)(b).variable(d)))}),null==this.accumulatedMoments[a]&&(this.accumulatedMoments[a]={originalName:e+"/momentum",variable:Object(r.t)((()=>Object(h.a)(b).variable(d)))}),null==this.accumulatedMeanGrads[a]&&this.centered&&(this.accumulatedMeanGrads[a]={originalName:e+"/mg",variable:Object(r.t)((()=>Object(h.a)(b).variable(d)))});const m=Array.isArray(t)?t[a].tensor:t[e];if(null==m)return;const O=this.accumulatedMeanSquares[a].variable,f=this.accumulatedMoments[a].variable;Object(r.t)((()=>{const t=Object(s.a)(Object(c.a)(O,this.decay),Object(c.a)(Object(u.a)(m),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[a].variable,n=Object(s.a)(Object(c.a)(e,this.decay),Object(c.a)(m,1-this.decay)),r=Object(i.a)(Object(c.a)(m,this.learningRate),Object(o.a)(Object(l.a)(t,Object(s.a)(Object(u.a)(n),this.epsilon)))),h=Object(s.a)(Object(c.a)(f,this.momentum),r);O.assign(t),e.assign(n),f.assign(h);const d=Object(l.a)(b,h);b.assign(d)}else{const t=Object(s.a)(Object(c.a)(O,this.decay),Object(c.a)(Object(u.a)(m),1-this.decay)),e=Object(s.a)(Object(c.a)(f,this.momentum),Object(i.a)(Object(c.a)(m,this.learningRate),Object(o.a)(Object(s.a)(t,this.epsilon))));O.assign(t),f.assign(e);const a=Object(l.a)(b,e);b.assign(a)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Object(r.d)(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Object(r.d)(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&Object(r.d)(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,a=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}},882:function(t,e,a){"use strict";function n(t,e,a){if(Object(s.e)(t),null!=e&&2!==e.length)throw Error("tensor2d() requires shape to have two numbers");const n=Object(r.c)(t,a);if(2!==n.length&&1!==n.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===n.length&&null==e)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(i.a)(t,e,n,a)}var r,s,i;a.d(e,"a",(function(){return n})),r=a(619),s=a(661),i=a(715)},883:function(t,e,a){"use strict";var n,r,s,i,c;a.d(e,"a",(function(){return o})),n=a(620),r=a(617),s=a(619),i=a(661),c=a(618);const o=Object(c.b)({unsortedSegmentSum_:function(t,e,a){const c=Object(s.a)(t,"x","unsortedSegmentSum"),o=Object(s.a)(e,"segmentIds","unsortedSegmentSum","int32");Object(i.c)(Object(i.w)(a),(()=>"numSegments must be of dtype int"));const u={x:c,segmentIds:o},l={numSegments:a};return n.a.runKernel(r.ud,u,l)}})},938:function(t,e,a){"use strict";var n,r,s,i,c,o,u;a.d(e,"a",(function(){return l})),n=a(849),r=a(852),s=a(853),i=a(854),c=a(855),o=a(856),u=a(798);class l{static sgd(t){return new u.a(t)}static momentum(t,e,a=!1){return new c.a(t,e,a)}static rmsprop(t,e=.9,a=0,n=null,r=!1){return new o.a(t,e,a,n,r)}static adam(t=.001,e=.9,a=.999,n=null){return new s.a(t,e,a,n)}static adadelta(t=.001,e=.95,a=null){return new n.a(t,e,a)}static adamax(t=.002,e=.9,a=.999,n=null,r=0){return new i.a(t,e,a,n,r)}static adagrad(t,e=.1){return new r.a(t,e)}}},944:function(t,e,a){"use strict";var n,r,s,i;a.d(e,"a",(function(){return c})),n=a(620),r=a(617),s=a(619),i=a(618);const c=Object(i.b)({tanh_:function(t){const e={x:Object(s.a)(t,"x","tanh","float32")};return n.a.runKernel(r.md,e)}})},974:function(t,e,a){"use strict";function n(t,e,a){if(Object(s.e)(t),null!=e&&3!==e.length)throw Error("tensor3d() requires shape to have three numbers");const n=Object(r.c)(t,a);if(3!==n.length&&1!==n.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===n.length&&null==e)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(i.a)(t,e,n,a)}var r,s,i;a.d(e,"a",(function(){return n})),r=a(619),s=a(661),i=a(715)},975:function(t,e,a){"use strict";var n,r,s,i;a.d(e,"a",(function(){return c})),n=a(620),r=a(617),s=a(619),i=a(618);const c=Object(i.b)({topk_:function(t,e=1,a=!0){const i=Object(s.a)(t,"x","topk");if(0===i.rank)throw Error("topk() expects the input to be of rank 1 or higher");const c=i.shape[i.shape.length-1];if(e<0)throw Error("'k' passed to topk() must be >= 0 but got "+e);if(e>c)throw Error(`'k' passed to topk() must be <= the last dimension (${c}) but got `+e);const o={x:i},u={k:e,sorted:a},[l,h]=n.a.runKernel(r.pd,o,u);return{values:l,indices:h}}})},976:function(t,e,a){"use strict";var n,r,s,i,c;a.d(e,"a",(function(){return o})),n=a(620),r=a(617),s=a(619),i=a(661),c=a(618);const o=Object(c.b)({unique_:function(t,e=0){const a=Object(s.a)(t,"x","unique","string_or_numeric");Object(i.c)(a.rank>0,(()=>"The input tensor must be at least 1D"));const c={x:a},o={axis:e},[u,l]=n.a.runKernel(r.sd,c,o);return{values:u,indices:l}}})},977:function(t,e,a){"use strict";var n,r;a.d(e,"a",(function(){return s})),n=a(978),r=a(619);const s=async function(t){const e=Object(r.a)(t,"condition","whereAsync","bool"),a=await e.data(),s=Object(n.a)(e.shape,a);return t!==e&&e.dispose(),s}}}]);