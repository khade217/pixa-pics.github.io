/*! For license information please see chunk_54.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{1764:function(t,n,e){"use strict";e.d(n,"a",(function(){return s}));class s{constructor(t){this.seed=t}next(){if(void 0!==this.seed)return this.seed++}}s.className="RandomSeed"},659:function(t,n,e){"use strict";function s(t,n){return N.xe(t,n)}function a(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),N.wh(t,e)}function i(t,n){return Object(N.Ei)((()=>{if(2!==t.shape.length)throw new B.e(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return p(a(t,1),[1,n,1])}))}function r(t){const n=[L.a(t.shape)];return N.wh(t,n)}function o(t){if(t.rank<=1)throw new B.e(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],L.a(t.shape,1)];return N.wh(t,n)}function c(t,n,e){return Object(N.Ei)((()=>{switch(t.rank){case 1:return N.Vh(t,n,e);case 2:return N.Wh(t,[n,0],[e,t.shape[1]]);case 3:return N.Xh(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return N.Yh(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return N.Uh(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return N.Uh(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new B.e("sliceAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}))}function u(t,n,e){return Object(N.Ei)((()=>{switch(t.rank){case 1:return N.Vh(t,n,e);case 2:return N.Wh(t,[0,n],[t.shape[0],e]);case 3:return N.Xh(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return N.Yh(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new B.e("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}}))}function h(t,n,e,s){return Object(N.Ei)((()=>{switch(t.rank){case 1:return N.Vh(t,n,e);case 2:switch(s){case 1:return c(t,n,e);case 2:return u(t,n,e);default:throw new B.e("The axis is not within the rank of the tensor "+s)}case 3:switch(s){case 1:return c(t,n,e);case 2:return N.Xh(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return u(t,n,e);default:throw new B.e("The axis is not within the rank of the tensor "+s)}case 4:switch(s){case 1:return c(t,n,e);case 2:return N.Yh(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return N.Yh(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return u(t,n,e);default:throw new B.e("The axis is not within the rank of the tensor "+s)}default:throw new B.e("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}}))}function l(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),N.Ce(t,n)}function d(t,n){switch(t.rank){case 1:return N.De([t,n]);case 2:return N.Ee([t,n],0);case 3:return N.Fe([t,n],0);case 4:return N.Ge([t,n],0);default:throw new B.e("concatAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}function p(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new B.e(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return N.Fi(t,n)}function f(t,n=0,e=1,s,a){return N.ih(t,n,e,s,a)}function m(t,n,e,s){if(t.rank<2||n.rank<2)throw new B.c(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3&&t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new B.c(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = `+n.shape);if(2===t.rank&&2===n.rank){const a=!1,i=!1;return N.Cf.matMul({a:t,b:n,transposeA:a,transposeB:i,bias:s?y(t.rank,s,Object(M.b)()):null,activation:e})}{const a=t.shape.slice(),i=a.pop();t=N.wh(t,[-1,i]);const r=n.shape.slice(),o=r.pop(),c=r.pop(),u=[...r,o],h=Array.from({length:n.rank},((t,e)=>0===e?n.rank-2:e<=n.rank-2?e-1:e));n=N.wh(N.Ji(n,h),[c,-1]);const l=[...a,...u],d=!1,p=!1;return N.wh(N.Cf.matMul({a:t,b:n,transposeA:d,transposeB:p,bias:s?y(t.rank,s,Object(M.b)()):null,activation:e}),l)}}function b(t,n,e){return Object(N.Ei)((()=>(n=Array.isArray(n)?Object(N.vi)(n,"int32"):N.xe(n,"int32"),N.Df(t,n,e))))}function g(t){return N.Gg(t,t)}function y(t,n,e){const s=n.shape;if(1!==n.rank&&n.rank!==t)throw new B.e("Unexpected bias dimensions: "+n.rank+"; expected it to be 1 or "+t);if(5===t){if("channelsFirst"===e)return 1===s.length?N.wh(n,[1,s[0],1,1,1]):N.wh(n,[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===e)return 1===s.length?N.wh(n,[1,1,1,1,s[0]]):N.wh(n,[1].concat(s))}else if(4===t){if("channelsFirst"===e)return 1===s.length?N.wh(n,[1,s[0],1,1]):N.wh(n,[1,s[2],s[0],s[1]]);if("channelsLast"===e)return 1===s.length?N.wh(n,[1,1,1,s[0]]):N.wh(n,[1].concat(s))}else if(3===t){if("channelsFirst"===e)return 1===s.length?N.wh(n,[1,s[0],1]):N.wh(n,[1,s[1],s[0]]);if("channelsLast"===e)return 1===s.length?N.wh(n,[1,1,s[0]]):N.wh(n,[1].concat(s))}else if(t<3)return n;throw new B.e("Unsupported input rank by biasAdd: "+n.rank)}function w(t,n,e){return Object(N.Ei)((()=>(null==e&&(e=Object(M.b)()),Object(v.a)(e),N.Ud(t,y(t.rank,n,e)))))}function x(t,n=1){if(1!==n)throw new B.c(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return N.if(t)}function E(t){return Object(N.Ei)((()=>N.df(t,N.Ud(N.Rd(t),1))))}function k(t,n,e,s){return Object(N.Ei)((()=>N.gf(t,n,e,s)))}function O(t){return Object(N.Ei)((()=>{const n=N.Ud(.5,N.Gg(.2,t));return N.ze(n,0,1)}))}function j(t,n,e=!1){return e?t():n()}var N,v,B,L,M;e.d(n,"c",(function(){return s})),e.d(n,"i",(function(){return a})),e.d(n,"o",(function(){return i})),e.d(n,"j",(function(){return r})),e.d(n,"a",(function(){return o})),e.d(n,"q",(function(){return c})),e.d(n,"p",(function(){return h})),e.d(n,"e",(function(){return l})),e.d(n,"d",(function(){return d})),e.d(n,"t",(function(){return p})),e.d(n,"n",(function(){return f})),e.d(n,"f",(function(){return m})),e.d(n,"k",(function(){return b})),e.d(n,"s",(function(){return g})),e.d(n,"b",(function(){return w})),e.d(n,"h",(function(){return x})),e.d(n,"r",(function(){return E})),e.d(n,"g",(function(){return k})),e.d(n,"l",(function(){return O})),e.d(n,"m",(function(){return j})),N=e(616),v=e(691),B=e(633),L=e(723),M=e(724)},691:function(t,n,e){"use strict";function s(t){Object(d.d)(l.b,"DataFormat",t)}function a(t){Object(d.d)(l.c,"InterpolationFormat",t)}function i(t){Object(d.d)(l.d,"PaddingMode",t)}function r(t){Object(d.d)(l.e,"PoolMode",t)}function o(t,n){f.push(t);try{const t=n();return f.pop(),t}catch(e){throw f.pop(),e}}function c(t){if(!h(t))throw Error("Not a valid tensor name: '"+t+"'");return(0===f.length?"":f.join(m)+m)+t}function u(t){if(!h(t))throw Error("Not a valid tensor name: '"+t+"'");p.has(t)||p.set(t,0);const n=p.get(t);if(p.set(t,p.get(t)+1),n>0){const e=`${t}_${n}`;return p.set(e,1),e}return t}function h(t){return!!t.match(b)}var l,d;e.d(n,"a",(function(){return s})),e.d(n,"b",(function(){return a})),e.d(n,"c",(function(){return i})),e.d(n,"d",(function(){return r})),e.d(n,"g",(function(){return o})),e.d(n,"e",(function(){return c})),e.d(n,"f",(function(){return u})),l=e(1204),d=e(648);const p=new Map,f=[],m="/",b=RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/)},724:function(t,n,e){"use strict";function s(){return null==r&&(r=Object(i.he)().epsilon()),r}function a(){return"channelsLast"}e.d(n,"a",(function(){return s})),e.d(n,"b",(function(){return a}));var i=e(616);let r},725:function(t,n,e){"use strict";function s(t,n){return Object(o.Ei)((()=>o.hi(o.qi(o.Gg(t,t),n,!0))))}function a(t){return Object(u.l)(t)}function i(t,n={}){return Object(u.g)(t,o.Lh.SerializationMap.getMap().classNameMap,n,"constraint")}function r(t){return null==t?null:"string"==typeof t?i({className:t in m?m[t]:t,config:{}}):t instanceof h?t:i(t)}var o,c,u;e.d(n,"a",(function(){return l})),e.d(n,"d",(function(){return d})),e.d(n,"c",(function(){return p})),e.d(n,"b",(function(){return f})),e.d(n,"f",(function(){return a})),e.d(n,"e",(function(){return r})),o=e(616),c=e(724),u=e(648);class h extends o.Lh.Serializable{getConfig(){return{}}}class l extends h{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Object(o.Ei)((()=>{const n=s(t,this.axis),e=o.ze(n,0,this.maxValue);return o.Gg(t,o.df(e,o.Ud(Object(c.a)(),n)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}l.className="MaxNorm",o.Lh.registerClass(l);class d extends h{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Object(o.Ei)((()=>o.df(t,o.Ud(Object(c.a)(),s(t,this.axis)))))}getConfig(){return{axis:this.axis}}}d.className="UnitNorm",o.Lh.registerClass(d);class p extends h{apply(t){return o.th(t)}}p.className="NonNeg",o.Lh.registerClass(p);class f extends h{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Object(o.Ei)((()=>{const n=s(t,this.axis),e=o.Ud(o.Gg(this.rate,o.ze(n,this.minValue,this.maxValue)),o.Gg(1-this.rate,n));return o.Gg(t,o.df(e,o.Ud(Object(c.a)(),n)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}f.className="MinMaxNorm",o.Lh.registerClass(f);const m={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"}},726:function(t,n,e){"use strict";function s(t,n){return null==t&&(t={}),t instanceof h?[t]:Array.isArray(t)&&t[0]instanceof h?t:c.o(t).map((t=>new f(t,n)))}function a(t,n,e,s,a,i,r,o,c){const u=new p,h=[new d,...m.createCallbacks(n)];null!=t&&h.push(...t),h.push(u);const f=new l(h);return f.setParams({epochs:e,initialEpoch:s,samples:a,steps:i,batchSize:r,verbose:n,doValidation:o,metrics:c}),{callbackList:f,history:u}}var i,r,o,c,u;e.d(n,"a",(function(){return h})),e.d(n,"c",(function(){return l})),e.d(n,"e",(function(){return p})),e.d(n,"d",(function(){return f})),e.d(n,"g",(function(){return s})),e.d(n,"b",(function(){return m})),e.d(n,"f",(function(){return a})),i=e(616),r=e(633),o=e(885),c=e(648),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(u||(u={}));class h{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class l{constructor(t,n=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onEpochBegin(t,n)}async onEpochEnd(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onEpochEnd(t,n)}async onBatchBegin(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onBatchBegin(t,n)}async onBatchEnd(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onBatchEnd(t,n)}async onTrainBegin(t){null==t&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class d extends h{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){null==n&&(n={});const e=null==n.size?0:n.size;this.seen+=e;for(const s in n){const t=n[s];if("number"==typeof t)this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+t*e;else{let n;s in this.totals?n=this.totals[s]:this.totals[s]=0;const a=Object(i.Ei)((()=>Object(i.Ud)(this.totals[s],Object(i.Gg)(t,e))));this.totals[s]=a,null!=n&&n.dispose()}}}async onEpochEnd(t,n){if(null!=n)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?n[e]=this.totals[e]/this.seen:Object(i.Ei)((()=>{const t=Object(i.Gg)(Object(i.df)(1,this.seen),this.totals[e]);n[e]=t,this.totals[e].dispose(),Object(i.Xf)(n[e])})))}}class p extends h{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){null==n&&(n={}),this.epoch.push(t);for(const e in n)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(n[e])}async syncData(){const t=[],n=[],e=[];for(const a in this.history){const s=this.history[a];for(let i=0;i<s.length;++i)if("number"!=typeof s[i]){const r=s[i];t.push(r.data()),n.push(a),e.push(i)}}const s=await Promise.all(t);for(let a=0;a<s.length;++a)this.history[n[a]][e[a]].dispose(),this.history[n[a]][e[a]]=s[a][0]}}class f extends h{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||i.Kg,this.yieldEvery=n||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");i.Si.isNumber(this.yieldEvery)&&(this.maybeWait=c.f(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,e){const s=[];null!=this.yield&&(await Object(o.b)(e),s.push(this.yield(t,n,e))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t,null!=this.epochBegin&&(await Object(o.b)(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const e=[];null!=this.epochEnd&&(await Object(o.b)(n),e.push(this.epochEnd(t,n))),"epoch"===this.yieldEvery&&e.push(this.nextFrameFunc()),await Promise.all(e)}async onBatchBegin(t,n){null!=this.batchBegin&&(await Object(o.b)(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const e=[];null!=this.batchEnd&&(await Object(o.b)(n),e.push(this.batchEnd(t,n))),"batch"===this.yieldEvery?e.push(this.nextFrameFunc()):i.Si.isNumber(this.yieldEvery)&&e.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(e)}async onTrainBegin(t){null!=this.trainBegin&&(await Object(o.b)(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await Object(o.b)(t),await this.trainEnd(t))}}class m{constructor(){}static registerCallbackConstructor(t,n){i.Si.assert(t>=0&&Number.isInteger(t),(()=>"Verbosity level is expected to be an integer >= 0, but got "+t)),m.checkForDuplicate(n),null==m.constructors[t]&&(m.constructors[t]=[]),m.constructors[t].push(n)}static checkForDuplicate(t){for(const n in m.constructors)m.constructors[+n].forEach((n=>{if(n===t)throw new r.e("Duplicate callback constructor.")}))}static clear(){m.constructors={}}static createCallbacks(t){const n=[];for(const e in m.constructors){const s=+e;t>=s&&n.push(...m.constructors[s])}return n.map((t=>new t))}}m.constructors={}},816:function(t,n,e){"use strict";function s(){return i++}function a(t=""){return t in r||(r[t]=0),r[t]+=1,t+r[t].toString()}e.d(n,"a",(function(){return s})),e.d(n,"b",(function(){return a}));let i=0;const r={}},887:function(t,n,e){"use strict";function s(t){return t.getClassName()}function a(t,n={}){return Object(c.g)(t,r.Lh.SerializationMap.getMap().classNameMap,n,"activation")}function i(t){if(null==t)return a({className:"linear",config:{}});if("string"==typeof t){const n={};return n.className=t,n.config={},a(n)}return t instanceof u?t:a(t)}var r,o,c;e.d(n,"a",(function(){return x})),e.d(n,"c",(function(){return s})),e.d(n,"b",(function(){return i})),r=e(616),o=e(659),c=e(648);class u extends r.Lh.Serializable{getConfig(){return{}}}class h extends u{apply(t,n=1){return o.h(t,n)}}h.className="elu",r.Lh.registerClass(h);class l extends u{apply(t){return r.Jh(t)}}l.className="selu",r.Lh.registerClass(l);class d extends u{apply(t){return r.th(t)}}d.className="relu",r.Lh.registerClass(d);class p extends u{apply(t){return Object(r.Ei)((()=>r.Bg(6,r.th(t))))}}p.className="relu6",r.Lh.registerClass(p);class f extends u{apply(t){return t}}f.className="linear",r.Lh.registerClass(f);class m extends u{apply(t){return r.Ph(t)}}m.className="sigmoid",r.Lh.registerClass(m);class b extends u{apply(t){return o.l(t)}}b.className="hardSigmoid",r.Lh.registerClass(b);class g extends u{apply(t){return r.bi(t)}}g.className="softplus",r.Lh.registerClass(g);class y extends u{apply(t){return o.r(t)}}y.className="softsign",r.Lh.registerClass(y);class w extends u{apply(t){return r.ti(t)}}w.className="tanh",r.Lh.registerClass(w);class x extends u{apply(t,n=-1){return r.ai(t,n)}}x.className="softmax",r.Lh.registerClass(x);class E extends u{apply(t,n=-1){return r.ig(t,n)}}E.className="logSoftmax",r.Lh.registerClass(E);class k extends u{apply(t,n=1){return Object(r.Ei)((()=>r.Gg(r.Ph(r.Gg(t,n)),t)))}}k.className="swish",r.Lh.registerClass(k);class O extends u{apply(t){return Object(r.Ei)((()=>r.Gg(t,r.ti(r.bi(t)))))}}O.className="mish",r.Lh.registerClass(O)},889:function(t,n,e){"use strict";function s(t,n){return t<n}function a(t,n){return t>n}var i,r,o,c;e.d(n,"a",(function(){return u})),e.d(n,"b",(function(){return h})),e.d(n,"c",(function(){return l})),i=e(726),r=e(831),o=e(633),c=e(885);class u extends i.a{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof r.a))throw Error("model must be a LayersModel, not some other Container");this.model=t}}class h extends u{constructor(t){if(super(),null==t&&(t={}),t.restoreBestWeights)throw new o.c("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=s:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=a:this.monitorFunc=s,this.monitorFunc===s&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===s?1/0:-1/0}async onEpochEnd(t,n){await Object(c.b)(n);const e=this.getMonitorValue(n);null!=e&&(this.monitorFunc(e-this.minDelta,this.best)?(this.best=e,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){null==t&&(t={});const n=t[this.monitor];return null==n&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: `+Object.keys(t)),n}}const l={earlyStopping:function(t){return new h(t)}}}}]);