/*! For license information please see chunk_21.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{1026:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n,attrs:l}=t,{axis:p}=l,h=s.Si.parseAxisParam(p,e[0].shape)[0],f=e.map((t=>t.shape));s.ie.assertParamsConsistent(f,h);let m=s.ie.computeOutShape(e.map((t=>t.shape)),h);if(0===s.Si.sizeFromShape(m))return n.makeTensorInfo(m,e[0].dtype,[]);const b=e.filter((t=>s.Si.sizeFromShape(t.shape)>0));if(1===b.length)return Object(r.a)({inputs:{x:b[0]},backend:n});if("complex64"===b[0].dtype){const t=b.map((t=>Object(d.a)({inputs:{input:t},backend:n}))),e=b.map((t=>Object(c.a)({inputs:{input:t},backend:n}))),s=a({inputs:t,backend:n,attrs:{axis:h}}),i=a({inputs:e,backend:n,attrs:{axis:h}}),r=Object(o.a)({inputs:{real:s,imag:i},backend:n});return t.forEach((t=>n.disposeIntermediateTensorInfo(t))),e.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),r}const k=b.map((t=>{const e=[-1,s.Si.sizeFromShape(t.shape.slice(h))];return Object(u.a)({inputs:{x:t},backend:n,attrs:{shape:e}})})),g=k.map((t=>({vals:n.data.get(t.dataId).values,shape:t.shape})));m=s.ie.computeOutShape(k.map((t=>t.shape)),1);const I=1===k[0].shape[0],v=Object(i.a)(g,m,e[0].dtype,I),S=s.ie.computeOutShape(b.map((t=>t.shape)),h),y=n.makeTensorInfo(S,e[0].dtype,v);return k.forEach((t=>n.disposeIntermediateTensorInfo(t))),y}var s,o,i,r,c,d,u;n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return l})),s=n(616),o=n(727),i=n(990),r=n(709),c=n(823),d=n(780),u=n(666);const l={kernelName:s.H,backendName:"cpu",kernelFunc:a}},1027:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n,attrs:a}=t,{input:i}=e,{dim:r}=a,c=i.shape.length,d=i.shape.slice();let u=r;return r<0&&(s.Si.assert(-(c+1)<=r,(()=>`Axis must be in the interval [${-(c+1)}, ${c}]`)),u=c+r+1),d.splice(u,0,1),Object(o.a)({inputs:{x:i},backend:n,attrs:{shape:d}})}var s,o;n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return i})),s=n(616),o=n(666);const i={kernelName:s.mb,backendName:"cpu",kernelFunc:a}},1214:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),n.d(e,"b",(function(){return i})),a=n(616),s=n(631);const o=Object(s.a)(a.gb,(t=>t>=0?t:Math.exp(t)-1)),i={kernelName:a.gb,backendName:"cpu",kernelFunc:o}},1218:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n,attrs:a}=t,{x:i,filter:r}=e,{strides:c,pad:d,dataFormat:u,dilations:l,dimRoundingMode:p}=a;Object(o.a)([i,r],"conv2d");const h=s.ie.convertConv2DDataFormat(u),f=s.ie.computeConv2DInfo(i.shape,r.shape,c,l,d,p,!1,h),m=f.filterHeight,b=f.filterWidth,k=f.dilationHeight,g=f.dilationWidth,I=f.padInfo.left,v=f.padInfo.top,S="channelsLast"===f.dataFormat,y=new s.Ed(f.outShape,i.dtype),N=s.Si.computeStrides(i.shape),x=s.Si.computeStrides(r.shape),M=N[0],F=S?N[1]:N[2],O=S?N[2]:1,T=S?1:N[1],C=y.strides[0],H=S?y.strides[1]:y.strides[2],W=S?y.strides[2]:1,E=S?1:y.strides[1],j=n.data.get(i.dataId).values,D=n.data.get(r.dataId).values,w=y.values;for(let s=0;s<f.batchSize;++s){const t=s*M,e=s*C;for(let n=0;n<f.outHeight;++n){const a=e+n*H,s=n*f.strideHeight-v;for(let e=0;e<m;++e){const n=s+e*k;if(n<0||n>=f.inHeight)continue;const o=e*x[0],i=t+n*F;for(let t=0;t<f.outWidth;++t){const e=a+t*W,n=t*f.strideWidth-I;for(let t=0;t<b;++t){const a=n+t*g;if(a<0||a>=f.inWidth)continue;const s=i+a*O;let r=o+t*x[1];for(let t=0;t<f.inChannels;++t){const n=j[s+t*T];for(let t=0;t<f.outChannels;++t)w[e+t*E]+=n*D[r+t];r+=f.outChannels}}}}}}return n.makeTensorInfo(y.shape,y.dtype,w)}var s,o;n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return i})),s=n(616),o=n(624);const i={kernelName:s.I,backendName:"cpu",kernelFunc:a}},1219:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n,attrs:a}=t,{x:i,filter:r}=e,{strides:c,pad:d,dilations:u,dimRoundingMode:l}=a;Object(o.a)([i,r],"depthwiseConv2DNative");const p=s.Si.computeStrides(i.shape),h=s.Si.computeStrides(r.shape);let f=u;null==f&&(f=[1,1]),s.Si.assert(s.ie.eitherStridesOrDilationsAreOne(c,f),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${f}'`));const m=s.ie.computeConv2DInfo(i.shape,r.shape,c,f,d,l,!0),{filterHeight:b,filterWidth:k,dilationHeight:g,dilationWidth:I,padInfo:v}=m,S=v.left,y=v.top,N=m.outChannels/m.inChannels,x=new s.Ed(m.outShape,i.dtype),M=n.data.get(i.dataId).values,F=n.data.get(r.dataId).values,O=x.values;for(let s=0;s<m.batchSize;++s){const t=s*p[0],e=s*x.strides[0];for(let n=0;n<m.outHeight;++n){const a=e+n*x.strides[1],s=n*m.strideHeight-y;for(let e=0;e<b;++e){const n=s+e*g;if(n<0||n>=m.inHeight)continue;const o=e*h[0],i=t+n*p[1];for(let t=0;t<m.outWidth;++t){const e=a+t*x.strides[2],n=t*m.strideWidth-S;for(let t=0;t<k;++t){const a=n+t*I;if(a<0||a>=m.inWidth)continue;const s=o+t*h[1],r=i+a*m.inChannels;let c=e,d=s;for(let t=0;t<m.inChannels;++t){const e=M[r+t];for(let t=0;t<N;++t)O[c+t]+=e*F[d+t];c+=N,d+=N}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var s,o;n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return i})),s=n(616),o=n(624);const i={kernelName:s.W,backendName:"cpu",kernelFunc:a}},1835:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return i})),a=n(616),s=n(631);const o=Object(s.a)(a.E,((t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t})),i={kernelName:a.E,backendName:"cpu",kernelFunc:o}},1836:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(616);const s={kernelName:a.G,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array(a.Si.sizeFromShape(e.shape)),o=n.data.get(e.dataId),i=o.complexTensorInfos.real,r=o.complexTensorInfos.imag,c=n.data.get(i.dataId).values,d=n.data.get(r.dataId).values;for(let a=0;a<c.length;a++){const t=c[a],e=d[a];s[a]=Math.hypot(t,e)}return n.makeOutput(s,e.shape,"float32")}}},1837:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.J,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{x:i,dy:r}=e,{strides:c,pad:d,dataFormat:u,dimRoundingMode:l,filterShape:p}=o;Object(s.a)([i,r],"conv2dBackpropFilter");const h=a.ie.convertConv2DDataFormat(u),f=a.ie.computeConv2DInfo(i.shape,p,c,1,d,l,!1,h),{strideHeight:m,strideWidth:b,filterHeight:k,filterWidth:g}=f,I="channelsLast"===f.dataFormat,v=new a.Ed(f.filterShape,"float32"),S=f.padInfo.left,y=f.padInfo.top,N=n.data.get(i.dataId).values,x=n.data.get(r.dataId).values,M=new a.Ed(i.shape,i.dtype,N),F=new a.Ed(r.shape,r.dtype,x);for(let a=0;a<k;++a){const t=Math.max(0,Math.ceil((y-a)/m)),e=Math.min(f.outHeight,(f.inHeight+y-a)/m);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((S-n)/b)),o=Math.min(f.outWidth,(f.inWidth+S-n)/b);for(let i=0;i<f.inChannels;++i)for(let r=0;r<f.outChannels;++r){let c=0;for(let d=0;d<f.batchSize;++d)for(let u=t;u<e;++u){const t=a+u*m-y;for(let e=s;e<o;++e){const a=n+e*b-S;c+=I?M.get(d,t,a,i)*F.get(d,u,e,r):M.get(d,i,t,a)*F.get(d,r,u,e)}}v.set(c,a,n,i,r)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}}},1838:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.K,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{dy:i,filter:r}=e,{inputShape:c,strides:d,pad:u,dataFormat:l,dimRoundingMode:p}=o;Object(s.a)([i,r],"conv2dBackpropInput");const h=a.Si.computeStrides(r.shape),f=a.Si.computeStrides(i.shape);let m=a.ie.convertConv2DDataFormat(l);const b=a.ie.computeConv2DInfo(c,r.shape,d,1,u,p,!1,m),k=new a.Ed(b.inShape,"float32"),g=k.values,I=n.data.get(i.dataId).values,v=n.data.get(r.dataId).values,[S,y,N]=h,{batchSize:x,filterHeight:M,filterWidth:F,inChannels:O,inHeight:T,inWidth:C,outChannels:H,outHeight:W,outWidth:E,strideHeight:j,strideWidth:D}=b;m=b.dataFormat;const w=M-1-b.padInfo.top,A=F-1-b.padInfo.left,z="channelsLast"===m,$=k.strides[0],P=z?k.strides[1]:k.strides[2],R=z?k.strides[2]:1,_=z?1:k.strides[1],U=f[0],V=z?f[1]:f[2],B=z?f[2]:1,G=z?1:f[1];for(let a=0;a<x;++a)for(let t=0;t<O;++t)for(let e=0;e<T;++e){const n=e-w,s=Math.max(0,Math.ceil(n/j)),o=Math.min(W,(M+n)/j);for(let i=0;i<C;++i){const r=i-A,c=Math.max(0,Math.ceil(r/D)),d=Math.min(E,(F+r)/D);let u=0;for(let e=s;e<o;++e){const s=e*j-n;for(let n=c;n<d;++n){const o=U*a+V*e+B*n,i=S*(M-1-s)+y*(F-1-(n*D-r))+N*t;for(let t=0;t<H;++t)u+=I[o+G*t]*v[i+t]}}g[$*a+P*e+R*i+_*t]=u}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}}},1839:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.L,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{x:i,filter:r}=e,{strides:c,pad:d,dilations:u}=o;Object(s.a)([i,r],"conv3d");const l=a.ie.computeConv3DInfo(i.shape,r.shape,c,u,d),{filterDepth:p,filterHeight:h,filterWidth:f,dilationDepth:m,dilationHeight:b,dilationWidth:k,padInfo:g}=l,I=g.front,v=g.left,S=g.top,y=new a.Ed(l.outShape,i.dtype),N=n.data.get(i.dataId).values,x=n.data.get(r.dataId).values,M=y.values,F=a.Si.computeStrides(i.shape),O=a.Si.computeStrides(r.shape);for(let a=0;a<l.batchSize;++a){const t=a*F[0],e=a*y.strides[0];for(let n=0;n<l.outDepth;++n){const a=e+n*y.strides[1],s=n*l.strideDepth-I;for(let e=0;e<p;++e){const n=s+e*m;if(n<0||n>=l.inDepth)continue;const o=e*O[0],i=t+n*F[1];for(let t=0;t<l.outHeight;++t){const e=a+t*y.strides[2],n=t*l.strideHeight-S;for(let t=0;t<h;++t){const a=n+t*b;if(a<0||a>=l.inHeight)continue;const s=o+t*O[1],r=i+a*F[2];for(let t=0;t<l.outWidth;++t){const n=e+t*l.outChannels,a=t*l.strideWidth-v;for(let t=0;t<f;++t){const e=a+t*k;if(e<0||e>=l.inWidth)continue;const o=s+t*O[2],i=r+e*l.inChannels;let c=o;for(let t=0;t<l.inChannels;++t){const e=N[i+t];for(let t=0;t<l.outChannels;++t)M[n+t]+=e*x[c+t];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}}},1840:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.M,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{x:i,dy:r}=e,{strides:c,pad:d,filterShape:u}=o;Object(s.a)([i,r],"conv3dBackpropFilterV2");const l=a.Si.computeStrides(i.shape),p=a.Si.computeStrides(r.shape),h=a.ie.computeConv3DInfo(i.shape,u,c,1,d),f=h.strideDepth,m=h.strideHeight,b=h.strideWidth,k=h.filterDepth,g=h.filterHeight,I=h.filterWidth,v=new a.Ed(h.filterShape,"float32"),S=v.values,[y,N,x,M]=v.strides,F=n.data.get(r.dataId).values,[O,T,C,H]=p,W=n.data.get(i.dataId).values,[E,j,D,w]=l,A=h.padInfo.front,z=h.padInfo.left,$=h.padInfo.top;for(let a=0;a<k;++a){const t=Math.max(0,Math.ceil((A-a)/f)),e=Math.min(h.outDepth,(h.inDepth+A-a)/f),n=a*y;for(let s=0;s<g;++s){const o=Math.max(0,Math.ceil(($-s)/m)),i=Math.min(h.outHeight,(h.inHeight+$-s)/m),r=s*N+n;for(let n=0;n<I;++n){const c=Math.max(0,Math.ceil((z-n)/b)),d=Math.min(h.outWidth,(h.inWidth+z-n)/b),u=n*x+r;for(let r=0;r<h.inChannels;++r){const l=r*M+u;for(let u=0;u<h.outChannels;++u){let p=0;for(let l=0;l<h.batchSize;++l){const h=l*E,k=l*O;for(let l=t;l<e;++l){const t=(a+l*f-A)*j+h,e=l*T+k;for(let a=o;a<i;++a){const o=(s+a*m-$)*D+t,i=a*C+e;for(let t=c;t<d;++t){const e=t*H+i;p+=W[(n+t*b-z)*w+o+r]*F[e+u]}}}}S[l+u]=p}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}}},1841:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.N,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{dy:i,filter:r}=e,{pad:c,strides:d,inputShape:u}=o;Object(s.a)([i],"conv3dBackpropInputV2");const l=a.Si.computeStrides(i.shape),p=a.Si.computeStrides(r.shape),h=a.ie.computeConv3DInfo(u,r.shape,d,1,c),f=new a.Ed(h.inShape,"float32"),m=f.values,[b,k,g,I]=f.strides,v=n.data.get(i.dataId).values,[S,y,N,x]=l,M=n.data.get(r.dataId).values,[F,O,T,C]=p,{batchSize:H,filterDepth:W,filterHeight:E,filterWidth:j,inChannels:D,inDepth:w,inHeight:A,inWidth:z,outChannels:$,outDepth:P,outHeight:R,outWidth:_,strideDepth:U,strideHeight:V,strideWidth:B}=h,G=W-1-h.padInfo.front,L=E-1-h.padInfo.top,Z=j-1-h.padInfo.left;for(let a=0;a<H;++a)for(let t=0;t<D;++t)for(let e=0;e<w;++e){const n=e-G,s=Math.max(0,Math.ceil(n/U)),o=Math.min(P,(W+n)/U);for(let i=0;i<A;++i){const r=i-L,c=Math.max(0,Math.ceil(r/V)),d=Math.min(R,(E+r)/V);for(let u=0;u<z;++u){const l=u-Z,p=Math.max(0,Math.ceil(l/B)),h=Math.min(_,(j+l)/B);let f=0;for(let e=s;e<o;++e){const s=e*U-n;for(let n=c;n<d;++n){const o=n*V-r;for(let i=p;i<h;++i){const r=S*a+y*e+N*n+x*i,c=F*(W-1-s)+O*(E-1-o)+T*(j-1-(i*B-l))+C*t;for(let t=0;t<$;++t)f+=v[r+t]*M[c+t]}}}m[b*a+k*e+g*i+I*u+t]=f}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}}},1842:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return i})),a=n(616),s=n(631);const o=Object(s.a)(a.O,(t=>Math.cos(t))),i={kernelName:a.O,backendName:"cpu",kernelFunc:o}},1843:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return i})),a=n(616),s=n(631);const o=Object(s.a)(a.P,(t=>Math.cosh(t))),i={kernelName:a.P,backendName:"cpu",kernelFunc:o}},1844:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(616);const s={kernelName:a.Q,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{image:o,boxes:i,boxInd:r}=e,{cropSize:c,method:d,extrapolationValue:u}=s,[l,p,h,f]=o.shape,m=i.shape[0],[b,k]=c,g=Object(a.we)([m,b,k,f],"float32"),I=n.data.get(i.dataId).values,v=n.data.get(r.dataId).values,S=n.data.get(o.dataId).values,y=a.Si.computeStrides(o.shape),N=a.Si.computeStrides(g.shape);for(let a=0;a<m;a++){const t=4*a,e=I[t],n=I[t+1],s=I[t+2],o=I[t+3],i=v[a];if(i>=l)continue;const r=b>1?(s-e)*(p-1)/(b-1):0,c=k>1?(o-n)*(h-1)/(k-1):0;for(let l=0;l<b;l++){const t=b>1?e*(p-1)+l*r:.5*(e+s)*(p-1);if(t<0||t>p-1)for(let e=0;e<k;e++)for(let t=0;t<f;t++){const n=t+e*N[2]+l*N[1]+a*N[0];g.values[n]=u}else if("bilinear"===d){const e=Math.floor(t),s=Math.ceil(t),r=t-e;for(let t=0;t<k;t++){const d=k>1?n*(h-1)+t*c:.5*(n+o)*(h-1);if(d<0||d>h-1){for(let e=0;e<f;e++){const n=e+t*N[2]+l*N[1]+a*N[0];g.values[n]=u}continue}const p=Math.floor(d),m=Math.ceil(d),b=d-p;for(let n=0;n<f;n++){let o=n+p*y[2]+e*y[1]+i*y[0];const c=S[o];o=n+m*y[2]+e*y[1]+i*y[0];const d=S[o];o=n+p*y[2]+s*y[1]+i*y[0];const u=S[o];o=n+m*y[2]+s*y[1]+i*y[0];const h=c+(d-c)*b,f=u+(S[o]-u)*b;o=n+t*N[2]+l*N[1]+a*N[0],g.values[o]=h+(f-h)*r}}}else for(let e=0;e<k;++e){const s=k>1?n*(h-1)+e*c:.5*(n+o)*(h-1);if(s<0||s>h-1){for(let t=0;t<f;t++){const n=t+e*N[2]+l*N[1]+a*N[0];g.values[n]=u}continue}const r=Math.round(s),d=Math.round(t);for(let t=0;t<f;t++){const n=t+r*y[2]+d*y[1]+i*y[0],s=t+e*N[2]+l*N[1]+a*N[0];g.values[s]=S[n]}}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}}},1845:function(t,e,n){"use strict";var a,s,o;n.d(e,"a",(function(){return i})),a=n(616),s=n(624),o=n(682);const i={kernelName:a.R,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:c,exclusive:d,reverse:u}=i;Object(s.a)(r,"cumprod");const l=a.ie.getAxesPermutation([c],r.shape.length);let p=r;null!=l&&(p=Object(o.a)({inputs:{x:r},backend:n,attrs:{perm:l}}));const h=a.ie.getInnerMostAxes(1,r.shape.length)[0];if(h!==p.shape.length-1)throw Error(`backend.cumprod in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${h}`);const f=Object(a.Qi)(p.dtype,"int32"),m=a.Si.makeOnesTypedArray(a.Si.sizeFromShape(p.shape),f),b=n.data.get(p.dataId).values,k=p.shape[p.shape.length-1],g=u?(t,e)=>t+k-e-1:(t,e)=>t+e;for(let a=0;a<b.length;a+=k)for(let t=0;t<k;t++){const e=g(a,t);if(0===t)m[e]=d?1:b[e];else{const n=g(a,t-1);m[e]=d?b[n]*m[n]:b[e]*m[n]}}const I=n.makeTensorInfo(p.shape,f,m);if(null!=l){const t=a.ie.getUndoAxesPermutation(l),e=Object(o.a)({inputs:{x:I},backend:n,attrs:{perm:t}});return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(p),e}return I}}},1846:function(t,e,n){"use strict";var a,s,o;n.d(e,"a",(function(){return i})),a=n(616),s=n(624),o=n(682);const i={kernelName:a.S,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:c,exclusive:d,reverse:u}=i;Object(s.a)(r,"cumsum");const l=a.ie.getAxesPermutation([c],r.shape.length);let p=r;null!=l&&(p=Object(o.a)({inputs:{x:r},backend:n,attrs:{perm:l}}));const h=a.ie.getInnerMostAxes(1,r.shape.length)[0];if(h!==p.shape.length-1)throw Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${h}`);const f=Object(a.Qi)(p.dtype,"int32"),m=a.Si.makeZerosTypedArray(a.Si.sizeFromShape(p.shape),f),b=n.data.get(p.dataId).values,k=p.shape[p.shape.length-1],g=u?(t,e)=>t+k-e-1:(t,e)=>t+e;for(let a=0;a<b.length;a+=k)for(let t=0;t<k;t++){const e=g(a,t);if(0===t)m[e]=d?0:b[e];else{const n=g(a,t-1);m[e]=d?b[n]+m[n]:b[e]+m[n]}}const I=n.makeTensorInfo(p.shape,f,m);if(null!=l){const t=a.ie.getUndoAxesPermutation(l),e=Object(o.a)({inputs:{x:I},backend:n,attrs:{perm:t}});return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(p),e}return I}}},1847:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(820);const o={kernelName:a.U,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:a}=t,{x:o,weights:i}=e,{size:r,binaryOutput:c}=a;if(1===o.shape.length){const t=n.data.get(o.dataId).values,e=n.data.get(i.dataId).values,a=Object(s.a)(t,e,i.dtype,i.shape,r);return n.makeTensorInfo([r],i.dtype,a)}if(2===o.shape.length){const t=n.bufferSync(o),e=n.bufferSync(i),a=Object(s.b)(t,e,r,c);return n.makeTensorInfo(a.shape,i.dtype,a.values)}throw Error("Error in denseBincount: input must be at most rank 2, but got rank"+o.shape.length+".")}}},1848:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(616);const s={kernelName:a.V,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:o}=e,{blockSize:i,dataFormat:r}=s;a.Si.assert("NHWC"===r,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+r));const c=o.shape[0],d=o.shape[1],u=o.shape[2],l=o.shape[3],p=d*i,h=u*i,f=l/(i*i),m=n.data.get(o.dataId).values,b=new Float32Array(c*p*h*f);let k=0;for(let a=0;a<c;++a)for(let t=0;t<p;++t){const e=Math.floor(t/i),n=t%i;for(let t=0;t<h;++t){const s=Math.floor(t/i),o=(n*i+t%i)*f;for(let t=0;t<f;++t){const n=t+o+l*(s+u*(e+d*a));b[k++]=m[n]}}}return n.makeTensorInfo([c,p,h,f],o.dtype,b)}}},1849:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.X,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{x:i,dy:r}=e,{strides:c,dilations:d,pad:u,dimRoundingMode:l,filterShape:p}=o;Object(s.a)([i,r],"depthwiseConv2dNativeBackpropFilter");const h=a.ie.computeConv2DInfo(i.shape,p,c,d,u,l,!0),{strideHeight:f,strideWidth:m,filterHeight:b,filterWidth:k}=h,g=new a.Ed(h.filterShape,"float32"),I=h.padInfo.left,v=h.padInfo.top,S=h.outChannels/h.inChannels,y=n.data.get(i.dataId).values,N=new a.Ed(i.shape,i.dtype,y),x=n.data.get(r.dataId).values,M=new a.Ed(r.shape,r.dtype,x);for(let a=0;a<b;++a){const t=Math.max(0,Math.ceil((v-a)/f)),e=Math.min(h.outHeight,(h.inHeight+v-a)/f);for(let n=0;n<k;++n){const s=Math.max(0,Math.ceil((I-n)/m)),o=Math.min(h.outWidth,(h.inWidth+I-n)/m);for(let i=0;i<h.outChannels;++i){const r=Math.trunc(i/S),c=i%S;let d=0;for(let u=0;u<h.batchSize;++u)for(let c=t;c<e;++c){const t=a+c*f-v;for(let e=s;e<o;++e){const a=n+e*m-I;d+=N.get(u,t,a,r)*M.get(u,c,e,i)}}g.set(d,a,n,r,c)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}}},1850:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.Y,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{dy:i,filter:r}=e,{strides:c,dilations:d,pad:u,dimRoundingMode:l,inputShape:p}=o;Object(s.a)([i,r],"depthwiseConv2DNativeBackpropInput");const h=a.Si.computeStrides(i.shape),f=a.Si.computeStrides(r.shape),m=a.ie.computeConv2DInfo(p,r.shape,c,d,u,l,!0),b=new a.Ed(m.inShape,"float32"),k=b.values,[g,I,v]=b.strides,S=n.data.get(i.dataId).values,[y,N,x]=h,M=n.data.get(r.dataId).values,[F,O,T]=f,{batchSize:C,filterHeight:H,filterWidth:W,inChannels:E,inHeight:j,inWidth:D,outChannels:w,outHeight:A,outWidth:z,strideHeight:$,strideWidth:P}=m,R=H-1-m.padInfo.top,_=W-1-m.padInfo.left,U=w/E;for(let a=0;a<C;++a)for(let t=0;t<E;++t)for(let e=0;e<j;++e){const n=e-R,s=Math.max(0,Math.ceil(n/$)),o=Math.min(A,(H+n)/$);for(let i=0;i<D;++i){const r=i-_,c=Math.max(0,Math.ceil(r/P)),d=Math.min(z,(W+r)/P);let u=0;for(let e=s;e<o;++e){const s=e*$-n;for(let n=c;n<d;++n){const o=y*a+N*e+x*n,i=F*(H-1-s)+O*(W-1-(n*P-r))+T*t;for(let e=0;e<U;++e)u+=S[o+(t*U+e)]*M[i+e]}}k[g*a+I*e+v*i+t]=u}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}}},1851:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(616);const s={kernelName:a.Z,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,o=a.Si.sizeFromShape(s.shape),i=n.data.get(s.dataId).values,r=Object(a.we)([o,o],s.dtype),c=r.values;for(let a=0;a<i.length;a++)c[a*o+a]=i[a];const d=[...s.shape,...s.shape];return n.makeTensorInfo(d,r.dtype,r.values)}}},1852:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(616);const s={kernelName:a.ab,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:o}=t,{strides:i,pad:r,dilations:c}=n,d=e,u=d.data.get(s.dataId).values,l=s.shape.length,p=d.data.get(o.dataId).values,h=o.shape.length,{batchSize:f,inHeight:m,inWidth:b,inChannels:k,outHeight:g,outWidth:I,padInfo:v,strideHeight:S,strideWidth:y,filterHeight:N,filterWidth:x,dilationHeight:M,dilationWidth:F,outShape:O}=a.ie.computeDilation2DInfo(s.shape,o.shape,i,r,"NHWC",c),T=a.Si.sizeFromShape(O),C=O.length,H=a.Si.getArrayFromDType(s.dtype,T);for(let W=0;W<f;++W)for(let t=0;t<g;++t){const e=t*S-v.top;for(let n=0;n<I;++n){const i=n*y-v.left;for(let r=0;r<k;++r){let c=Number.MIN_SAFE_INTEGER;for(let t=0;t<N;++t){const n=e+t*M;if(n>=0&&n<m)for(let e=0;e<x;++e){const d=i+e*F;if(d>=0&&d<b){const i=a.Si.locToIndex([W,n,d,r],l,a.Si.computeStrides(s.shape)),f=a.Si.locToIndex([t,e,r],h,a.Si.computeStrides(o.shape)),m=u[i]+p[f];m>c&&(c=m)}}}H[a.Si.locToIndex([W,t,n,r],C,a.Si.computeStrides(O))]=c}}}return{dataId:d.write(a.Si.toTypedArray(H,s.dtype),O,s.dtype),shape:O,dtype:s.dtype}}}},1853:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(616);const s={kernelName:a.bb,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:o,dy:i}=t,{strides:r,pad:c,dilations:d}=n,u=e,l=a.Si.toNestedArray(s.shape,u.data.get(s.dataId).values),p=a.Si.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:b,outHeight:k,outWidth:g,padInfo:I,strideHeight:v,strideWidth:S,filterHeight:y,filterWidth:N,dilationHeight:x,dilationWidth:M,outShape:F}=a.ie.computeDilation2DInfo(s.shape,o.shape,r,c,"NHWC",d);a.Si.assert(i.rank===F.length,(()=>`Error in ${a.bb}, dy must have the same rank as output ${F.length}, but got `+i.rank));const O=a.Si.toNestedArray(F,u.data.get(i.dataId).values),T=a.Si.makeZerosNestedTypedArray(o.shape,o.dtype);for(let a=0;a<h;++a)for(let t=0;t<k;++t){const e=t*v-I.top;for(let n=0;n<g;++n){const s=n*S-I.left;for(let o=0;o<b;++o){let i=Number.MIN_SAFE_INTEGER,r=0,c=0;for(let t=0;t<y;++t){const n=e+t*x;if(n>=0&&n<f)for(let e=0;e<N;++e){const d=s+e*M;if(d>=0&&d<m){const s=l[a][n][d][o]+p[t][e][o];s>i&&(i=s,r=t,c=e)}}}T[r][c][o]+=O[a][t][n][o]}}}return{dataId:u.write(a.Si.toTypedArray(T,s.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}}},1854:function(t,e,n){"use strict";n.d(e,"a",(function(){return s}));var a=n(616);const s={kernelName:a.cb,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:o,dy:i}=t,{strides:r,pad:c,dilations:d}=n,u=e,l=a.Si.toNestedArray(s.shape,u.data.get(s.dataId).values),p=a.Si.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:b,outHeight:k,outWidth:g,padInfo:I,strideHeight:v,strideWidth:S,filterHeight:y,filterWidth:N,dilationHeight:x,dilationWidth:M,outShape:F}=a.ie.computeDilation2DInfo(s.shape,o.shape,r,c,"NHWC",d);a.Si.assert(i.rank===F.length,(()=>`Error in ${a.cb}, dy must have the same rank as output ${F.length}, but got `+i.rank));const O=a.Si.toNestedArray(F,u.data.get(i.dataId).values),T=a.Si.makeZerosNestedTypedArray(s.shape,s.dtype);for(let a=0;a<h;++a)for(let t=0;t<k;++t){const e=t*v-I.top;for(let n=0;n<g;++n){const s=n*S-I.left;for(let o=0;o<b;++o){let i=Number.MIN_SAFE_INTEGER,r=e<0?0:e,c=s<0?0:s;for(let t=0;t<y;++t){const n=e+t*x;if(n>=0&&n<f)for(let e=0;e<N;++e){const d=s+e*M;if(d>=0&&d<m){const s=l[a][n][d][o]+p[t][e][o];s>i&&(i=s,r=n,c=d)}}}T[a][r][c][o]+=O[a][t][n][o]}}}return{dataId:u.write(a.Si.toTypedArray(T,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}}},1855:function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));const a={kernelName:n(616).db,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:a}=t,{image:s}=e,{canvas:o,options:i}=a,{contextOptions:r,imageOptions:c}=i||{},d=(null==c?void 0:c.alpha)||1,u=(null==r?void 0:r.contextType)||"2d";if("2d"!==u)throw Error(`Context type ${r.contextType} is not supported by the CPU backend.`);const l=o.getContext(u,(null==r?void 0:r.contextAttributes)||{});if(null==l)throw Error(`Could not get the context with ${u} type.`);const[p,h]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,b="float32"===s.dtype?255:1,k=new Uint8ClampedArray(h*p*4);for(let I=0;I<p*h;++I){const t=[0,0,0,255*d];for(let n=0;n<f;n++){const e=m[I*f+n];if("float32"===s.dtype){if(e<0||e>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${e}.`)}else if("int32"===s.dtype&&(e<0||e>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${e}.`);1===f?(t[0]=e*b,t[1]=e*b,t[2]=e*b):t[n]=e*b}const e=4*I;k[e+0]=Math.round(t[0]),k[e+1]=Math.round(t[1]),k[e+2]=Math.round(t[2]),k[e+3]=Math.round(t[3])}o.width=h,o.height=p;const g=new ImageData(k,h,p);return l.putImageData(g,0,0),s}}},1856:function(t,e,n){"use strict";var a,s,o,i,r;n.d(e,"a",(function(){return c})),a=n(616),s=n(752),o=n(666),i=n(824),r=n(682);const c={kernelName:a.fb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:c}=t,{equation:d}=c,u=e,{allDims:l,summedDims:p,idDims:h}=a.ie.decodeEinsumEquation(d,u.length);a.ie.checkEinsumDimSizes(l.length,h,u);const{path:f,steps:m}=a.ie.getEinsumComputePath(p,h),b=m.length;let k=null,g=l.length;const I=[];for(let v=0;v<b;++v){for(const t of m[v]){const{permutationIndices:e,expandDims:i}=a.ie.getEinsumPermutation(g,h[t]);let c;a.ie.isIdentityPermutation(e)?c=u[t]:(c=Object(r.a)({inputs:{x:u[t]},backend:n,attrs:{perm:e}}),I.push(c));const d=c.shape.slice();for(let t=0;t<i.length;++t)d.splice(i[t],0,1);a.Si.arraysEqual(c.shape,d)||(c=Object(o.a)({inputs:{x:c},backend:n,attrs:{shape:d}}),I.push(c)),null===k?k=c:(k=Object(s.a)({inputs:{a:c,b:k},backend:n}),I.push(k))}v<b-1&&(f[v]>=0&&(k=Object(i.a)({inputs:{x:k},backend:n,attrs:{axis:f[v]-(l.length-g),keepDims:!1}}),I.push(k)),g--)}for(const a of I)a!==k&&n.disposeIntermediateTensorInfo(a);return k}}},1857:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return o})),a=n(616),s=n(624);const o={kernelName:a.hb,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:o,y:i}=e;Object(s.a)([o,i],"eluGrad");const r=new Float32Array(a.Si.sizeFromShape(i.shape)),c=n.data.get(i.dataId).values,d=n.data.get(o.dataId).values;for(let a=0;a<c.length;++a){const t=c[a];r[a]=t>=0?d[a]:d[a]*(t+1)}return n.makeTensorInfo(i.shape,"float32",r)}}},1858:function(t,e,n){"use strict";var a,s;n.d(e,"a",(function(){return p})),a=n(616),s=n(631);const o=a.ie.ERF_P,i=a.ie.ERF_A1,r=a.ie.ERF_A2,c=a.ie.ERF_A3,d=a.ie.ERF_A4,u=a.ie.ERF_A5,l=Object(s.a)(a.kb,(t=>{const e=Math.sign(t),n=Math.abs(t),a=1/(1+o*n);return e*(1-((((u*a+d)*a+c)*a+r)*a+i)*a*Math.exp(-n*n))})),p={kernelName:a.kb,backendName:"cpu",kernelFunc:l}},727:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n}=t,{real:a,imag:s}=e,o=n.data.get(a.dataId).values,i=n.data.get(s.dataId).values,r=n.makeTensorInfo(a.shape,"complex64");return n.data.get(r.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",i)},r}n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return s}));const s={kernelName:n(616).F,backendName:"cpu",kernelFunc:a}},751:function(t,e,n){"use strict";function a(t,e,n,a){if("int32"===a)return[e,"int32",Int32Array.from(t)];if("bool"===a){const a=o.Si.toTypedArray([0],n),[s,r]=Object(i.a)(((t,e)=>t!==e?1:0))(e,[],t,a,"bool");return[r,"bool",s]}throw Error(`Error in Cast: failed to cast ${n} to ${a}`)}function s(t){const{inputs:e,backend:n,attrs:i}=t,{x:l}=e,{dtype:p}=i;if("complex64"===p){if("complex64"===l.dtype)return Object(d.a)({inputs:{x:l},backend:n});const t=Object(r.a)(n,l.shape,l.dtype),e=s({inputs:{x:l},backend:n,attrs:{dtype:"float32"}}),a=Object(c.a)({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),a}if("complex64"===l.dtype){const t=Object(u.a)({inputs:{input:l},backend:n}),e=s({inputs:{x:t},backend:n,attrs:{dtype:p}});return n.disposeIntermediateTensorInfo(t),e}if(!o.Si.hasEncodingLoss(l.dtype,p)){const t=Object(d.a)({inputs:{x:l},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:p}}const h=n.data.get(l.dataId).values,[f,m,b]=a(h,l.shape,l.dtype,p);return n.makeTensorInfo(f,m,b)}var o,i,r,c,d,u;n.d(e,"c",(function(){return a})),n.d(e,"a",(function(){return s})),n.d(e,"b",(function(){return l})),o=n(616),i=n(655),r=n(1211),c=n(727),d=n(709),u=n(780);const l={kernelName:o.C,backendName:"cpu",kernelFunc:s}},890:function(t,e,n){"use strict";var a,s,o;n.d(e,"c",(function(){return i})),n.d(e,"a",(function(){return r})),n.d(e,"b",(function(){return c})),a=n(616),s=n(655),o=n(663);const i=Object(s.a)(((t,e)=>t===e?1:0)),r=Object(o.a)(a.jb,i,null,"bool"),c={kernelName:a.jb,backendName:"cpu",kernelFunc:r}},891:function(t,e,n){"use strict";var a,s,o;n.d(e,"c",(function(){return i})),n.d(e,"a",(function(){return r})),n.d(e,"b",(function(){return c})),a=n(616),s=n(697),o=n(631);const i=Object(s.a)((t=>Math.exp(t))),r=Object(o.b)(a.lb,i,"float32"),c={kernelName:a.lb,backendName:"cpu",kernelFunc:r}},989:function(t,e,n){"use strict";var a,s,o;n.d(e,"b",(function(){return i})),n.d(e,"a",(function(){return c})),a=n(616),s=n(697),o=n(631);const i=Object(s.a)((t=>Math.ceil(t))),r=Object(o.b)(a.D,i),c={kernelName:a.D,backendName:"cpu",kernelFunc:r}},990:function(t,e,n){"use strict";function a(t,e,n,a){const o=s.Si.getArrayFromDType(n,s.Si.sizeFromShape(e));if(a&&"string"!==n){let e=0;t.forEach((t=>{const n=s.Si.sizeFromShape(t.shape);o.set(t.vals,e),e+=n}))}else{let a=0;t.forEach((t=>{const i="string"===n?s.ie.fromUint8ToStringArray(t.vals):t.vals;let r=0;for(let n=0;n<t.shape[0];++n){const s=n*e[1]+a;for(let e=0;e<t.shape[1];++e)o[s+e]=i[r++]}a+=t.shape[1]}))}return o}n.d(e,"a",(function(){return a}));var s=n(616)},991:function(t,e,n){"use strict";var a,s,o;n.d(e,"b",(function(){return i})),n.d(e,"a",(function(){return c})),a=n(616),s=n(697),o=n(631);const i=Object(s.a)((t=>Math.expm1(t))),r=Object(o.b)(a.nb,i),c={kernelName:a.nb,backendName:"cpu",kernelFunc:r}}}]);