/*! For license information please see chunk_64.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{1052:function(t,e,s){"use strict";function r(t,e=null){return new class extends g{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function i(t){return r((async()=>Object(p.f)(t)),t.length)}function n(t){if(!Object(w.e)(t))throw Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let s=0;s<t.length;s++)e=null==e?t[s].size:Math.min(e,t[s].size);else if(t instanceof Object)for(const s in t)e=null==e?t[s].size:Math.min(e,t[s].size);return r((async()=>{const e=await Object(w.c)(t,(t=>{if(t instanceof g)return{value:t.iterator(),recurse:!1};if(Object(w.e)(t))return{value:null,recurse:!0};throw Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}));return Object(p.g)(e,p.c.SHORTEST)}),e)}function a(t){if(null===t)return null;const e=t[0];return Object(w.a)(e)?{value:function(t){if(0===t.length)throw Error("Can't make a batch of zero elements.");return t[0]instanceof m.Dd?m.li(t):m.ui(t)}(t),recurse:!1}:{value:null,recurse:!0}}function o(t){return"string"==typeof t&&"file://"===t.slice(0,7)}function u(t,e={}){return new R(new I(t),e)}function h(t){const e=Object(p.e)(t);return r((async()=>e))}function l(t){return r((async()=>{const e=await t();return Object(p.e)((()=>e.next()))}))}async function c(t,e){return O.create(t,e)}async function f(t){return A.create(t)}var m,d,p,w,y;s.r(e),m=s(616),d=s(874),p=s(784),w=s(985);class g{constructor(){this.size=null}batch(t,e=!0){const s=this;let i;return m.Si.assert(t>0,(()=>"batchSize needs to be positive, but it is\n      "+t)),i=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),r((async()=>(await s.iterator()).columnMajorBatch(t,e,a)),i)}concatenate(t){const e=this;let s;return s=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,r((async()=>(await e.iterator()).concatenate(await t.iterator())),s)}filter(t){const e=this;let s;return s=this.size===1/0?1/0:null,r((async()=>(await e.iterator()).filter((e=>m.Ei((()=>t(e)))))),s)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return r((async()=>(await e.iterator()).map((e=>m.Ei((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return r((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return r((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let s;return s=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,r((async()=>{const s=Object(p.e)((async()=>({value:await e.iterator(),done:!1})));return Object(p.d)(s.take(t))}),s)}skip(t){const e=this;let s;return s=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,r((async()=>(await e.iterator()).skip(t)),s)}shuffle(t,e,s=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const i=this,n=d.alea(e||m.Si.now().toString());return r((async()=>{let e=n.int32();return s&&(e+=n.int32()),(await i.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let s;return s=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,r((async()=>(await e.iterator()).take(t)),s)}async toArray(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}g.MAX_BUFFER_SIZE=1e4;class b extends g{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((t=>(t.endsWith("\r")&&(t=t.slice(0,-1)),t)))}}const v='"',x=Symbol("out"),C=Symbol("field"),E=Symbol("quote"),z=Symbol("quoteafterquote"),S=Symbol("quoteinquote");class R extends g{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&m.Si.assert(t.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=t);const e=this.fullColumnNames.reduce(((t,e)=>(t[e]=t[e]+1||1,t)),{}),s=Object.keys(e).filter((t=>e[t]>1));if(m.Si.assert(0===s.length,(()=>"Duplicate column names found: "+s.toString())),this.columnConfigs)for(const r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await this.base.iterator(),e=await t.next();if(e.done)throw Error("No data was found for CSV parsing.");const s=e.value;return this.parseRow(s,!1)}return null}constructor(t,e){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new b(t),e||(e={}),this.hasHeader=!1!==e.hasHeader,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(m.Si.assert(null==e.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map((t=>this.makeDataElement(t)))}makeDataElement(t){const e=this.parseRow(t),s={},r={};for(let i=0;i<this.fullColumnNames.length;i++){const n=this.fullColumnNames[i],a=this.columnConfigs?this.columnConfigs[n]:null;if(!this.configuredColumnsOnly||a){const o=e[i];let u=null;if(""===o)if(a&&void 0!==a.default)u=a.default;else{if(a&&(a.required||a.isLabel))throw Error(`Required column ${n} is empty in this line: ${t}`);u=void 0}else{const t=Number(o);if(isNaN(t))u=a&&"bool"===a.dtype?this.getBoolean(o):o;else if(a&&a.dtype)switch(a.dtype){case"float32":default:u=t;break;case"int32":u=Math.floor(t);break;case"bool":u=this.getBoolean(o)}else u=t}a&&a.isLabel?r[n]=u:s[n]=u}}return 0===Object.keys(r).length?s:{xs:s,ys:r}}getBoolean(t){return"1"===t||"true"===t.toLowerCase()?1:0}parseRow(t,e=!0){const s=[];let r=0;const i=t.length;let n=x;for(let a=0;a<i;a++)switch(n){case x:switch(t.charAt(a)){case v:r=a+1,n=E;break;case this.delimiter:if(r=a+1," "===this.delimiter&&this.delimWhitespace)break;s.push(""),n=x;break;default:n=C,r=a}break;case C:t.charAt(a)===this.delimiter&&(s.push(t.substring(r,a)),n=x,r=a+1);break;case E:t.charAt(a)===v&&(n=z);break;case z:switch(t.charAt(a)){case this.delimiter:s.push(t.substring(r,a-1)),n=x,r=a+1;break;case v:n=E;break;default:n=S}break;case S:t.charAt(a)===v&&(n=E)}if(n===z?s.push(t.substring(r,i-1)):s.push(t.substring(r)),e&&s.length!==this.fullColumnNames.length)throw Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class A extends p.a{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;const e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got "+this.fftSize);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=!1!==t.includeSpectrogram,this.includeWaveform=!0===t.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!Object(m.of)().get("IS_BROWSER"))throw Error("microphone API is only supported in browser environment.");const e=new A(t);return await e.start(),e}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(s){throw Error("Error thrown while initializing video stream: "+s.message)}if(!this.stream)throw Error("Could not obtain audio from microphone.");const t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: `+this.audioContext.sampleRate)}else this.sampleRateHz=this.audioContext.sampleRate;const e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,e;const s=await this.getAudioData();if(this.includeSpectrogram){const e=this.flattenQueue(s.freqDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const t=this.flattenQueue(s.timeDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const t=[],e=[];let s=0;return new Promise((r=>{const i=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(i),r({freqDataQueue:t,timeDataQueue:e}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){const e=t[0].length,s=new Float32Array(t.length*e);return t.forEach(((t,r)=>s.set(t,r*e))),s}getTensorFromAudioDataArray(t,e){const s=new Float32Array(m.Si.sizeFromShape(e));return s.set(t,s.length-t.length),Object(m.ui)(s,e)}}class O extends p.a{constructor(t,e){if(super(),this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Object(m.vi)([0],"int32"),this.webcamConfig.centerCrop){const t=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,e=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,s=(1-t)/2,r=(1-e)/2,i=s+t,n=e+r;this.cropBox=Object(m.wi)([r,s,n,i],[1,4])}else this.cropBox=Object(m.wi)([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,e={}){if(!Object(m.of)().get("IS_BROWSER"))throw Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}const s=new O(t,e);return await s.start(),s}async start(){this.webcamConfig.facingMode&&m.Si.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message="Error thrown while initializing video stream: "+t.message,t}if(!this.stream)throw Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=m.ve.fromPixels(this.webcamVideoElement)}catch(e){throw Error("Error thrown converting video to pixels: "+JSON.stringify(e))}if(!this.resize)return{value:t,done:!1};try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(e){throw Error("Error thrown cropping the video: "+e.message)}finally{t.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(t){return Object(m.Ei)((()=>{const e=Object(m.tf)(Object(m.xe)(t,"float32"),0);let s;s=m.Qf.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return Object(m.wh)(s,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((t=>t.stop()));try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw Error("Can not convert infinite video stream to array.")}}class T{}y=s(1811);class F extends y.a{constructor(t,e={}){super(),this.file=t,this.options=e,m.Si.assert(t instanceof Uint8Array||!!Object(m.of)().get("IS_BROWSER")&&(t instanceof File||t instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1048576}summary(){return"FileChunks "+this.file}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const t=new Promise(((t,e)=>{const s=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,s)));else{const r=new FileReader;r.onload=s=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return e(new TypeError("FileReader returned unknown type."));t(i)},r.onabort=t=>e(Error("Aborted")),r.onerror=t=>e(Error(t.type));const i=this.file.slice(this.offset,s);r.readAsArrayBuffer(i)}this.offset=s}));return{value:await t,done:!1}}}class N extends T{constructor(t,e={}){super(),this.input=t,this.options=e}async iterator(){if(o(this.input)&&Object(m.of)().get("IS_NODE")){const t=s(1814);this.input=t.readFileSync(this.input.slice(7))}return new F(this.input,this.options)}}class I extends T{constructor(t,e={}){super(),this.url=t,this.fileOptions=e}async iterator(){return o(this.url)?new N(this.url,this.fileOptions).iterator():async function(t,e={},s){let r,i;var n;"string"==typeof t?r=t:(r=t.url,i={method:(n=t).method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});const a=await(s||m.Si.fetch)(r,i);if(a.ok){const t=new Uint8Array(await a.arrayBuffer());return new F(t,e)}throw Error(a.statusText)}(this.url,this.fileOptions)}}s.d(e,"array",(function(){return i})),s.d(e,"Dataset",(function(){return g})),s.d(e,"zip",(function(){return n})),s.d(e,"CSVDataset",(function(){return R})),s.d(e,"TextLineDataset",(function(){return b})),s.d(e,"csv",(function(){return u})),s.d(e,"func",(function(){return h})),s.d(e,"generator",(function(){return l})),s.d(e,"microphone",(function(){return f})),s.d(e,"webcam",(function(){return c})),s.d(e,"FileDataSource",(function(){return N})),s.d(e,"URLDataSource",(function(){return I})),s.d(e,"version_data",(function(){return"4.17.0"}))},1811:function(t,e,s){"use strict";!function(t){var r,i,n;s.d(e,"a",(function(){return a})),r=s(616),i=s(784),n=s(1812);class a extends i.a{decodeUTF8(){return new o(this)}}class o extends n.a{constructor(t){super(),this.upstream=t,this.impl=new u(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class u extends i.b{constructor(t){if(super(),this.upstream=t,Object(r.of)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=s(1813);this.decoder=new t("utf8")}}summary(){return this.upstream.summary()+" -> Utf8"}async pump(){const e=await this.upstream.next();let s,i;return!e.done&&(s=e.value,i=Object(r.of)().get("IS_BROWSER")?this.decoder.decode(s,{stream:!0}):this.decoder.write(t.from(s.buffer)),this.outputQueue.push(i),!0)}}}(s(66).Buffer)},1812:function(t,e,s){"use strict";s.d(e,"a",(function(){return i}));var r=s(784);class i extends r.a{split(t){return new n(this,t)}}class n extends i{constructor(t,e){super(),this.upstream=t,this.impl=new a(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class a extends r.b{constructor(t,e){super(),this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const t=await this.upstream.next();if(t.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(const s of e.slice(0,-1))this.outputQueue.push(s);return this.carryover=e[e.length-1],!0}}},784:function(t,e,s){"use strict";function r(t){return t instanceof h.Dd?{value:t.clone(),recurse:!1}:Object(c.e)(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}function i(t){return new p(t)}function n(t){return new w(t)}function a(t,e){return new A(t,e)}function o(t,e=u.FAIL){return new O(t,e)}var u,h=s(616),l=s(874),c=s(985);class f{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),s=this.get(e);return this.set(e,this.pop()),s}}class m extends f{constructor(){super(m.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=Array(t),s=this.length();for(let r=0;r<s;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}m.INITIAL_CAPACITY=32,s.d(e,"f",(function(){return i})),s.d(e,"e",(function(){return n})),s.d(e,"d",(function(){return a})),s.d(e,"g",(function(){return o})),s.d(e,"a",(function(){return d})),s.d(e,"b",(function(){return S})),s.d(e,"c",(function(){return u}));class d{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let s=await t.next();for(;!s.done;)e.push(s.value),s=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),s=t(e.value);for(;!e.done&&s;)e=await this.next(),s=t(e.value)}handleErrors(t){return new E(this,t)}filter(t){return new x(this,t)}map(t){return new C(this,t)}mapAsync(t){return new z(this,t)}serialMapAsync(t){return new z(this,t).serial()}flatmap(t){return new R(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t,e=!0){return new v(this,t,e)}columnMajorBatch(t,e=!0,s=c.f){return this.rowMajorBatch(t,e).map((t=>Object(c.d)(t,s)))}concatenate(t,e){return new A(i([this,t]),e)}take(t){return t<0||null==t?this:new b(this,t)}skip(t){return t<0||null==t?this:new g(this,t)}prefetch(t){return new T(this,t)}shuffle(t,e){return new F(this,t,e)}serial(){return new y(this)}}class p extends d{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:(e=t,Object(c.b)(e,r)),done:!1};var e}}class w extends d{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message="Error thrown while iterating through a dataset: "+t.message,t}}}class y extends d{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Serial"}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class g extends d{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Skip"}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;h.bf(t.value)}return this.upstream.next()}}class b extends d{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return this.upstream.summary()+" -> Take"}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class v extends d{constructor(t,e,s=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> RowMajorBatch"}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class x extends d{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Filter"}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;h.bf(t.value)}}}class C extends d{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> Map"}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=h.Ci.getTensorsInContainer(t.value),s=this.transform(t.value),r=h.Ci.getTensorsInContainer(s);for(const i of e)h.Ci.isTensorInList(i,r)||i.dispose();return{value:s,done:!1}}}class E extends d{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> handleErrors"}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class z extends d{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> AsyncMap"}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=h.Ci.getTensorsInContainer(t.value),s=await this.transform(t.value),r=h.Ci.getTensorsInContainer(s);for(const i of e)h.Ci.isTensorInList(i,r)||i.dispose();return{value:s,done:!1}}}class S extends d{constructor(){super(),this.outputQueue=new m,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class R extends S{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> Flatmap"}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=h.Ci.getTensorsInContainer(t.value),s=this.transform(t.value),r=h.Ci.getTensorsInContainer(s);this.outputQueue.pushAll(s);for(const i of e)h.Ci.isTensorInList(i,r)||i.dispose();return!0}}class A extends d{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(u||(u={}));class O extends d{constructor(t,e=u.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,s=0;const r=await Object(c.c)(this.iterators,(function(t){return t instanceof d?{value:t.next().then((t=>(e++,t.done&&s++,t.value))),recurse:!1}:{value:null,recurse:!0}}));if(e===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case u.FAIL:throw Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case u.SHORTEST:return{value:null,done:!0};case u.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class T extends d{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new f(e)}summary(){return this.upstream.summary()+" -> Prefetch"}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class F extends T{constructor(t,e,s){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=l.alea(s||h.Si.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}},985:function(t,e,s){"use strict";function r(t,e){return i(t,e)}function i(t,e,s=new Map,r=new Set){if(null==t)return null;if("function"==typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw Error("Circular references are not supported.");if(s.has(t))return s.get(t);const n=e(t);if(n.recurse&&null!==n.value)throw Error("A deep map function may not return both a value and recurse=true.");if(n.recurse){if(h(t)){const n=Array.isArray(t)?[]:{};r.add(t);for(const a in t){const o=i(t[a],e,s,r);n[a]=o}return r.delete(t),t.__proto__&&(n.__proto__=t.__proto__),n}throw Error("Can't recurse into non-iterable type: "+t)}return s.set(t,n.value),n.value}function n(t,e=o){return a(t,e)}function a(t,e,s=new Set){const r=t[0];if(s.has(r))throw Error("Circular references are not supported.");const i=e(t);if(i.recurse&&null!==i.value)throw Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(h(r)){const i=Array.isArray(r)?[]:{};s.add(r);for(const n in r){const r=a(t.map((t=>t[n])),e,s);i[n]=r}return s.delete(r),i}throw Error("Can't recurse into non-iterable type: "+r)}return i.value}function o(t){return null===t?null:h(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function u(t,e){const s=new Map;i(t,e,s);for(const r of Array.from(s.keys())){const t=s.get(r);if(c.Si.isPromise(t)){const e=await t;s.set(r,e)}}return i(t,e,s)}function h(t){let e=!1;if(c.of().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=s(1810);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof c.Dd)&&!(t instanceof Promise)&&!e)}function l(t){return null==t||null===(e=t)||"object"!=typeof e&&"function"!=typeof e||Array.isArray(t)||"object"==typeof t&&t instanceof c.Dd||c.Si.isTypedArray(t);var e}s.d(e,"b",(function(){return r})),s.d(e,"d",(function(){return n})),s.d(e,"f",(function(){return o})),s.d(e,"c",(function(){return u})),s.d(e,"e",(function(){return h})),s.d(e,"a",(function(){return l}));var c=s(616)}}]);