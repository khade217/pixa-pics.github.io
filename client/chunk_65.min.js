/*! For license information please see chunk_65.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{1752:function(t,e,i){"use strict";var s,n,r,a,l,h,o,u,c;i.d(e,"a",(function(){return g})),s=i(616),n=i(659),r=i(725),a=i(642),l=i(633),h=i(700),o=i(708),u=i(648),c=i(654);class g extends a.b{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(u.o(t.inputLength))}this.inputDim=t.inputDim,u.b(this.inputDim,"inputDim"),this.outputDim=t.outputDim,u.b(this.outputDim,"outputDim"),this.embeddingsInitializer=Object(h.q)(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Object(o.b)(t.embeddingsRegularizer),this.activityRegularizer=Object(o.b)(t.activityRegularizer),this.embeddingsConstraint=Object(r.e)(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return Object(s.Ei)((()=>this.maskZero?(t=Object(c.b)(t),Object(s.Mg)(t,Object(s.bj)(t))):null))}computeOutputShape(t){if(t=Object(c.a)(t),null==this.inputLength)return[...t,this.outputDim];const e=u.o(this.inputLength);if(e.length!==t.length-1)throw new l.e(`"inputLength" is ${this.inputLength}, but received input shape has shape `+t);{let i=0;for(let s=0;s<e.length;++s){const n=e[s],r=t[s+1];if(null!=n&&null!=r&&n!==r)throw new l.e(`"inputLength" is ${this.inputLength}, but received input shape has shape `+t);null==n&&(e[i]=r),i++}}return[t[0],...e,this.outputDim]}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);let i=Object(c.b)(t);"int32"!==i.dtype&&(i=n.c(i,"int32"));const r=n.k(this.embeddings.read(),Object(s.wh)(i,[i.size]));return Object(s.wh)(r,Object(c.a)(this.computeOutputShape(i.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Object(h.r)(this.embeddingsInitializer),embeddingsRegularizer:Object(o.e)(this.embeddingsRegularizer),activityRegularizer:Object(o.e)(this.activityRegularizer),embeddingsConstraint:Object(r.f)(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}g.className="Embedding",s.Lh.registerClass(g)},1753:function(t,e,i){"use strict";function s(t,e){for(;t<0;)t+=e;return t}var n,r,a,l,h,o,u,c;i.d(e,"a",(function(){return p})),i.d(e,"g",(function(){return m})),i.d(e,"b",(function(){return b})),i.d(e,"e",(function(){return f})),i.d(e,"f",(function(){return d})),i.d(e,"c",(function(){return O})),i.d(e,"d",(function(){return x})),n=i(616),r=i(659),a=i(642),l=i(633),h=i(779),o=i(648),u=i(723),c=i(654);class g extends a.b{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new l.c}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const i=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const n=t[t.length-e.length+s],r=e[s];if(null==n||null==r||n<0||r<0)i.push(null);else if(1===n)i.push(r);else if(1===r)i.push(n);else{if(n!==r)throw new l.e("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));i.push(n)}}return i}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Object(c.a)(t)]),t.length<2)throw new l.e(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const n of t)null!=n&&null!==n[0]&&e.push(n[0]);if(e=o.q(e),e.length>1)throw new l.e(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let i=null==t[0]?null:t[0].slice(1);for(let n=1;n<t.length;++n){const e=null==t[n]?null:t[n].slice(1);i=this.computeElementwiseOpOutputShape(i,e)}const s=t.map((t=>t.length));-1===t.indexOf(null)&&1===o.q(s).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return Object(n.Ei)((()=>{if(this.reshapeRequired){const e=[],i=t.map((t=>t.rank));if(-1===i.indexOf(null)){const s=u.c(i);for(let i of t){const t=i.rank;for(let e=0;e<s-t;++e)i=r.i(i,1);e.push(i)}return this.mergeFunction(e)}{let i=!1;for(const a of t){const t=a.rank;if(null==t){const t=a.shape,s=t[0],r=t.slice(1).concat([s]);let l=n.wh(a,[s].concat(u.a(t.slice(1))));l=n.Ji(l,[1,0]),l=n.wh(l,r),e.push(l),i=!0}else if(t>1){const s=u.e(1,t).concat([0]);e.push(n.Ji(a,s)),i=!0}else e.push(a)}let s=this.mergeFunction(e);const r=s.rank;if(i)if(null==r){const t=s.shape,e=t[t.length-1],i=[e].concat(t.slice(0,t.length-1));s=n.wh(n.Ji(n.wh(s,[-1,e]),[1,0]),i)}else if(r>1){const t=[r-1].concat(u.e(0,r-1));s=n.Ji(s,t)}return s}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const i=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let i=[];for(const s of t)null!=s&&null!==s[0]&&i.push(s[0]);return i=o.q(i),e=1===i.length?i.concat(e):[null].concat(e),e}computeMask(t,e){return n.Ei((()=>{if(null==e)return null;if(!Array.isArray(e))throw new l.e("`mask` should be an Array");if(!Array.isArray(t))throw new l.e("`inputs` should be an Array");if(e.length!==t.length)throw new l.e(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every((t=>null==t)))return null;let i=(e=e.map((t=>null==t?t:n.tf(t,0))))[0];for(let t=1;t<e.length-1;++t)i=n.kg(i,e[t]);return i}))}}class p extends g{constructor(t){super(t)}mergeFunction(t){return Object(n.Ei)((()=>{let e=t[0].clone();for(let i=1;i<t.length;++i)e=n.Ud(e,t[i]);return e}))}}p.className="Add",n.Lh.registerClass(p);class m extends g{constructor(t){super(t)}mergeFunction(t){return Object(n.Ei)((()=>{let e=t[0].clone();for(let i=1;i<t.length;++i)e=n.Gg(e,t[i]);return e}))}}m.className="Multiply",n.Lh.registerClass(m);class b extends g{constructor(t){super(t)}mergeFunction(t){return Object(n.Ei)((()=>{let e=t[0].clone();for(let i=1;i<t.length;++i)e=n.Ud(e,t[i]);return n.Gg(1/t.length,e)}))}}b.className="Average",n.Lh.registerClass(b);class f extends g{constructor(t){super(t)}mergeFunction(t){return Object(n.Ei)((()=>{let e=t[0];for(let i=1;i<t.length;++i)e=n.wg(e,t[i]);return e}))}}f.className="Maximum",n.Lh.registerClass(f);class d extends g{constructor(t){super(t)}mergeFunction(t){return Object(n.Ei)((()=>{let e=t[0];for(let i=1;i<t.length;++i)e=n.Bg(e,t[i]);return e}))}}d.className="Minimum",n.Lh.registerClass(d);class O extends g{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new l.e("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const s of t)if(null!=s){e=!1;break}if(e)return;const i=[];for(let s=0;s<t.length;++s){const e=t[s].slice();e.splice(this.axis,1);let r=!1;for(const t of i)if(n.Si.arraysEqual(t,e)){r=!0;break}r||i.push(e)}if(i.length>1)throw new l.e("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Object(n.Ei)((()=>r.e(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new l.e("A `Concatenate` layer should be called on a list of inputs.");const e=t,i=e[0].slice(),s=this.axis<0?i.length+this.axis:this.axis;for(const n of e.slice(1)){if(null==i[s]||null==n[s]){i[s]=null;break}i[s]+=n[s]}return i}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new l.e("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new l.e("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new l.e(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return n.Ei((()=>{let i=!0;if(e.forEach((t=>{null==t||(i=!1)})),i)return null;const s=[];for(let a=0;a<t.length;++a)null==e[a]?s.push(n.xe(n.Pg(t[a]),"bool")):e[a].rank<t[a].rank?s.push(n.tf(e[a],-1)):s.push(e[a]);const r=n.Ce(s,this.axis);return n.Wd(r,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}O.className="Concatenate",n.Lh.registerClass(O);class x extends g{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){n.Si.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],i=t[1];if(e.length>3||i.length>3)throw new l.c("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,i);if(e[s[0]]!==i[s[1]])throw new l.e(`Dimension incompatibility: ${e[s[0]]} !== ${i[s[1]]}`)}mergeFunction(t){if(2!==t.length)throw new l.e(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,i=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,i)=>s(e,t[i].shape.length))):[s(this.axes,i.shape.length),s(this.axes,r.shape.length)],this.normalize&&(i=Object(h.e)(i,e[0]),r=Object(h.e)(r,e[1])),function(t,e,i){if(t.shape.length>3||e.shape.length>3)throw new l.c("batchDot is not implemented for tensors of 4D or higher rank yet");if(n.Si.assert(t.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, but got "+t.shape.length)),n.Si.assert(t.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, but got "+e.shape.length)),"number"==typeof i&&(i=[i,i]),"complex64"===t.dtype||"complex64"===e.dtype)throw new l.c("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;null==i&&(i=[s-1,r-2]);const a=i;return n.Ei((()=>{let i,l;if(s>r){i=s-r;const t=[];for(let e=0;e<i;++e)t.push(1);e=n.wh(e,e.shape.concat(t))}else if(r>s){i=r-s;const e=[];for(let t=0;t<i;++t)e.push(1);t=n.wh(t,t.shape.concat(e))}else i=0;if(2===t.shape.length&&2===e.shape.length)l=a[0]===a[1]?n.qi(n.Gg(t,e),a[0]):n.qi(n.Gg(n.Ji(t,[1,0]),e),a[1]);else{const i=a[0]!==t.shape.length-1,s=a[1]===e.shape.length-1;l=n.qg(t,e,i,s)}if(i>0){let t;t=s>r?s+r-3:s-1;const e=[];for(let s=t;s<t+i;++s)e.push(s);l=n.ki(l,e)}return 1===l.shape.length&&(l=n.tf(l,1)),l}))}(i,r,e)}interpretAxes(t,e){let i;return i=Array.isArray(this.axes)?this.axes:[s(this.axes,t.length),s(this.axes,e.length)],i}computeOutputShape(t){n.Si.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),i=t[1].slice();if(e.length>3||i.length>3)throw new l.c("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,i);e.splice(s[0],1),i.splice(s[1],1),i.splice(0,1);const r=e.concat(i);return 1===r.length&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}x.className="Dot",n.Lh.registerClass(x)},1754:function(t,e,i){"use strict";var s,n,r,a;i.d(e,"c",(function(){return l})),i.d(e,"b",(function(){return h})),i.d(e,"a",(function(){return o})),s=i(616),n=i(659),r=i(642),a=i(654);class l extends r.b{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);const i=Object(a.b)(t);return n.m((()=>Object(s.Ud)(n.n(i.shape,0,this.stddev),i)),(()=>i),e.training||!1)}))}}l.className="GaussianNoise",s.Lh.registerClass(l);class h extends r.b{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Object(s.Ei)((()=>{this.invokeCallHook(t,e);const i=Object(a.b)(t);if(this.rate>0&&this.rate<1){const t=()=>{const t=Math.sqrt(this.rate/(1-this.rate));return Object(s.Gg)(i,n.n(i.shape,1,t))};return n.m(t,(()=>i),e.training||!1)}return i}))}}h.className="GaussianDropout",s.Lh.registerClass(h);class o extends r.b{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Object(a.b)(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Object(s.Ei)((()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(t),r=()=>{const e=Object(a.b)(t),r=-1.7580993408473766;let l=Object(s.Nf)(Object(s.kh)(i),this.rate);l=n.c(l,"float32");const h=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-h*r*this.rate,u=Object(s.Ud)(Object(s.Gg)(e,l),Object(s.Gg)(Object(s.Ud)(l,-1),r));return Object(s.Ud)(Object(s.Gg)(u,h),o)};return n.m(r,(()=>Object(a.b)(t)),e.training||!1)}return t}))}}o.className="AlphaDropout",s.Lh.registerClass(o)},1755:function(t,e,i){"use strict";function s(t,e,i,s,r,a=.001){let h;if(2===t.rank)h=n.le(t,e,i,s,r,a);else if(3===t.rank)h=n.me(t,e,i,s,r,a);else{if(4!==t.rank)throw new l.c(`batchNormalization is not implemented for array of rank ${t.rank} yet`);h=n.ne(t,e,i,s,r,a)}return h}var n,r,a,l,h,o,u,c,g;i.d(e,"a",(function(){return p})),i.d(e,"b",(function(){return m})),n=i(616),r=i(725),a=i(642),l=i(633),h=i(700),o=i(708),u=i(648),c=i(723),g=i(654);class p extends a.b{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Object(h.q)(t.betaInitializer||"zeros"),this.gammaInitializer=Object(h.q)(t.gammaInitializer||"ones"),this.movingMeanInitializer=Object(h.q)(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Object(h.q)(t.movingVarianceInitializer||"ones"),this.betaConstraint=Object(r.e)(t.betaConstraint),this.gammaConstraint=Object(r.e)(t.gammaConstraint),this.betaRegularizer=Object(o.b)(t.betaRegularizer),this.gammaRegularizer=Object(o.b)(t.gammaRegularizer)}build(t){t=Object(g.a)(t);const e=this.axis>=0?this.axis:this.axis+t.length,i=t[e];if(null==i)throw new l.e(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape `+JSON.stringify(t)+".");this.inputSpec=[new a.a({ndim:t.length,axes:{[e]:i}})];const s=[i];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return Object(n.Ei)((()=>{const i=null!=e.training&&e.training,r=Object(g.b)(t),a=r.shape,l=a.length,h=c.e(0,l),o=this.axis>=0?this.axis:this.axis+l;h.splice(o,1);const p=u.j(1,l);p[o]=a[o];const m=h.slice();m.sort();const b=!n.Si.arraysEqual(m,c.e(0,l).slice(0,l-1));if(!i)return(()=>{if(b){const t=Object(n.wh)(this.movingMean.read(),p),e=Object(n.wh)(this.movingVariance.read(),p),i=this.center?Object(n.wh)(this.beta.read(),p):null,a=this.scale?Object(n.wh)(this.gamma.read(),p):null;return s(r,t,e,i,a,this.epsilon)}return s(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[f,d,O]=function(t,e,i,r,a=.001){return n.Si.arraysEqual(r.slice().sort(),c.e(0,t.rank-1))?function(t,e,i,r,a=.001){return Object(n.Ei)((()=>{const l=n.Eg(t,r),h=l.mean,o=l.variance;return[s(t,h,o,i,e,a),h,o]}))}(t,e,i,r,a):function(t,e,i,r,a=.001){return Object(n.Ei)((()=>{const l=n.Eg(t,r),h=l.mean,o=l.variance,u=[];for(const e of c.e(0,t.rank))-1!==r.indexOf(e)?u.push(1):u.push(t.shape[e]);const g=Object(n.wh)(h,u),p=Object(n.wh)(o,u),m=null==e?null:Object(n.wh)(e,u),b=null==i?null:Object(n.wh)(i,u);return[s(t,g,p,b,m,a),h,o]}))}(t,e,i,r,a)}(r,this.gamma.read(),this.beta.read(),h,this.epsilon),x=(t,e,i)=>{n.Ei((()=>{const s=1-i,r=t.read(),a=n.Gg(n.pi(r,e),s);t.write(n.pi(r,a))}))};return(()=>{x(this.movingMean,d,this.momentum),x(this.movingVariance,O,this.momentum)})(),f}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Object(h.r)(this.betaInitializer),gammaInitializer:Object(h.r)(this.gammaInitializer),movingMeanInitializer:Object(h.r)(this.movingMeanInitializer),movingVarianceInitializer:Object(h.r)(this.movingVarianceInitializer),betaRegularizer:Object(o.e)(this.betaRegularizer),gammaRegularizer:Object(o.e)(this.gammaRegularizer),betaConstraint:Object(r.f)(this.betaConstraint),gammaConstraint:Object(r.f)(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}p.className="BatchNormalization",n.Lh.registerClass(p);class m extends a.b{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw Error("Expected axis to be an integer, but received "+this.axis)}else{if(!Array.isArray(this.axis))throw Error("Expected axis to be an integer or an array of integers, but received "+JSON.stringify(this.axis));for(const t of this.axis)if(!Number.isInteger(t))throw Error("Expected axis to be an array of integers, but received "+JSON.stringify(this.axis))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Object(h.q)(t.betaInitializer||"zeros"),this.gammaInitializer=Object(h.q)(t.gammaInitializer||"ones"),this.betaRegularizer=Object(o.b)(t.betaRegularizer),this.gammaRegularizer=Object(o.b)(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=Object(g.a)(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(const s of this.axis)if(s<0||s>=e)throw Error("Invalid axis: "+s);if(this.axis.length!==u.q(this.axis).length)throw Error("Found duplicate axes in: "+this.axis);const i=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(t,e){const i=Object(g.b)(t),r=i.shape,a=r.length;return Object(n.Ei)((()=>{let{mean:t,variance:e}=Object(n.Eg)(i,this.axis,!0);const l=u.j(1,a);for(const i of this.axis)l[i]=r[i];const h=t=>null!=t&&t.shape.length!==a?n.wh(t,l):t;let o=this.scale?h(this.gamma.read()):null,c=this.center?h(this.beta.read()):null;const g=[],p=[];for(let i=0;i<a;++i)-1!==this.axis.indexOf(i)?(g.push(r[i]),p.push(1)):(g.push(1),p.push(r[i]));return t=n.Fi(t,g),e=n.Fi(e,g),null!=o&&(o=n.Fi(o,p)),null!=c&&(c=n.Fi(c,p)),s(i,t,e,c,o,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Object(h.r)(this.betaInitializer),gammaInitializer:Object(h.r)(this.gammaInitializer),betaRegularizer:Object(o.e)(this.betaRegularizer),gammaRegularizer:Object(o.e)(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}m.className="LayerNormalization",n.Lh.registerClass(m)}}]);