/*! For license information please see chunk_33.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{1057:function(e,t,r){"use strict";var s,c,n,a=r(616);Object(a.of)().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),s=r(907),c=r(819),n=r(1209),r.d(t,"a",(function(){return s.a})),r.d(t,"c",(function(){return s.b})),r.d(t,"d",(function(){return s.c})),r.d(t,"b",(function(){return c.a})),r.d(t,"e",(function(){return c.c})),r.d(t,"f",(function(){return n.a}))},1786:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(650),c=r(1207);class n{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Object(s.e)(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(null!=r.tensor)return Object(s.e)(e,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return Object(c.f)(this.node.rawAttrs,e,t);if(null!=r.s)return Object(c.i)(this.node.rawAttrs,e,t);if(null!=r.b)return Object(c.c)(this.node.rawAttrs,e,t);if(null!=r.shape)return Object(c.k)(this.node.rawAttrs,e,t);if(null!=r.type)return Object(c.e)(this.node.rawAttrs,e,t);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return Object(c.g)(this.node.rawAttrs,e,t);if(null!=r.list.s)return Object(c.h)(this.node.rawAttrs,e,t);if(null!=r.list.shape)return Object(c.j)(this.node.rawAttrs,e,t);if(null!=r.list.b)return Object(c.b)(this.node.rawAttrs,e,t);if(null!=r.list.type)return Object(c.d)(this.node.rawAttrs,e,t)}return t}}},1787:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"AddN":return[n.addN(Object(c.d)("tensors",e,t,r))];case"FloorMod":case"Mod":return[n.mod(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Mul":return[n.mul(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"RealDiv":case"Div":return[n.div(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"DivNoNan":return[n.divNoNan(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"FloorDiv":return[n.floorDiv(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Sub":return[n.sub(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Minimum":return[n.minimum(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Maximum":return[n.maximum(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Pow":return[n.pow(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"SquaredDifference":return[n.squaredDifference(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1788:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"Abs":case"ComplexAbs":return[n.abs(Object(c.d)("x",e,t,r))];case"Acos":return[n.acos(Object(c.d)("x",e,t,r))];case"Acosh":return[n.acosh(Object(c.d)("x",e,t,r))];case"Asin":return[n.asin(Object(c.d)("x",e,t,r))];case"Asinh":return[n.asinh(Object(c.d)("x",e,t,r))];case"Atan":return[n.atan(Object(c.d)("x",e,t,r))];case"Atan2":return[n.atan2(Object(c.d)("x",e,t,r),Object(c.d)("y",e,t,r))];case"Atanh":return[n.atanh(Object(c.d)("x",e,t,r))];case"Ceil":return[n.ceil(Object(c.d)("x",e,t,r))];case"Complex":return[n.complex(Object(c.d)("real",e,t,r),Object(c.d)("imag",e,t,r))];case"Cos":return[n.cos(Object(c.d)("x",e,t,r))];case"Cosh":return[n.cosh(Object(c.d)("x",e,t,r))];case"Elu":return[n.elu(Object(c.d)("x",e,t,r))];case"Erf":return[n.erf(Object(c.d)("x",e,t,r))];case"Exp":return[n.exp(Object(c.d)("x",e,t,r))];case"Expm1":return[n.expm1(Object(c.d)("x",e,t,r))];case"Floor":return[n.floor(Object(c.d)("x",e,t,r))];case"Log":return[n.log(Object(c.d)("x",e,t,r))];case"Log1p":return[n.log1p(Object(c.d)("x",e,t,r))];case"Imag":return[n.imag(Object(c.d)("x",e,t,r))];case"Neg":return[n.neg(Object(c.d)("x",e,t,r))];case"Reciprocal":return[n.reciprocal(Object(c.d)("x",e,t,r))];case"Real":return[n.real(Object(c.d)("x",e,t,r))];case"Relu":return[n.relu(Object(c.d)("x",e,t,r))];case"Round":return[n.round(Object(c.d)("x",e,t,r))];case"Selu":return[n.selu(Object(c.d)("x",e,t,r))];case"Sigmoid":return[n.sigmoid(Object(c.d)("x",e,t,r))];case"Sin":return[n.sin(Object(c.d)("x",e,t,r))];case"Sign":return[n.sign(Object(c.d)("x",e,t,r))];case"Sinh":return[n.sinh(Object(c.d)("x",e,t,r))];case"Softplus":return[n.softplus(Object(c.d)("x",e,t,r))];case"Sqrt":return[n.sqrt(Object(c.d)("x",e,t,r))];case"Square":return[n.square(Object(c.d)("x",e,t,r))];case"Tanh":return[n.tanh(Object(c.d)("x",e,t,r))];case"Tan":return[n.tan(Object(c.d)("x",e,t,r))];case"ClipByValue":return[n.clipByValue(Object(c.d)("x",e,t,r),Object(c.d)("clipValueMin",e,t,r),Object(c.d)("clipValueMax",e,t,r))];case"Relu6":return[n.relu6(Object(c.d)("x",e,t,r))];case"Rsqrt":return[n.rsqrt(Object(c.e)(e.inputNames[0],t,r))];case"LeakyRelu":return[n.leakyRelu(Object(c.d)("x",e,t,r),Object(c.d)("alpha",e,t,r))];case"Prelu":return[n.prelu(Object(c.d)("x",e,t,r),Object(c.d)("alpha",e,t,r))];case"IsNan":return[n.isNaN(Object(c.e)(e.inputNames[0],t,r))];case"IsInf":return[n.isInf(Object(c.e)(e.inputNames[0],t,r))];case"IsFinite":return[n.isFinite(Object(c.e)(e.inputNames[0],t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1789:function(e,t,r){"use strict";var s,c,n,a;r.d(t,"a",(function(){return d})),s=r(616),c=r(1790),n=r(1791),a=r(650);const d=async(e,t,r)=>{switch(e.op){case"If":case"StatelessIf":{const s=Object(a.d)("thenBranch",e,t,r),c=Object(a.d)("elseBranch",e,t,r),n=Object(a.d)("cond",e,t,r),d=Object(a.d)("args",e,t,r);return(await n.data())[0]?r.functionMap[s].executeFunctionAsync(d,r.tensorArrayMap,r.tensorListMap):r.functionMap[c].executeFunctionAsync(d,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=Object(a.d)("body",e,t,r),c=Object(a.d)("cond",e,t,r),n=Object(a.d)("args",e,t,r),d=await r.functionMap[c].executeFunctionAsync(n,r.tensorArrayMap,r.tensorListMap),o=n.map((e=>e.id));let i=await d[0].data();d.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=n;for(;i[0];){const e=u;u=await r.functionMap[s].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const n=await r.functionMap[c].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);i=await n[0].data(),n.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":{const s=Object(a.d)("pred",e,t,r);return[Object(a.a)(s)]}case"Switch":{const s=Object(a.d)("pred",e,t,r);let c=Object(a.d)("data",e,t,r);return c.kept||(c=Object(a.a)(c)),(await s.data())[0]?[void 0,c]:[c,void 0]}case"Merge":{const s=e.inputNames.find((e=>void 0!==Object(a.e)(e,t,r)));if(s){const e=Object(a.e)(s,t,r);return[Object(a.a)(e)]}return}case"Enter":{const s=Object(a.d)("frameName",e,t,r),c=Object(a.d)("tensor",e,t,r);return r.enterFrame(s),[Object(a.a)(c)]}case"Exit":{const s=Object(a.d)("tensor",e,t,r);return r.exitFrame(),[Object(a.a)(s)]}case"NextIteration":{const s=Object(a.d)("tensor",e,t,r);return r.nextIteration(),[Object(a.a)(s)]}case"TensorArrayV3":{const n=Object(a.d)("size",e,t,r),d=Object(a.d)("dtype",e,t,r),o=Object(a.d)("elementShape",e,t,r),i=Object(a.d)("dynamicSize",e,t,r),u=Object(a.d)("clearAfterRead",e,t,r),b=Object(a.d)("identicalElementShapes",e,t,r),O=Object(a.d)("name",e,t,r),j=new c.a(O,d,n,o,b,i,u);return r.addTensorArray(j),[j.idTensor,Object(s.Fh)(1)]}case"TensorArrayWriteV3":{const s=Object(a.d)("tensorArrayId",e,t,r),c=Object(a.d)("index",e,t,r),n=Object(a.d)("tensor",e,t,r),d=r.getTensorArray(s.id);return d.write(c,n),[d.idTensor]}case"TensorArrayReadV3":{const s=Object(a.d)("tensorArrayId",e,t,r),c=Object(a.d)("index",e,t,r);return[r.getTensorArray(s.id).read(c)]}case"TensorArrayGatherV3":{const s=Object(a.d)("tensorArrayId",e,t,r),c=Object(a.d)("indices",e,t,r),n=Object(a.d)("dtype",e,t,r);return[r.getTensorArray(s.id).gather(c,n)]}case"TensorArrayScatterV3":{const s=Object(a.d)("tensorArrayId",e,t,r),c=Object(a.d)("indices",e,t,r),n=Object(a.d)("tensor",e,t,r),d=r.getTensorArray(s.id);return d.scatter(c,n),[d.idTensor]}case"TensorArrayConcatV3":{const s=Object(a.d)("tensorArrayId",e,t,r),c=r.getTensorArray(s.id),n=Object(a.d)("dtype",e,t,r);return[c.concat(n)]}case"TensorArraySplitV3":{const s=Object(a.d)("tensorArrayId",e,t,r),c=Object(a.d)("tensor",e,t,r),n=Object(a.d)("lengths",e,t,r),d=r.getTensorArray(s.id);return d.split(n,c),[d.idTensor]}case"TensorArraySizeV3":{const c=Object(a.d)("tensorArrayId",e,t,r),n=r.getTensorArray(c.id);return[Object(s.Fh)(n.size(),"int32")]}case"TensorArrayCloseV3":{const s=Object(a.d)("tensorArrayId",e,t,r),c=r.getTensorArray(s.id);return c.clearAndClose(),[c.idTensor]}case"TensorListSetItem":{const s=Object(a.d)("tensorListId",e,t,r),c=Object(a.d)("index",e,t,r),n=Object(a.d)("tensor",e,t,r),d=r.getTensorList(s.id);return d.setItem(c,n),[d.idTensor]}case"TensorListGetItem":{const s=Object(a.d)("tensorListId",e,t,r),c=Object(a.d)("index",e,t,r),n=Object(a.d)("elementShape",e,t,r),d=Object(a.d)("elementDType",e,t,r);return[r.getTensorList(s.id).getItem(c,n,d)]}case"TensorListScatterV2":case"TensorListScatter":{const s=Object(a.d)("indices",e,t,r),c=Object(a.d)("tensor",e,t,r),d=Object(a.d)("elementShape",e,t,r),o=Object(a.d)("numElements",e,t,r),i=Object(n.c)(c,s,d,o);return r.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=Object(a.d)("elementShape",e,t,r),c=Object(a.d)("elementDType",e,t,r);let d;d="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=Object(a.d)(d,e,t,r),i="TensorListReserve"===e.op?-1:o,u=Object(n.b)(s,c,o,i);return r.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=Object(a.d)("tensorListId",e,t,r),c=Object(a.d)("indices",e,t,r),n=Object(a.d)("elementShape",e,t,r),d=Object(a.d)("elementDType",e,t,r);return[r.getTensorList(s.id).gather(c,d,n)]}case"TensorListStack":{const s=Object(a.d)("tensorListId",e,t,r),c=Object(a.d)("elementShape",e,t,r),n=Object(a.d)("elementDType",e,t,r),d=Object(a.d)("numElements",e,t,r);return[r.getTensorList(s.id).stack(c,n,d)]}case"TensorListFromTensor":{const s=Object(a.d)("tensor",e,t,r),c=Object(a.d)("elementShape",e,t,r),d=Object(a.d)("elementDType",e,t,r),o=Object(n.a)(s,c,d);return r.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=Object(a.d)("tensorListId",e,t,r),c=r.getTensorList(s.id),n=Object(a.d)("dtype",e,t,r),d=Object(a.d)("elementShape",e,t,r);return[c.concat(n,d)]}case"TensorListPushBack":{const s=Object(a.d)("tensorListId",e,t,r),c=Object(a.d)("tensor",e,t,r),n=r.getTensorList(s.id);return n.pushBack(c),[n.idTensor]}case"TensorListPopBack":{const s=Object(a.d)("tensorListId",e,t,r),c=Object(a.d)("elementShape",e,t,r),n=Object(a.d)("elementDType",e,t,r);return[r.getTensorList(s.id).popBack(c,n)]}case"TensorListSplit":{const s=Object(a.d)("tensor",e,t,r),c=Object(a.d)("elementShape",e,t,r),d=Object(a.d)("lengths",e,t,r),o=Object(n.d)(s,d,c);return r.addTensorList(o),[o.idTensor]}case"TensorListLength":{const c=Object(a.d)("tensorListId",e,t,r),n=r.getTensorList(c.id);return[Object(s.Fh)(n.size(),"int32")]}case"TensorListResize":{const s=Object(a.d)("tensorListId",e,t,r),c=Object(a.d)("size",e,t,r),n=r.getTensorList(s.id).resize(c);return r.addTensorList(n),[n.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1792:function(e,t,r){"use strict";function s(e,t,r){const[s,c]=Object(n.d)("fusedOps",e,t,r),a="biasadd"===s,d=!a,o="prelu"===c,i="fusedbatchnorm"===s,u=Object(n.d)("numArgs",e,t,r);if(a){if(o&&2!==u)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const b=Object(n.d)("strides",e,t,r),O=Object(n.c)(e,t,r),j=Object(n.d)("dataFormat",e,t,r).toUpperCase(),p=Object(n.d)("dilations",e,t,r);let[l,m]=Object(n.d)("args",e,t,r);return d&&(m=l,l=void 0),{stride:b,pad:O,dataFormat:j,dilations:p,biasArg:l,preluArg:m,activationFunc:c,leakyreluAlpha:Object(n.d)("leakyreluAlpha",e,t,r)}}var c,n;r.d(t,"a",(function(){return a})),c=r(664),n=r(650);const a=(e,t,r,a=c)=>{switch(e.op){case"Conv1D":{const s=Object(n.d)("stride",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("dataFormat",e,t,r).toUpperCase(),o=Object(n.d)("dilation",e,t,r);return[a.conv1d(Object(n.d)("x",e,t,r),Object(n.d)("filter",e,t,r),s,c,d,o)]}case"Conv2D":{const s=Object(n.d)("strides",e,t,r),c=Object(n.c)(e,t,r),d=Object(n.d)("dataFormat",e,t,r).toUpperCase(),o=Object(n.d)("dilations",e,t,r);return[a.conv2d(Object(n.d)("x",e,t,r),Object(n.d)("filter",e,t,r),[s[1],s[2]],c,d,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:c,pad:d,dataFormat:o,dilations:i,biasArg:u,preluArg:b,activationFunc:O,leakyreluAlpha:j}=s(e,t,r);return[a.fused.conv2d({x:Object(n.d)("x",e,t,r),filter:Object(n.d)("filter",e,t,r),strides:[c[1],c[2]],pad:d,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:O,preluActivationWeights:b,leakyreluAlpha:j})]}case"FusedDepthwiseConv2dNative":{const{stride:c,pad:d,dataFormat:o,dilations:i,biasArg:u,preluArg:b,activationFunc:O,leakyreluAlpha:j}=s(e,t,r);return[a.fused.depthwiseConv2d({x:Object(n.d)("x",e,t,r),filter:Object(n.d)("filter",e,t,r),strides:[c[1],c[2]],pad:d,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:O,preluActivationWeights:b,leakyreluAlpha:j})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=Object(n.d)("outputShape",e,t,r),c=Object(n.d)("strides",e,t,r),d=Object(n.c)(e,t,r);return[a.conv2dTranspose(Object(n.d)("x",e,t,r),Object(n.d)("filter",e,t,r),s,[c[1],c[2]],d)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=Object(n.d)("strides",e,t,r),c=Object(n.c)(e,t,r),d=Object(n.d)("dilations",e,t,r),o=Object(n.d)("dataFormat",e,t,r).toUpperCase();return[a.depthwiseConv2d(Object(n.d)("input",e,t,r),Object(n.d)("filter",e,t,r),[s[1],s[2]],c,o,[d[1],d[2]])]}case"Conv3D":{const s=Object(n.d)("strides",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("dataFormat",e,t,r).toUpperCase(),o=Object(n.d)("dilations",e,t,r);return[a.conv3d(Object(n.d)("x",e,t,r),Object(n.d)("filter",e,t,r),[s[1],s[2],s[3]],c,d,[o[1],o[2],o[3]])]}case"AvgPool":{const s=Object(n.d)("strides",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("kernelSize",e,t,r);return[a.avgPool(Object(n.d)("x",e,t,r),[d[1],d[2]],[s[1],s[2]],c)]}case"MaxPool":{const s=Object(n.d)("strides",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("kernelSize",e,t,r);return[a.maxPool(Object(n.d)("x",e,t,r),[d[1],d[2]],[s[1],s[2]],c)]}case"MaxPoolWithArgmax":{const s=Object(n.d)("strides",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("kernelSize",e,t,r),o=Object(n.d)("includeBatchInIndex",e,t,r),{result:i,indexes:u}=a.maxPoolWithArgmax(Object(n.d)("x",e,t,r),[d[1],d[2]],[s[1],s[2]],c,o);return[i,u]}case"AvgPool3D":{const s=Object(n.d)("strides",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("kernelSize",e,t,r);return[a.avgPool3d(Object(n.d)("x",e,t,r),[d[1],d[2],d[3]],[s[1],s[2],s[3]],c)]}case"MaxPool3D":{const s=Object(n.d)("strides",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("kernelSize",e,t,r);return[a.maxPool3d(Object(n.d)("x",e,t,r),[d[1],d[2],d[3]],[s[1],s[2],s[3]],c)]}case"Dilation2D":{const s=Object(n.d)("strides",e,t,r),c=Object(n.d)("pad",e,t,r),d=Object(n.d)("dilations",e,t,r),o=s[1],i=s[2],u=d[1],b=d[2];return[a.dilation2d(Object(n.d)("x",e,t,r),Object(n.d)("filter",e,t,r),[o,i],c,[u,b],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1793:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"Fill":{const s=Object(c.d)("shape",e,t,r),a=Object(c.d)("dtype",e,t,r),d=Object(c.d)("value",e,t,r);return[n.fill(s,d,a)]}case"LinSpace":{const s=Object(c.d)("start",e,t,r),a=Object(c.d)("stop",e,t,r),d=Object(c.d)("num",e,t,r);return[n.linspace(s,a,d)]}case"Multinomial":{const s=Object(c.d)("logits",e,t,r),a=Object(c.d)("numSamples",e,t,r),d=Object(c.d)("seed",e,t,r);return[n.multinomial(s,a,d)]}case"OneHot":{const s=Object(c.d)("indices",e,t,r),a=Object(c.d)("depth",e,t,r),d=Object(c.d)("onValue",e,t,r),o=Object(c.d)("offValue",e,t,r),i=Object(c.d)("dtype",e,t,r);return[n.oneHot(s,a,d,o,i)]}case"Ones":return[n.ones(Object(c.d)("shape",e,t,r),Object(c.d)("dtype",e,t,r))];case"OnesLike":return[n.onesLike(Object(c.d)("x",e,t,r))];case"RandomStandardNormal":return[n.randomStandardNormal(Object(c.d)("shape",e,t,r),Object(c.d)("dtype",e,t,r),Object(c.d)("seed",e,t,r))];case"RandomUniform":return[n.randomUniform(Object(c.d)("shape",e,t,r),Object(c.d)("minval",e,t,r),Object(c.d)("maxval",e,t,r),Object(c.d)("dtype",e,t,r))];case"RandomUniformInt":return[n.randomUniformInt(Object(c.d)("shape",e,t,r),Object(c.d)("minval",e,t,r),Object(c.d)("maxval",e,t,r),Object(c.d)("seed",e,t,r))];case"Range":{const s=Object(c.d)("start",e,t,r),a=Object(c.d)("stop",e,t,r),d=Object(c.d)("step",e,t,r);return[n.range(s,a,d,Object(c.d)("dtype",e,t,r))]}case"TruncatedNormal":{const s=Object(c.d)("shape",e,t,r),a=Object(c.d)("mean",e,t,r),d=Object(c.d)("stdDev",e,t,r),o=Object(c.d)("seed",e,t,r);return[n.truncatedNormal(s,a,d,Object(c.d)("dtype",e,t,r),o)]}case"Zeros":return[n.zeros(Object(c.d)("shape",e,t,r),Object(c.d)("dtype",e,t,r))];case"ZerosLike":return[n.zerosLike(Object(c.d)("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1794:function(e,t,r){"use strict";function s(e,t,r){return{boxes:Object(n.d)("boxes",e,t,r),scores:Object(n.d)("scores",e,t,r),maxOutputSize:Object(n.d)("maxOutputSize",e,t,r),iouThreshold:Object(n.d)("iouThreshold",e,t,r),scoreThreshold:Object(n.d)("scoreThreshold",e,t,r),softNmsSigma:Object(n.d)("softNmsSigma",e,t,r)}}var c,n;r.d(t,"a",(function(){return a})),c=r(664),n=r(650);const a=async(e,t,r,a,d=c)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:c,scores:n,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}=s(e,t,r),b=await d.image.nonMaxSuppressionWithScoreAsync(c,n,a,o,i,u);return[b.selectedIndices,b.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:c,scores:a,maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=s(e,t,r),b=Object(n.d)("padToMaxOutputSize",e,t,r),O=await d.image.nonMaxSuppressionPaddedAsync(c,a,o,i,u,b);return[O.selectedIndices,O.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:c,scores:n,maxOutputSize:a,iouThreshold:o,scoreThreshold:i}=s(e,t,r);return[await d.image.nonMaxSuppressionAsync(c,n,a,o,i)]}case"Where":{const s=d.cast(Object(n.d)("condition",e,t,r),"bool"),c=[await d.whereAsync(s)];return s.dispose(),c}case"ListDiff":return d.setdiff1dAsync(Object(n.d)("x",e,t,r),Object(n.d)("y",e,t,r));default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1795:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"LowerBound":{const s=Object(c.d)("sortedSequence",e,t,r),a=Object(c.d)("values",e,t,r);return[n.lowerBound(s,a)]}case"TopKV2":{const s=Object(c.d)("x",e,t,r),a=Object(c.d)("k",e,t,r),d=Object(c.d)("sorted",e,t,r),o=n.topk(s,a,d);return[o.values,o.indices]}case"UpperBound":{const s=Object(c.d)("sortedSequence",e,t,r),a=Object(c.d)("values",e,t,r);return[n.upperBound(s,a)]}case"Unique":{const s=Object(c.d)("x",e,t,r),a=n.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=Object(c.d)("x",e,t,r),a=Object(c.d)("axis",e,t,r),d=n.unique(s,a);return[d.values,d.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1796:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=Object(c.d)("default",e,t,r);return[Object(c.e)(e.name,t,r)||s];case"Placeholder":return[Object(c.e)(e.name,t,r)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const s=Object(c.d)("x",e,t,r);return[Object(c.a)(s)]}case"IdentityN":return Object(c.d)("x",e,t,r).map((e=>Object(c.a)(e)));case"Snapshot":const a=Object(c.d)("x",e,t,r);return[Object(c.a)(a)];case"Shape":return[n.tensor1d(Object(c.d)("x",e,t,r).shape,"int32")];case"ShapeN":return Object(c.d)("x",e,t,r).map((e=>n.tensor1d(e.shape)));case"Size":return[n.scalar(Object(c.d)("x",e,t,r).size,"int32")];case"Rank":return[n.scalar(Object(c.d)("x",e,t,r).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":const d=Object(c.d)("x",e,t,r),o=Object(c.d)("data",e,t,r),i=Object(c.d)("message",e,t,r),u=Object(c.d)("summarize",e,t,r);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,u));return[d];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1797:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(1798),c=r(650);const n=async(e,t,r,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{const a=n.getHashTableHandleByName(e.name);if(null!=a)return[a];{const a=Object(c.d)("keyDType",e,t,r),d=Object(c.d)("valueDType",e,t,r),o=new s.a(a,d);return n.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=Object(c.d)("tableHandle",e,t,r,n),a=Object(c.d)("keys",e,t,r),d=Object(c.d)("values",e,t,r),o=n.getHashTableById(s.id);return[await o.import(a,d)]}case"LookupTableFind":case"LookupTableFindV2":{const s=Object(c.d)("tableHandle",e,t,r,n),a=Object(c.d)("keys",e,t,r),d=Object(c.d)("defaultValue",e,t,r),o=n.getHashTableById(s.id);return[await o.find(a,d)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=Object(c.d)("tableHandle",e,t,r,n);return[n.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1799:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"ResizeBilinear":{const s=Object(c.d)("images",e,t,r),a=Object(c.d)("size",e,t,r),d=Object(c.d)("alignCorners",e,t,r),o=Object(c.d)("halfPixelCenters",e,t,r);return[n.image.resizeBilinear(s,[a[0],a[1]],d,o)]}case"ResizeNearestNeighbor":{const s=Object(c.d)("images",e,t,r),a=Object(c.d)("size",e,t,r),d=Object(c.d)("alignCorners",e,t,r),o=Object(c.d)("halfPixelCenters",e,t,r);return[n.image.resizeNearestNeighbor(s,[a[0],a[1]],d,o)]}case"CropAndResize":{const s=Object(c.d)("image",e,t,r),a=Object(c.d)("boxes",e,t,r),d=Object(c.d)("boxInd",e,t,r),o=Object(c.d)("cropSize",e,t,r),i=Object(c.d)("method",e,t,r),u=Object(c.d)("extrapolationValue",e,t,r);return[n.image.cropAndResize(s,a,d,o,i,u)]}case"ImageProjectiveTransformV3":{const s=Object(c.d)("images",e,t,r),a=Object(c.d)("transforms",e,t,r),d=Object(c.d)("outputShape",e,t,r),o=Object(c.d)("fillValue",e,t,r),i=Object(c.d)("interpolation",e,t,r),u=Object(c.d)("fillMode",e,t,r);return[n.image.transform(s,a,i.toLowerCase(),u.toLowerCase(),o,d)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1800:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"Equal":return[n.equal(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"NotEqual":return[n.notEqual(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Greater":return[n.greater(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"GreaterEqual":return[n.greaterEqual(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Less":return[n.less(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"LessEqual":return[n.lessEqual(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"LogicalAnd":return[n.logicalAnd(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"LogicalNot":return[n.logicalNot(Object(c.d)("a",e,t,r))];case"LogicalOr":return[n.logicalOr(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"Select":case"SelectV2":return[n.where(Object(c.d)("condition",e,t,r),Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];case"BitwiseAnd":return[n.bitwiseAnd(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1801:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(Object(c.d)("a",e,t,r),Object(c.d)("b",e,t,r),Object(c.d)("transposeA",e,t,r),Object(c.d)("transposeB",e,t,r))];case"Einsum":return[n.einsum(Object(c.d)("equation",e,t,r),...Object(c.d)("tensors",e,t,r))];case"Transpose":return[n.transpose(Object(c.d)("x",e,t,r),Object(c.d)("perm",e,t,r))];case"_FusedMatMul":const[s,a]=Object(c.d)("fusedOps",e,t,r),d="biasadd"===s,o="prelu"===a,i=Object(c.d)("numArgs",e,t,r),u=Object(c.d)("leakyreluAlpha",e,t,r);if(d){if(o&&2!==i)throw Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[b,O]=Object(c.d)("args",e,t,r);return[n.fused.matMul({a:Object(c.d)("a",e,t,r),b:Object(c.d)("b",e,t,r),transposeA:Object(c.d)("transposeA",e,t,r),transposeB:Object(c.d)("transposeB",e,t,r),bias:b,activation:a,preluActivationWeights:O,leakyreluAlpha:u})];case"MatrixBandPart":return[n.linalg.bandPart(Object(c.d)("a",e,t,r),Object(c.d)("numLower",e,t,r),Object(c.d)("numUpper",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1802:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"EuclideanNorm":return[n.euclideanNorm(Object(c.d)("x",e,t,r),Object(c.d)("axis",e,t,r),Object(c.d)("keepDims",e,t,r))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[n.batchNorm(Object(c.d)("x",e,t,r),Object(c.d)("mean",e,t,r),Object(c.d)("variance",e,t,r),Object(c.d)("offset",e,t,r),Object(c.d)("scale",e,t,r),Object(c.d)("epsilon",e,t,r))];case"LRN":return[n.localResponseNormalization(Object(c.d)("x",e,t,r),Object(c.d)("radius",e,t,r),Object(c.d)("bias",e,t,r),Object(c.d)("alpha",e,t,r),Object(c.d)("beta",e,t,r))];case"Softmax":return[n.softmax(Object(c.d)("x",e,t,r))];case"LogSoftmax":return[n.logSoftmax(Object(c.d)("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1803:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=n.raggedGather(Object(c.d)("paramsNestedSplits",e,t,r),Object(c.d)("paramsDenseValues",e,t,r),Object(c.d)("indices",e,t,r),Object(c.d)("outputRaggedRank",e,t,r));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=n.raggedRange(Object(c.d)("starts",e,t,r),Object(c.d)("limits",e,t,r),Object(c.d)("splits",e,t,r));return[s,a]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(Object(c.d)("shape",e,t,r),Object(c.d)("values",e,t,r),Object(c.d)("defaultValue",e,t,r),Object(c.d)("rowPartitionTensors",e,t,r),Object(c.d)("rowPartitionTypes",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1804:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"Max":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("keepDims",e,t,r);return[n.max(Object(c.d)("x",e,t,r),s,a)]}case"Mean":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("keepDims",e,t,r);return[n.mean(Object(c.d)("x",e,t,r),s,a)]}case"Min":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("keepDims",e,t,r);return[n.min(Object(c.d)("x",e,t,r),s,a)]}case"Sum":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("keepDims",e,t,r);return[n.sum(Object(c.d)("x",e,t,r),s,a)]}case"All":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("keepDims",e,t,r);return[n.all(Object(c.d)("x",e,t,r),s,a)]}case"Any":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("keepDims",e,t,r);return[n.any(Object(c.d)("x",e,t,r),s,a)]}case"ArgMax":{const s=Object(c.d)("axis",e,t,r);return[n.argMax(Object(c.d)("x",e,t,r),s)]}case"ArgMin":{const s=Object(c.d)("axis",e,t,r);return[n.argMin(Object(c.d)("x",e,t,r),s)]}case"Prod":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("keepDims",e,t,r);return[n.prod(Object(c.d)("x",e,t,r),s,a)]}case"Cumprod":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("exclusive",e,t,r),d=Object(c.d)("reverse",e,t,r);return[n.cumprod(Object(c.d)("x",e,t,r),s,a,d)]}case"Cumsum":{const s=Object(c.d)("axis",e,t,r),a=Object(c.d)("exclusive",e,t,r),d=Object(c.d)("reverse",e,t,r);return[n.cumsum(Object(c.d)("x",e,t,r),s,a,d)]}case"Bincount":const s=Object(c.d)("x",e,t,r),a=Object(c.d)("weights",e,t,r),d=Object(c.d)("size",e,t,r);return[n.bincount(s,a,d)];case"DenseBincount":{const s=Object(c.d)("x",e,t,r),a=Object(c.d)("weights",e,t,r),d=Object(c.d)("size",e,t,r),o=Object(c.d)("binaryOutput",e,t,r);return[n.denseBincount(s,a,d,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1805:function(e,t,r){"use strict";var s,c,n;r.d(t,"a",(function(){return a})),s=r(616),c=r(664),n=r(650);const a=(e,t,r,a=c)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=Object(n.d)("n",e,t,r),c=Object(n.d)("axis",e,t,r);let d=Object(n.d)("tensors",e,t,r);return d=d.slice(0,s),[a.concat(d,c)]}case"Gather":{const s=Object(n.d)("x",e,t,r),c=Object(n.d)("indices",e,t,r);return[a.gather(s,a.cast(c,"int32"),0)]}case"GatherV2":{const s=Object(n.d)("axis",e,t,r),c=Object(n.d)("batchDims",e,t,r),d=Object(n.d)("x",e,t,r),o=Object(n.d)("indices",e,t,r);return[a.gather(d,a.cast(o,"int32"),s,c)]}case"Reverse":{const s=Object(n.d)("dims",e,t,r),c=[];for(let e=0;e<s.length;e++)s[e]&&c.push(e);const d=Object(n.d)("x",e,t,r);return[a.reverse(d,c)]}case"ReverseV2":{const s=Object(n.d)("axis",e,t,r),c=Object(n.d)("x",e,t,r);return[a.reverse(c,s)]}case"Slice":{const s=Object(n.d)("begin",e,t,r),c=Object(n.d)("size",e,t,r);return[a.slice(Object(n.d)("x",e,t,r),s,c)]}case"StridedSlice":{const s=Object(n.d)("begin",e,t,r),c=Object(n.d)("end",e,t,r),d=Object(n.d)("strides",e,t,r),o=Object(n.d)("beginMask",e,t,r),i=Object(n.d)("endMask",e,t,r),u=Object(n.d)("ellipsisMask",e,t,r),b=Object(n.d)("newAxisMask",e,t,r),O=Object(n.d)("shrinkAxisMask",e,t,r),j=Object(n.d)("x",e,t,r);return[a.stridedSlice(j,s,c,d,o,i,u,b,O)]}case"Pack":return Object(s.Ei)((()=>{const c=Object(n.d)("axis",e,t,r),d=Object(n.d)("tensors",e,t,r),o=d[0].shape,i=a.squeeze(d[0]).shape,u=d.map((e=>{const t=s.Si.arraysEqual(e.shape,o);if(!t&&!s.Si.arraysEqual(a.squeeze(e).shape,i))throw Error("the input tensors shape does not match");return t?e:a.reshape(e,o)}));return[a.stack(u,c)]}));case"Unpack":{const s=Object(n.d)("axis",e,t,r),c=Object(n.d)("tensor",e,t,r);return a.unstack(c,s)}case"Tile":{const s=Object(n.d)("reps",e,t,r);return[a.tile(Object(n.d)("x",e,t,r),s)]}case"Split":case"SplitV":{const s=Object(n.d)("axis",e,t,r),c=Object(n.d)("numOrSizeSplits",e,t,r),d=Object(n.d)("x",e,t,r);return a.split(d,c,s)}case"ScatterNd":{const s=Object(n.d)("indices",e,t,r),c=Object(n.d)("values",e,t,r),d=Object(n.d)("shape",e,t,r);return[a.scatterND(s,c,d)]}case"GatherNd":{const s=Object(n.d)("x",e,t,r),c=Object(n.d)("indices",e,t,r);return[a.gatherND(s,c)]}case"SparseToDense":{const s=Object(n.d)("sparseIndices",e,t,r),c=Object(n.d)("outputShape",e,t,r),d=Object(n.d)("sparseValues",e,t,r),o=Object(n.d)("defaultValue",e,t,r);return[a.sparseToDense(s,d,c,d.dtype===o.dtype?o:a.cast(o,d.dtype))]}case"TensorScatterUpdate":{const s=Object(n.d)("indices",e,t,r),c=Object(n.d)("values",e,t,r),d=Object(n.d)("tensor",e,t,r);return[a.tensorScatterUpdate(d,s,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1806:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:d,reverseIndexMap:o}=n.sparse.sparseFillEmptyRows(Object(c.d)("indices",e,t,r),Object(c.d)("values",e,t,r),Object(c.d)("denseShape",e,t,r),Object(c.d)("defaultValue",e,t,r));return[s,a,d,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=n.sparse.sparseReshape(Object(c.d)("inputIndices",e,t,r),Object(c.d)("inputShape",e,t,r),Object(c.d)("newShape",e,t,r));return[s,a]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(Object(c.d)("data",e,t,r),Object(c.d)("indices",e,t,r),Object(c.d)("segmentIds",e,t,r))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(Object(c.d)("data",e,t,r),Object(c.d)("indices",e,t,r),Object(c.d)("segmentIds",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1807:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"FFT":return[n.fft(Object(c.d)("x",e,t,r))];case"IFFT":return[n.ifft(Object(c.d)("x",e,t,r))];case"RFFT":return[n.rfft(Object(c.d)("x",e,t,r))];case"IRFFT":return[n.irfft(Object(c.d)("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1808:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(Object(c.d)("input",e,t,r),Object(c.d)("pattern",e,t,r),Object(c.d)("rewrite",e,t,r),Object(c.d)("replaceGlobal",e,t,r))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=n.string.stringNGrams(Object(c.d)("data",e,t,r),Object(c.d)("dataSplits",e,t,r),Object(c.d)("separator",e,t,r),Object(c.d)("nGramWidths",e,t,r),Object(c.d)("leftPad",e,t,r),Object(c.d)("rightPad",e,t,r),Object(c.d)("padWidth",e,t,r),Object(c.d)("preserveShortSequences",e,t,r));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:d}=n.string.stringSplit(Object(c.d)("input",e,t,r),Object(c.d)("delimiter",e,t,r),Object(c.d)("skipEmpty",e,t,r));return[s,a,d]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(Object(c.d)("input",e,t,r),Object(c.d)("numBuckets",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},1809:function(e,t,r){"use strict";var s,c;r.d(t,"a",(function(){return n})),s=r(664),c=r(650);const n=(e,t,r,n=s)=>{switch(e.op){case"Cast":return[n.cast(Object(c.d)("x",e,t,r),Object(c.d)("dtype",e,t,r))];case"ExpandDims":{const s=Object(c.d)("axis",e,t,r);return[n.expandDims(Object(c.d)("x",e,t,r),s)]}case"Squeeze":{const s=Object(c.d)("axis",e,t,r);return[n.squeeze(Object(c.d)("x",e,t,r),s)]}case"Reshape":return[n.reshape(Object(c.d)("x",e,t,r),Object(c.d)("shape",e,t,r))];case"EnsureShape":return[n.ensureShape(Object(c.d)("x",e,t,r),Object(c.d)("shape",e,t,r))];case"MirrorPad":return[n.mirrorPad(Object(c.d)("x",e,t,r),Object(c.d)("padding",e,t,r),Object(c.d)("mode",e,t,r))];case"PadV2":case"Pad":return[n.pad(Object(c.d)("x",e,t,r),Object(c.d)("padding",e,t,r),Object(c.d)("constantValue",e,t,r))];case"SpaceToBatchND":{const s=Object(c.d)("blockShape",e,t,r),a=Object(c.d)("paddings",e,t,r);return[n.spaceToBatchND(Object(c.d)("x",e,t,r),s,a)]}case"BatchToSpaceND":{const s=Object(c.d)("blockShape",e,t,r),a=Object(c.d)("crops",e,t,r);return[n.batchToSpaceND(Object(c.d)("x",e,t,r),s,a)]}case"DepthToSpace":{const s=Object(c.d)("blockSize",e,t,r),a=Object(c.d)("dataFormat",e,t,r).toUpperCase();return[n.depthToSpace(Object(c.d)("x",e,t,r),s,a)]}case"BroadcastTo":return[n.broadcastTo(Object(c.d)("x",e,t,r),Object(c.d)("shape",e,t,r))];case"BroadcastArgs":return[n.broadcastArgs(Object(c.d)("s0",e,t,r),Object(c.d)("s1",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},650:function(e,t,r){"use strict";function s(e,t,r,s,n){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,d=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return c(t.inputNames[o],r,s,n);if("tensors"===a.type){const a=t.inputs.slice(e,d);return t.inputNames.slice(e,d).filter(((e,t)=>{var r;return"NoOp"!==(null===(r=a[t])||void 0===r?void 0:r.op)})).map((e=>c(e,r,s,n)))}const i=c(t.inputNames[o],r,s,n),u=i.dataSync();return"number"===a.type?u[0]:b.Si.toNestedArray(i.shape,u)}const d=t.attrParams[e];return d&&d.value}function c(e,t,r,s){const[c,n]=o(e,r);if(null!=s){const e=s.getHashTableHandleByName(c);if(null!=e)return e}const a=r.currentContextIds.find((e=>!!t[d(c,e)]));return void 0!==a?t[d(c,a)][n]:void 0}function n(e,t,r){return t[d(e,r.currentContextId)]}function a(e,t){const[r,s,c]=o(e,t);return[d(r,t&&t.currentContextId),s,c]}function d(e,t){return t?`${e}-${t}`:e}function o(e,t){if(""===e)return["",0,void 0];const r=null!=t&&null!=t.parseNodeNameCache;if(r){const r=t.parseNodeNameCache.get(e);if(null!=r)return r}const s=e.split(":");let c;if(1===s.length)c=[e,0,void 0];else{const e=s[0],t=3===s.length?s[1]:void 0;c=[e,Number(s[s.length-1]),t]}return r&&t.parseNodeNameCache.set(e,c),c}function i(e,t,r){let c=s("pad",e,t,r);if("explicit"===c){c=s("explicitPaddings",e,t,r);const n=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)n[e][0]=c[2*e],n[e][1]=c[2*e+1];return n}return c}function u(e){return e.kept?e:Object(b.Ae)(e)}r.d(t,"d",(function(){return s})),r.d(t,"e",(function(){return c})),r.d(t,"f",(function(){return n})),r.d(t,"b",(function(){return a})),r.d(t,"g",(function(){return o})),r.d(t,"c",(function(){return i})),r.d(t,"a",(function(){return u}));var b=r(616)},819:function(e,t,r){"use strict";function s(e,t){const r={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};a[e]=r}function c(e){return a[e]}function n(e){delete a[e]}r.d(t,"c",(function(){return s})),r.d(t,"b",(function(){return c})),r.d(t,"a",(function(){return n}));const a={}}}]);