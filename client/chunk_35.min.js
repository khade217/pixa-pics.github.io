/*! For license information please see chunk_35.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{1029:function(e,t,n){"use strict";var r=n(1226);n.d(t,"a",(function(){return r.a})),n.d(t,"b",(function(){return r.b})),n.d(t,"c",(function(){return r.c})),n.d(t,"d",(function(){return r.d})),n.d(t,"e",(function(){return r.e})),n.d(t,"f",(function(){return r.f})),n.d(t,"g",(function(){return r.g})),n.d(t,"h",(function(){return r.h})),n(1933)},1031:function(e,t,n){"use strict";var r,i,o,a,s;n.d(t,"a",(function(){return u})),r=n(616),i=n(825),o=n(896),a=n(692),s=n(674);class u{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Object(r.of)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,Object(i.b)(t,e)):this.gl=Object(i.a)(t),e=this.gl,2===Object(r.of)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>s.callAndCheck(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>s.callAndCheck(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>s.callAndCheck(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>s.callAndCheck(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>s.callAndCheck(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>s.callAndCheck(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>s.callAndCheck(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>s.callAndCheck(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const u="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Object(r.of)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=s.getExtensionOrThrow(this.gl,e),s.hasExtension(this.gl,t))this.textureHalfFloatExtension=s.getExtensionOrThrow(this.gl,t);else if(Object(r.of)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),s.hasExtension(this.gl,u))this.colorBufferHalfFloatExtension=s.getExtensionOrThrow(this.gl,u);else if(Object(r.of)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",s.hasExtension(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!s.hasExtension(this.gl,u))throw Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(u)}this.vertexBuffer=o.createVertexBuffer(this.gl),this.indexBuffer=o.createIndexBuffer(this.gl),this.framebuffer=s.createFramebuffer(this.gl),this.textureConfig=a.g(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(r.of)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;s.callAndCheck(e,(()=>e.finish())),s.callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),s.callAndCheck(e,(()=>e.deleteFramebuffer(this.framebuffer))),s.callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),s.callAndCheck(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),s.callAndCheck(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),o.createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),o.createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),o.createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),o.uploadPixelDataToTexture(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),o.uploadDenseMatrixToTexture(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),o.createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),o.createPackedMatrixTexture(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(s.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),s.callAndCheck(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>o.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,i,a){return o.downloadPackedMatrixFromBuffer(this.gl,e,t,n,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return o.downloadFloat32MatrixFromBuffer(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=o.createBufferFromOutputTexture(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Object(r.of)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(i,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=i}else Object(r.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Object(r.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>o.downloadMatrixFromPackedOutputTexture(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=o.createVertexShader(t));const n=s.createProgram(t);s.callAndCheck(t,(()=>t.attachShader(n,this.vertexShader))),s.callAndCheck(t,(()=>t.attachShader(n,e))),s.linkProgram(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&s.validateProgram(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;s.callAndCheck(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),o.bindVertexProgramAttributeStreams(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(s.callAndCheck(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&s.validateProgram(this.gl,this.program),s.callAndCheck(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?s.getProgramUniformLocationOrThrow(this.gl,e,t):s.getProgramUniformLocation(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),s.callAndCheck(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),s.bindTextureToProgramUniformSampler(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,i]=a.e(t,n);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&s.validateProgram(this.gl,this.program),s.validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}s.callAndCheck(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),s.callAndCheck(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=s.getExtensionOrThrow(this.gl,2===Object(r.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(r.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Object(r.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await r.Si.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,Object(r.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Object(r.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Object(r.of)().platform&&(n=Object(r.of)().platform.setTimeoutCustom.bind(Object(r.of)().platform)),r.Si.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),s.bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.debug&&s.validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(s.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&s.validateFramebuffer(this.gl)):s.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;s.bindColorTextureToFramebuffer(r,e,this.framebuffer),this.debug&&s.validateFramebuffer(r),this.outputTexture=e,s.callAndCheck(r,(()=>r.viewport(0,0,t,n))),s.callAndCheck(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),s.callAndCheck(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw Error("No GPU program is currently set.")}}},1923:function(e,t,n){"use strict";var r=n(616),i=n(674);const o=Object(r.of)();o.registerFlag("HAS_WEBGL",(()=>o.getNumber("WEBGL_VERSION")>0)),o.registerFlag("WEBGL_VERSION",(()=>Object(i.isWebGLVersionEnabled)(2)?2:Object(i.isWebGLVersionEnabled)(1)?1:0)),o.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),o.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===o.get("WEBGL_VERSION"))),o.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),o.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),o.registerFlag("WEBGL_PACK",(()=>o.getBool("HAS_WEBGL"))),o.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_CLIP",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_REDUCE",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_LAZILY_UNPACK",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_CONV_IM2COL",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>o.getBool("WEBGL_PACK"))),o.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>Object(i.getWebGLMaxTextureSize)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>Object(i.getMaxTexturesInShader)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=o.getNumber("WEBGL_VERSION");return 0===e?0:Object(i.getWebGLDisjointQueryTimerVersion)(e)})),o.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>o.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!r.Xe.isMobile())),o.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>Object(i.isCapableOfRenderingToFloatTexture)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!o.getBool("WEBGL_FORCE_F16_TEXTURES")&&o.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),o.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>Object(i.isDownloadFloatTextureEnabled)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>Object(i.isWebGLFenceEnabled)(o.getNumber("WEBGL_VERSION")))),o.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>o.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),o.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),o.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>r.Xe.isMobile()?1:-1),(e=>{if("number"!=typeof e)throw Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+e+".");if(e<0&&-1!==e)throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),o.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),o.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),o.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),o.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),o.registerFlag("WEBGL_EXP_CONV",(()=>!1)),o.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>o.getBool("IS_TEST"))),o.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),o.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),o.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),o.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1))},1925:function(e,t,n){"use strict";var r,i,o;n.d(t,"a",(function(){return s})),r=n(693),i=n(665),o=n(729);const a={R:0,G:1,B:2,A:3};class s{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Object(r.a)();this.outputShape=e,this.enableShapeUniforms=Object(i.e)(this.outputShape.length);let u="result";t&&(u="floor(result * 255. + 0.5)");let l="";for(let r=0;r<n.length;r++){const e=n[r];l+=`\n          if(offset == ${r}) {\n            result = values[${a[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?o.c():o.b(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${l}\n        }\n        ${s.output} = vec4(${u}, 0., 0., 0.);\n      }\n    `}}},1926:function(e,t,n){"use strict";var r,i,o;n.d(t,"a",(function(){return a})),r=n(693),i=n(729),o=n(692);class a{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=o.c.DOWNLOAD;const t=Object(r.a)();this.outputShape=e,this.userCode=`\n      ${i.a}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}},1927:function(e,t,n){"use strict";var r,i,o;n.d(t,"a",(function(){return a})),r=n(693),i=n(729),o=n(692);class a{constructor(e){this.variableNames=["A"],this.outTexUsage=o.c.DOWNLOAD;const t=Object(r.a)();this.outputShape=e,this.userCode=`\n      ${i.a}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}},1930:function(e,t,n){"use strict";var r,i,o,a;n.d(t,"a",(function(){return s})),r=n(693),i=n(665),o=n(729),a=n(692);class s{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=a.a.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Object(r.a)();this.outputShape=e,this.enableShapeUniforms=Object(i.e)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?o.f(["r","c","d"],e):o.d(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}},1931:function(e,t,n){"use strict";var r,i,o,a;n.d(t,"a",(function(){return s})),r=n(693),i=n(665),o=n(729),a=n(692);class s{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=a.a.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Object(r.a)();this.outputShape=e,this.enableShapeUniforms=Object(i.e)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?o.f(["r","c","d"],e):o.d(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}},1932:function(e,t,n){"use strict";var r,i,o;n.d(t,"a",(function(){return a})),r=n(693),i=n(665),o=n(729);class a{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Object(r.a)();this.outputShape=e,this.enableShapeUniforms=Object(i.e)(this.outputShape.length);let a="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let r=0;r<=1;r++)for(let t=0;t<=1;t++){const i=2*r+t;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":""+e[2]}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${r} < ${this.enableShapeUniforms?"outShape[1]":""+e[1]}) {\n            localCoords[1] += ${r};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${i}] = values[0];\n            } else if (offset == 1) {\n              result[${i}] = values[1];\n            } else if (offset == 2) {\n              result[${i}] = values[2];\n            } else {\n              result[${i}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?o.c():o.b(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${n.output} = ${s};\n        }\n    `}}},1983:function(e,t,n){"use strict";var r,i;n.d(t,"a",(function(){return o})),r=n(693),i=n(665);class o{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Object(i.e)(this.outputShape.length);const{dataFormat:n}=t,o=Object(r.a)(),a="channelsLast"===n,s=a?1:2,u=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let r=0;r<=1;r++)for(let e=0;e<=1;e++)c+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${r};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${u}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*r+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*r+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${o.output} = result;\n      }\n    `}}},1998:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}},2003:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}},2005:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:s,dilationHeight:u,dilationWidth:l}=e,{top:c,left:f}=r;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${c}, ${f});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${s}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}},2013:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,o=n?r+".0":"1.0";let a;if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}},2014:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}},2016:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}},2022:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n(651);class i{constructor(e,t,n,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=n;const o=Object(r.a)(n.length);let a="\n    int index;";for(let r=0;r<this.sliceDim;r++)a+=`\n          index = round(getIndices(coords[0], ${r}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[r]};\n          flattenIndex += index * ${this.strides[r]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}},2023:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n(651);class i{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Object(r.a)(this.rank),i=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e.length;i++)2===i?r.push("index"):r.push(""+n[i]);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}},665:function(e,t,n){"use strict";function r(e,t,n,r){const o=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=o.map((e=>e.shapeInfo)),s={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=c.c(o,s,t),h=Object(f.createFragmentShader)(e.gl,u),d=e.createProgram(h);return Object(l.of)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:h,source:u,webGLProgram:d,inShapeInfos:a,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(d),Object.assign({program:t,fragmentShader:h,source:u,webGLProgram:d,inShapeInfos:a,outShapeInfo:s},i(e,t,d)))}function i(e,t,n){const r=[],i=[];let o,a,s,u=null,c=null;c=e.getUniformLocation(n,"NAN",!1),1===Object(l.of)().getNumber("WEBGL_VERSION")&&(u=e.getUniformLocation(n,"INFINITY",!1));const f=!1;for(const l of t.variableNames){const i={name:l,uniform:e.getUniformLocation(n,l,f),offset:e.getUniformLocation(n,"offset"+l,f)};t.enableShapeUniforms&&(i.shape=e.getUniformLocation(n,l+"Shape",f),i.texShape=e.getUniformLocation(n,l+"TexShape",f)),r.push(i)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",f),s=e.getUniformLocation(n,"outShapeStrides",f),a=e.getUniformLocation(n,"outTexShape",f)),t.customUniforms)for(const l of t.customUniforms)i.push(e.getUniformLocation(n,l.name,f));return{variablesLocations:r,customUniformLocations:i,infLoc:u,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:a}}function o(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,i=t[n],o=i.shape;if(!l.Si.arraysEqual(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,s=i.isUniform?null:i.texData.texShape;if(!l.Si.arraysEqual(a,s))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${s} must match`)}))}function a(e,t,n,r,i){t.program.enableShapeUniforms||(o(t.inShapeInfos,n),o([t.outShapeInfo],[r]));const a=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,s[0],s[1]):e.setOutputMatrixTexture(a.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Object(l.of)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let o=0;o<n.length;++o){const r=n[o],{uniform:i,offset:a,shape:s,texShape:u}=t.variablesLocations[o];if(s){const{uniformShape:n}=c.b(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n))}}if(u&&e.gl.uniform2i(u,r.texData.texShape[0],r.texData.texShape[1]),null!=i)if(r.isUniform)if(l.Si.sizeFromShape(r.shape)<2)e.gl.uniform1f(i,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(i,t)}else null!=r.texData.slice&&null!=a&&e.gl.uniform1i(a,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,i,o)}const u=t.outShapeLocation;if(u)switch(r.shape.length){case 1:e.gl.uniform1iv(u,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(u,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(u,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(u,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=l.Si.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&i)for(let o=0;o<t.program.customUniforms.length;++o){const n=t.program.customUniforms[o],r=t.customUniformLocations[o],a=i[o];if("float"===n.type)e.gl.uniform1fv(r,a);else if("vec2"===n.type)e.gl.uniform2fv(r,a);else if("vec3"===n.type)e.gl.uniform3fv(r,a);else if("vec4"===n.type)e.gl.uniform4fv(r,a);else if("int"===n.type)e.gl.uniform1iv(r,a);else if("ivec2"===n.type)e.gl.uniform2iv(r,a);else if("ivec3"===n.type)e.gl.uniform3iv(r,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,a)}}e.executeProgram()}function s(e,t,n){let r="";t.concat(n).forEach((t=>{const i=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:a,uniformShape:s,keptDims:u}=c.b(e.packedInputs,t.shape,o);let f="",h="",d="";if(1===s.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];f=`${e[0]>1}_${e[1]>1}`}else if(2!==s.length||e.packedInputs){if(s.length>2&&!e.packedInputs){const e=l.Si.computeStrides(s);d=`${e[0]===o[1]}_${e[e.length-1]===o[1]}`}}else h=`${s[0]>1}_${s[1]>1}`;const g=t.shape.length,E=2===s.length&&l.Si.arraysEqual(t.shape,o),p=1===l.Si.sizeFromShape(t.shape),m=l.ie.getBroadcastDims(t.shape,n.shape),x=!e.packedInputs&&g===n.shape.length&&l.Si.arraysEqual(o,n.texData.texShape),_=e.packedInputs||s.length>2?"":`${o[0]>1}_${o[1]>1}`;r+=`${g}_${x}_${a?u:""}_${s.length}_${p}_${m}_${E}_${f}_${h}_${d}_${_}_${i}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${i}`}}));const i=e.userCode;let o=e.constructor.name;return o+="_"+r+"_"+i+Object(l.of)().getNumber("WEBGL_VERSION"),o}function u(e){return Object(l.of)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var l,c,f;n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return i})),n.d(t,"d",(function(){return a})),n.d(t,"c",(function(){return s})),n.d(t,"e",(function(){return u})),l=n(616),c=n(651),f=n(674)},693:function(e,t,n){"use strict";function r(){let e,t,n,r,o,a,s,u,l,c;return 2===Object(i.of)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",o="texture",a="outputColor",s="out vec4 outputColor;",u=Object(i.of)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",o="texture2D",a="gl_FragColor",s="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:o,output:a,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}n.d(t,"a",(function(){return r}));var i=n(616)},896:function(e,t,n){"use strict";function r(e){const t=Object(O.a)(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return L.createVertexShader(e,n)}function i(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return L.createStaticVertexBuffer(e,t)}function o(e){const t=new Uint16Array([0,1,2,2,1,3]);return L.createStaticIndexBuffer(e,t)}function a(e,t,n,r,i,o){L.validateTextureSize(t,n);const a=L.createTexture(e),s=e.TEXTURE_2D;return L.callAndCheck(e,(()=>e.bindTexture(s,a))),L.callAndCheck(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),L.callAndCheck(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),L.callAndCheck(e,(()=>e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST))),L.callAndCheck(e,(()=>e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Object(v.of)().getNumber("WEBGL_VERSION")?L.callAndCheck(e,(()=>e.texImage2D(s,0,r,t,n,0,i,o,null))):L.callAndCheck(e,(()=>e.texStorage2D(s,1,r,t,n))),L.callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:a,texShape:[n,t]}}function s(e){return e.internalFormatFloat}function u(e,t,n,r){const[i,o]=F.i(t,n);return a(e,i,o,s(r),r.textureFormatFloat,e.FLOAT)}function l(e){return e.internalFormatHalfFloat}function c(e,t,n,r){const[i,o]=F.i(t,n);return a(e,i,o,l(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function f(e){return e.downloadTextureFormat}function h(e,t,n,r){const[i,o]=F.i(t,n);return a(e,i,o,f(r),e.RGBA,e.UNSIGNED_BYTE)}function d(e){return e.internalFormatPackedFloat}function g(e,t,n,r){const[i,o]=F.e(t,n);return a(e,i,o,d(r),e.RGBA,e.FLOAT)}function E(e){return e.internalFormatPackedHalfFloat}function p(e,t,n,r){const[i,o]=F.e(t,n);return a(e,i,o,E(r),e.RGBA,r.textureTypeHalfFloat)}function m(e,t,n){return L.callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),L.bindVertexBufferToProgramAttribute(e,t,"clipSpacePos",n,3,20,0)&&L.bindVertexBufferToProgramAttribute(e,t,"uv",n,2,20,12)}function x(e,t,n,r,i,o){let a,s,u;L.callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),i instanceof Uint8Array?(a=new Uint8Array(n*r*4),s=e.UNSIGNED_BYTE,u=e.RGBA):(a=new Float32Array(n*r*4),s=e.FLOAT,u=o.internalFormatPackedFloat),a.set(i),2===Object(v.of)().getNumber("WEBGL_VERSION")?L.callAndCheck(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,s,a))):L.callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,s,a))),L.callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function _(e,t,n){L.callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Object(v.of)().getNumber("WEBGL_VERSION")?L.callAndCheck(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):L.callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Object(v.of)().getNumber("WEBGL_VERSION")?L.callAndCheck(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):L.callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),L.callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function T(e,t,n,r){const i=e.createBuffer();L.callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,i)));const o=16*t*n;return L.callAndCheck(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),L.callAndCheck(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),L.callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),i}function S(e,t,n){const r=e,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function b(e,t,n,r){const[i,o]=F.i(t,n),a=new Uint8Array(F.h(t*n,4));return L.callAndCheck(e,(()=>e.readPixels(0,0,i,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,a))),new Float32Array(a.buffer)}function I(e,t,n,r,i,o,a,s){const u=e,l=new Float32Array(F.f(o,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function A(e,t,n){const r=new Float32Array(t*n*4);return L.callAndCheck(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}var v,O,F,L;n.r(t),n.d(t,"createVertexShader",(function(){return r})),n.d(t,"createVertexBuffer",(function(){return i})),n.d(t,"createIndexBuffer",(function(){return o})),n.d(t,"getInternalFormatForFloat32MatrixTexture",(function(){return s})),n.d(t,"createFloat32MatrixTexture",(function(){return u})),n.d(t,"getInternalFormatForFloat16MatrixTexture",(function(){return l})),n.d(t,"createFloat16MatrixTexture",(function(){return c})),n.d(t,"getInternalFormatForUnsignedBytesMatrixTexture",(function(){return f})),n.d(t,"createUnsignedBytesMatrixTexture",(function(){return h})),n.d(t,"getInternalFormatForPackedMatrixTexture",(function(){return d})),n.d(t,"createPackedMatrixTexture",(function(){return g})),n.d(t,"getInternalFormatForFloat16PackedMatrixTexture",(function(){return E})),n.d(t,"createFloat16PackedMatrixTexture",(function(){return p})),n.d(t,"bindVertexProgramAttributeStreams",(function(){return m})),n.d(t,"uploadDenseMatrixToTexture",(function(){return x})),n.d(t,"uploadPixelDataToTexture",(function(){return _})),n.d(t,"createBufferFromOutputTexture",(function(){return T})),n.d(t,"downloadFloat32MatrixFromBuffer",(function(){return S})),n.d(t,"downloadByteEncodedFloatMatrixFromOutputTexture",(function(){return b})),n.d(t,"downloadPackedMatrixFromBuffer",(function(){return I})),n.d(t,"downloadMatrixFromPackedOutputTexture",(function(){return A})),v=n(616),O=n(693),F=n(692),L=n(674)}}]);