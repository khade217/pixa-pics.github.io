/*! For license information please see chunk_32.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{1166:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({stridedSlice_:function(e,t,n,c,i=0,u=0,o=0,p=0,b=0){const d={x:Object(a.a)(e,"x","stridedSlice","string_or_numeric")},h={begin:t,end:n,strides:c,beginMask:i,endMask:u,ellipsisMask:o,newAxisMask:p,shrinkAxisMask:b};return r.a.runKernel(s.fd,d,h)}})},1196:function(e,t,n){"use strict";function r(e,t,n=0){let r=[];if("number"==typeof t)Object(s.c)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Object(s.c)(a<=1,(()=>"There should be only one negative value in split array."));const c=t.indexOf(-1);if(-1!==c){const r=t.reduce(((e,t)=>t>0?e+t:e));t[c]=e.shape[n]-r}Object(s.c)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}n.d(t,"a",(function(){return r}));var s=n(661)},1197:function(e,t,n){"use strict";function r(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = "+e}function s(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function a(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return s})),n.d(t,"c",(function(){return a}))},1198:function(e,t,n){"use strict";function r(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function s(e,t){return`size ${e} must be non-negative, not ${t}`}function a(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function c(e,t){return`Input to reshape is a SparseTensor with ${Object(u.O)(e)}\n  dense values, but the requested shape requires a multiple of ${Object(u.O)(t)}. inputShape=${e} outputShape= ${t}`}function i(e,t){return`Input to reshape is a tensor with ${Object(u.O)(e)} dense values, but the requested shape has ${Object(u.O)(t)}. inputShape=${e} outputShape=${t}`}n.d(t,"d",(function(){return r})),n.d(t,"e",(function(){return s})),n.d(t,"a",(function(){return a})),n.d(t,"c",(function(){return c})),n.d(t,"b",(function(){return i}));var u=n(661)},1199:function(e,t,n){"use strict";function r(){return"segment ids must be >= 0"}function s(){return"segment ids are not increasing"}function a(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function c(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}n.d(t,"b",(function(){return r})),n.d(t,"c",(function(){return s})),n.d(t,"d",(function(){return a})),n.d(t,"a",(function(){return c}))},1284:function(e,t,n){"use strict";var r=n(620),s=n(617),a=n(619),c=n(661),i=n(618);n.d(t,"a",(function(){return u}));const u=Object(i.b)({sparseToDense_:function(e,t,n,i=0){Object(c.d)(n);const u=Object(a.a)(e,"sparseIndices","sparseToDense","int32"),o=Object(a.a)(t,"sparseValues","sparseToDense","string_or_numeric"),p=Object(a.a)(i,"defaultValue","sparseToDense",o.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const c=t.size;if(0!==t.rank&&(1!==t.rank||c!==s))throw Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype")}(u,o,n,p);const b={sparseIndices:u,sparseValues:o,defaultValue:p},d={outputShape:n};return r.a.runKernel(s.Yc,b,d)}})},1543:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({sparseFillEmptyRows_:function(e,t,n,c){const i=Object(a.a)(e,"indices","sparseFillEmptyRows","int32"),u=Object(a.a)(t,"values","sparseFillEmptyRows"),o=Object(a.a)(n,"denseShape","sparseFillEmptyRows","int32"),p=Object(a.a)(c,"defaultValue","sparseFillEmptyRows",u.dtype);if(2!==i.rank)throw Error("Indices should be Tensor2D but received shape\n        "+i.shape);if(1!==u.rank)throw Error("Values should be Tensor1D but received shape "+u.shape);if(1!==o.rank)throw Error("Dense shape should be Tensor1D but received shape "+o.shape);if(0!==p.rank)throw Error("Default value should be a scalar but received shape "+p.shape);const b={indices:i,values:u,denseShape:o,defaultValue:p},d=r.a.runKernel(s.Uc,b);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}})},1544:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({sparseReshape_:function(e,t,n){const c=Object(a.a)(e,"inputIndices","sparseReshape","int32"),i=Object(a.a)(t,"inputShape","sparseReshape","int32"),u=Object(a.a)(n,"newShape","sparseReshape","int32");if(2!==c.rank)throw Error("Input indices should be Tensor2D but received shape\n        "+c.shape);if(1!==i.rank)throw Error("Input shape should be Tensor1D but received shape "+i.shape);if(1!==u.rank)throw Error("New shape should be Tensor1D but received shape "+u.shape);const o={inputIndices:c,inputShape:i,newShape:u},p=r.a.runKernel(s.Vc,o);return{outputIndices:p[0],outputShape:p[1]}}})},1545:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({sparseSegmentMean_:function(e,t,n){const c=Object(a.a)(e,"data","sparseSegmentMean"),i=Object(a.a)(t,"indices","sparseSegmentMean","int32"),u=Object(a.a)(n,"segmentIds","sparseSegmentMean","int32");if(c.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw Error("Indices should be Tensor1D but received shape\n          "+i.shape);if(1!==u.rank)throw Error("Segment ids should be Tensor1D but received shape\n          "+u.shape);const o={data:c,indices:i,segmentIds:u};return r.a.runKernel(s.Wc,o)}})},1546:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({sparseSegmentSum_:function(e,t,n){const c=Object(a.a)(e,"data","sparseSegmentSum"),i=Object(a.a)(t,"indices","sparseSegmentSum","int32"),u=Object(a.a)(n,"segmentIds","sparseSegmentSum","int32");if(c.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw Error("Indices should be Tensor1D but received shape\n         "+i.shape);if(1!==u.rank)throw Error("Segment ids should be Tensor1D but received shape\n         "+u.shape);const o={data:c,indices:i,segmentIds:u};return r.a.runKernel(s.Xc,o)}})},1547:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({stringNGrams_:function(e,t,n,c,i,u,o,p){const b=Object(a.a)(e,"data","stringNGrams","string");if("string"!==b.dtype)throw Error("Data must be of datatype string");if(1!==b.shape.length)throw Error("Data must be a vector, saw: "+b.shape);const d=Object(a.a)(t,"dataSplits","stringNGrams");if("int32"!==d.dtype)throw Error("Data splits must be of datatype int32");const h={separator:n,nGramWidths:c,leftPad:i,rightPad:u,padWidth:o,preserveShortSequences:p},f={data:b,dataSplits:d},l=r.a.runKernel(s.gd,f,h);return{nGrams:l[0],nGramsSplits:l[1]}}})},1548:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({stringSplit_:function(e,t,n=!0){const c=Object(a.a)(e,"input","stringSplit","string"),i=Object(a.a)(t,"delimiter","stringSplit","string");if(1!==c.rank)throw Error("Input should be Tensor1D but received shape "+c.shape);if(0!==i.rank)throw Error("Delimiter should be a scalar but received shape "+i.shape);const u={skipEmpty:n},o={input:c,delimiter:i},p=r.a.runKernel(s.hd,o,u);return{indices:p[0],values:p[1],shape:p[2]}}})},1549:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({stringToHashBucketFast_:function(e,t){const n=Object(a.a)(e,"input","stringToHashBucketFast","string"),c={numBuckets:t};if(t<=0)throw Error("Number of buckets must be at least 1");const i={input:n};return r.a.runKernel(s.id,i,c)}})},1550:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({staticRegexReplace_:function(e,t,n,c=!0){const i=Object(a.a)(e,"input","staticRegexReplace","string"),u={pattern:t,rewrite:n,replaceGlobal:c};return r.a.runKernel(s.dd,{x:i},u)}})},653:function(e,t,n){"use strict";var r,s,a;n.d(t,"a",(function(){return c})),r=n(620),s=n(619),a=n(618);const c=Object(a.b)({square_:function(e){const t=Object(s.a)(e,"x","square");return r.a.runKernel("Square",{x:t},{})}})},687:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({sqrt_:function(e){const t={x:Object(a.a)(e,"x","sqrt","float32")};return r.a.runKernel(s.ad,t)}})},721:function(e,t,n){"use strict";var r,s,a,c,i;n.d(t,"a",(function(){return u})),r=n(620),s=n(617),a=n(619),c=n(661),i=n(618);const u=Object(i.b)({stack_:function(e,t=0){const n=Object(a.b)(e,"tensors","stack","string_or_numeric");c.c(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&c.c(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const i=n,u={axis:t};return r.a.runKernel(s.kc,i,u)}})},746:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({split_:function(e,t,n=0){const c={x:Object(a.a)(e,"x","split")},i={numOrSizeSplits:t,axis:n};return r.a.runKernel(s.Zc,c,i)}})},775:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(619),c=n(618);const i=Object(c.b)({step_:function(e,t=0){const n={x:Object(a.a)(e,"x","step")},c={alpha:t};return r.a.runKernel(s.ed,n,c)}})},810:function(e,t,n){"use strict";var r,s,a,c,i;n.d(t,"a",(function(){return u})),r=n(620),s=n(617),a=n(619),c=n(661),i=n(618);const u=Object(i.b)({spaceToBatchND_:function(e,t,n){const i=Object(a.a)(e,"x","spaceToBatchND");c.c(i.rank>=1+t.length,(()=>`input rank ${i.rank} should be > than [blockShape] ${t.length}`)),c.c(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),c.c(i.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const u={x:i},o={blockShape:t,paddings:n};return r.a.runKernel(s.Tc,u,o)}})},812:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(619),s=n(661),a=n(618),c=n(623);const i=Object(a.b)({squeeze_:function(e,t){const n=Object(r.a)(e,"x","squeeze","string_or_numeric");return Object(c.a)(n,Object(s.Q)(n.shape,t).newShape)}})},878:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(661),c=n(618);const i=Object(c.b)({fft_:function(e){Object(a.c)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.a.runKernel(s.hb,t)}})},879:function(e,t,n){"use strict";var r,s,a,c;n.d(t,"a",(function(){return i})),r=n(620),s=n(617),a=n(661),c=n(618);const i=Object(c.b)({ifft_:function(e){Object(a.c)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.a.runKernel(s.ub,t)}})},880:function(e,t,n){"use strict";var r,s,a,c,i,u,o,p,b,d,h,f;n.d(t,"a",(function(){return l})),r=n(661),s=n(716),a=n(680),c=n(805),i=n(618),u=n(811),o=n(623),p=n(673),b=n(746),d=n(773),h=n(640),f=n(878);const l=Object(i.b)({rfft_:function(e,t){Object(r.c)("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got "+e.dtype));let n=e.shape[e.shape.length-1];const i=e.size/n;let l;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,l=Object(p.a)(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,l=Object(a.a)([e,Object(d.a)(r)],e.shape.length-1),n=t}else l=e;const O=Object(h.a)(l),j=Object(o.a)(Object(s.a)(l,O),[i,n]),m=Object(f.a)(j),g=Math.floor(n/2)+1,v=Object(u.a)(m),S=Object(c.a)(m),k=Object(b.a)(v,[g,n-g],v.shape.length-1),w=Object(b.a)(S,[g,n-g],S.shape.length-1),y=l.shape.slice();return y[l.shape.length-1]=g,Object(o.a)(Object(s.a)(k[0],w[0]),y)}})},881:function(e,t,n){"use strict";var r,s,a,c,i,u;n.d(t,"a",(function(){return o})),r=n(620),s=n(617),a=n(643),c=n(619),i=n(637),u=n(618);const o=Object(u.b)({squaredDifference_:function(e,t){let n=Object(c.a)(e,"a","squaredDifference"),u=Object(c.a)(t,"b","squaredDifference");[n,u]=Object(a.makeTypesMatch)(n,u),Object(i.assertAndGetBroadcastShape)(n.shape,u.shape);const o={a:n,b:u};return r.a.runKernel(s.cd,o,{})}})},973:function(e,t,n){"use strict";var r,s,a,c,i,u,o,p,b,d,h;n.d(t,"a",(function(){return f})),r=n(716),s=n(680),a=n(805),c=n(625),i=n(618),u=n(811),o=n(623),p=n(705),b=n(639),d=n(673),h=n(879);const f=Object(i.b)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let i;if(t<=2){const r=Object(o.a)(e,[n,t]);i=Object(h.a)(r)}else{const f=[n,2*(t-1)],l=Object(o.a)(Object(u.a)(e),[n,t]),O=Object(o.a)(Object(a.a)(e),[n,t]),j=Object(p.a)(Object(d.a)(l,[0,1],[n,t-2]),1),m=Object(c.a)(Object(p.a)(Object(d.a)(O,[0,1],[n,t-2]),1),Object(b.a)(-1)),g=Object(s.a)([l,j],1),v=Object(s.a)([O,m],1),S=Object(o.a)(Object(r.a)(g,v),[f[0],f[1]]);i=Object(h.a)(S)}if(i=Object(u.a)(i),3===e.rank&&0!==e.shape[0]){const t=i,n=e.shape[0];i=Object(o.a)(i,[n,i.shape[0]/n,i.shape[1]]),t.dispose()}return i}})}}]);