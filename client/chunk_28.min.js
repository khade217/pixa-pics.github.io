/*! For license information please see chunk_28.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{1037:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(651);class i{constructor(n,t,e,i,a,s,u=!0,r=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const c=Object(o.a)(a.length),l=Object(o.a)(s.length);let d="";1===e?d="i":2===e&&(d="i, j");const f=`getIndices(${d})`;let h="";1===i?h="i":2===i&&(h="i, coords[1]");const x=`getUpdates(${h})`;let p="";r&&(p="coords[0], coords[1]");const C=`getDefaultValue(${p})`,$=t>1?"strides[j]":"strides";this.userCode=`\n        ${c} strides = ${c}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${f});\n              flattenedIndex += index * ${$};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${x};\n              found = true;\n            }\n          }\n          setOutput(mix(${C}, sum, float(found)));\n        }\n      `}}},1228:function(n,t,e){"use strict";var o,i;e.d(t,"a",(function(){return a})),o=e(665),i=e(729);class a{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=Object(o.e)(this.outputShape.length);let e="";for(let o=0;o<4;o++){let n="thisRC = rc;";o%2==1&&(n+="thisRC.z += 1;"),o>1&&(n+="thisRC.y += 1;"),e+=`\n        ${n}\n        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${o}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${o>0?"}":""}\n      `}var a,s;this.userCode=`\n      ${a=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?i.e(["r","c","d"],"inputShape"):i.d(["r","c","d"],a)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?i.c():i.b(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${e}\n\n        setOutput(result);\n      }\n    `}}},1232:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(665);class i{constructor(n,t,e,i=!1,a=!1,s=!1,u=null,r=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Object(o.e)(this.outputShape.length);const l=i?n[1]:n[2],d=Math.ceil(l/2),f=i?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",x=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let C="",$="";u&&(C=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${u}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${u}\n        }`:`vec4 activation(vec4 x) {\n          ${u}\n        }`,$="result = activation(result);");const v=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let g="rc.x",m="rc.x";n[0]<t[0]?g=`imod(rc.x, ${n[0]})`:t[0]<n[0]&&(m=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${C}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${g};\n        int batchB = ${m};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${f});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${x[0]} * ${p[0]});\n          result += (${x[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${v}\n\n        ${$}\n\n        setOutput(result);\n      }\n    `}}},1929:function(n,t,e){"use strict";var o,i,a;e.d(t,"a",(function(){return s})),o=e(665),i=e(698),a=e(651);class s{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=Object(o.e)(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=Object(i.a)("rc",this.rank),t=Object(a.a)(this.rank),e=this.getOutOfBoundsCondition(n),o=this.getSetup(n),s=this.getOutput(n);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${e}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const t=[];for(let e=0;e<=1;e++)for(let o=0;o<=1;o++){let i=`${0===e?"r":"rp1"}, ${0===o?"c":"cp1"}`;for(let t=2;t<this.rank;t++)i=n[n.length-1-t]+","+i;t.push(i)}return t}getOutOfBoundsCondition(n){if(1===this.rank)return"rc > "+(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let e=this.rank-2;e<this.rank;e++)t+=`${n[e]} >= ${this.enableShapeUniforms?`outShape[${e}]`:this.outputShape[e]}`,e<this.rank-1&&(t+="||");return t}getSetup(n){if(1===this.rank)return"";const t=n.slice(-2),e=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${e};\n      bool rEdge = rp1 >= ${o};\n    `}getOutput(n){const t=this.getSourceCoordsArr(n);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}},1933:function(n,t,e){"use strict";var o=e(616),i=e(1934),a=e(1940),s=e(1941),u=e(1942),r=e(1943),c=e(1944),l=e(1947),d=e(1948),f=e(1949),h=e(1952),x=e(1953),p=e(1954),C=e(1955),$=e(1956),v=e(1957),g=e(1958),m=e(1959),R=e(1960),b=e(1961),V=e(1962),I=e(1963),y=e(1966),O=e(1969),w=e(1970),S=e(1971),z=e(1972),N=e(1974),D=e(1975),A=e(730),F=e(1978),M=e(1282),j=e(1982),k=e(1984),L=e(1985),W=e(1987),X=e(1988),H=e(1989),U=e(1990),E=e(1991),B=e(1992),P=e(1994),G=e(1995),T=e(1996),Y=e(1997),q=e(1999),J=e(2e3),_=e(2001),K=e(2002),Q=e(2004),Z=e(2006),nn=e(2007),tn=e(2008),en=e(2009),on=e(2010),an=e(1242),sn=e(1243),un=e(2011),rn=e(2012),cn=e(828),ln=e(2015),dn=e(2017),fn=e(2018),hn=e(2263),xn=e(2019),pn=e(2020),Cn=e(2021),$n=e(1245),vn=e(2024),gn=e(2025),mn=e(686),Rn=e(2026),bn=e(897),Vn=e(2027),In=e(2028),yn=e(2029),On=e(1230),wn=e(2030),Sn=e(2031),zn=e(2032),Nn=e(2033),Dn=e(2034),An=e(2035),Fn=e(2036),Mn=e(2037),jn=e(2038),kn=e(2041),Ln=e(1283),Wn=e(2043),Xn=e(2044),Hn=e(2045),Un=e(2046),En=e(2047),Bn=e(2268),Pn=e(2269),Gn=e(2048),Tn=e(2049),Yn=e(2050),qn=e(2053),Jn=e(2054),_n=e(1034),Kn=e(2056),Qn=e(2057),Zn=e(2058),nt=e(2059),tt=e(1235),et=e(2060),ot=e(2062),it=e(2063),at=e(1251),st=e(2066),ut=e(1229),rt=e(2067),ct=e(2068),lt=e(2069),dt=e(2070),ft=e(1252),ht=e(827),xt=e(1249),pt=e(2071),Ct=e(2072),$t=e(2073),vt=e(636),gt=e(2074),mt=e(2077),Rt=e(2079),bt=e(2082),Vt=e(2084),It=e(2087),yt=e(2089),Ot=e(2090),wt=e(2091),St=e(2093),zt=e(2095),Nt=e(2097),Dt=e(2098),At=e(2099),Ft=e(2100),Mt=e(2101),jt=e(782),kt=e(1247),Lt=e(2102),Wt=e(2103),Xt=e(2104),Ht=e(2105),Ut=e(2106),Et=e(2107),Bt=e(2108),Pt=e(2109),Gt=e(2110),Tt=e(2111),Yt=e(2112),qt=e(2113),Jt=e(2114),_t=e(2115),Kt=e(2117),Qt=e(2118),Zt=e(2119),ne=e(1248),te=e(908),ee=e(2120),oe=e(2121),ie=e(2122),ae=e(1253),se=e(2124),ue=e(2126),re=e(684),ce=e(2128),le=e(2129),de=e(2130),fe=e(1250);const he=[i.a,a.a,s.a,u.a,r.a,c.a,l.a,d.a,f.a,h.a,x.a,p.a,C.a,$.a,v.a,g.a,m.a,R.a,b.a,V.a,I.a,y.a,O.a,w.a,S.a,z.a,N.a,D.a,A.b,F.a,M.b,j.a,k.a,L.a,W.a,X.a,H.a,U.a,E.a,B.a,P.a,G.a,T.a,Y.a,q.a,J.a,_.a,K.a,Q.a,Z.a,nn.a,tn.a,en.a,on.a,an.b,sn.b,un.a,rn.a,cn.b,ln.a,dn.a,fn.a,hn.a,xn.a,pn.a,Cn.a,$n.b,vn.a,gn.a,mn.b,Rn.a,bn.b,Vn.a,In.a,yn.a,On.c,wn.a,Sn.a,zn.a,Nn.a,Dn.a,An.a,Fn.a,Mn.a,jn.a,kn.a,Ln.b,Wn.a,Xn.a,Hn.a,Un.a,En.a,Bn.a,Pn.a,Gn.a,Tn.a,Yn.a,qn.a,Jn.a,_n.b,Kn.a,Qn.a,Zn.a,nt.a,tt.b,et.a,ot.a,it.a,at.b,st.a,ut.c,rt.a,ct.a,lt.a,dt.a,ft.b,ht.b,xt.b,pt.a,Ct.a,$t.a,vt.b,gt.a,mt.a,Rt.a,bt.a,Vt.a,It.a,yt.a,Ot.a,wt.a,St.a,zt.a,Nt.a,Dt.a,At.a,Ft.a,Mt.a,jt.b,kt.b,Lt.a,Wt.a,Xt.a,Ht.a,Ut.a,Et.a,Bt.a,Pt.a,Gt.a,Tt.a,Yt.a,qt.a,Jt.a,_t.a,Kt.a,Qt.a,Zt.a,ne.b,te.b,ee.a,oe.a,ie.a,ae.b,se.a,ue.a,re.b,ce.a,le.a,de.a,fe.b];for(const xe of he)Object(o.sh)(xe)},1938:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(616);class i{constructor(n,t){this.variableNames=["x"];const{windowSize:e,batchSize:i,inSize:a,outSize:s}=n;this.outputShape=[i,s];const u=4*Math.floor(e/4),r=e%4;let c="sumValue += dot(values, ones);";if(null!=t){const n=1/t;c=`sumValue += dot(values * ${o.Si.isInt(n)?n.toPrecision(2):n}, ones);`}let l="";a%e>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===r}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===r}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===r}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}},1939:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t){this.variableNames=["x"];const{windowSize:e,batchSize:o,inSize:i,outSize:a}=n;this.outputShape=[o,a];let s="0.0",u="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",u="min"):"max"===t&&(s="-1.0 / 1e-20",u="max");let r=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?r="sumValue":"prod"===t?r="prodValue":"all"===t?r="allValue":"any"===t&&(r="anyValue");const c=4*Math.floor(e/4),l=e%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${u}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${u}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let h="";i%e>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        vec4 minMaxValue = vec4(${s});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===l}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===l}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===l}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${r});\n      }\n    `}}},2051:function(n,t,e){"use strict";var o,i;e.d(t,"a",(function(){return a})),o=e(698),i=e(651);class a{constructor(n,t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const a=n.length,s=Object(i.a)(a),u=t.map((n=>n[0])).join(","),r=t.map(((t,e)=>t[0]+n[e])).join(","),c=Object(o.a)("rc",a),l=Object(o.a)("source",a),d=`${c[a-1]} < ${this.outputShape[a-1]}`,f=1===a?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===e?0:1;let x="";if(1===a){const n=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;x=`\n        ${s} rc = outputLoc;\n        ${n}\n        result[0] = getChannel(getX(${l.join()}), ${f});\n        ${c[a-1]} += 1;\n        if(${d}) {\n          ${n}\n          result[1] = getChannel(getX(${l.join()}), ${f});\n        }\n      `}else{const n=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;x=`\n        ${s} rc = outputLoc;\n        ${n}\n        result[0] = getChannel(getX(${l.join()}), ${f});\n        ${c[a-1]} += 1;\n        if(${d}) {\n          ${n}\n          result[1] = getChannel(getX(${l.join()}), ${f});\n        }\n        rc = outputLoc;\n        ${c[a-2]} += 1;\n        if(${c[a-2]} < ${this.outputShape[a-2]}) {\n          ${n}\n          result[2] = getChannel(getX(${l.join()}), ${f});\n          ${c[a-1]} += 1;\n          if(${d}) {\n            ${n}\n            result[3] = getChannel(getX(${l.join()}), ${f});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${u});\n      const ${s} end = ${s}(${r});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${x}\n        setOutput(result);\n      }\n    `}}},2052:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(651);class i{constructor(n,t,e){this.variableNames=["x"],this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const i=n.length,a=Object(o.a)(i),s=t.map((n=>n[0])).join(","),u=t.map(((t,e)=>t[0]+n[e])).join(","),r=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c="reflect"===e?0:1;this.userCode=1!==i?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${u});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${i}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${r}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${u};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}},2055:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}},2061:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e,o){this.variableNames=["indices"],this.outputShape=[n,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${o}), float(${e}),\n                      float(index == coords.y)));\n      }\n    `}}},2064:function(n,t,e){"use strict";var o,i;e.d(t,"a",(function(){return a})),o=e(698),i=e(651);class a{constructor(n,t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const a=n.length,s=Object(i.a)(a),u=t.map((n=>n[0])).join(","),r=t.map(((t,e)=>t[0]+n[e])).join(","),c=Object(o.a)("rc",a),l=Object(o.a)("source",a),d=`${c[a-1]} < ${this.outputShape[a-1]}`,f=1===a?"source":`vec2(${l.slice(-2).join()})`,h=[s+" rc = outputLoc;",`${c[a-1]} += 1;\n       if(${d}) {\n      `,1===a?"":`}\n       rc = outputLoc;\n       ${c[a-2]} += 1;\n       if(${c[a-2]} < ${this.outputShape[a-2]}) {`,1===a?"":`  ${c[a-1]} += 1;\n         if(${d}) {`],x=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let o=0,i=1===a?2:4;o<i;o++)p+=`\n        ${h[o]}\n        if (${x}) {\n          result[${o}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${o}] = getChannel(getX(${l.join()}), ${f});\n        }\n      `;p+=1===a?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${u});\n      const ${s} end = ${s}(${r});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}},2065:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(651);class i{constructor(n,t,e){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const i=n.length,a=Object(o.a)(i),s=t.map((n=>n[0])).join(","),u=t.map(((t,e)=>t[0]+n[e])).join(","),r=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${u});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${r}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${u};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}},2075:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,s,u,r]=n;this.outputShape=[a,t,e,r];const c=[o&&t>1?s-1:s,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e];let d;d=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]},\n          ${c[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${r-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}},2076:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.outputShape=[];const[a,s,u,r]=n;this.outputShape=[a,t,e,r];const c=[o&&t>1?s-1:s,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e];let d;d=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}},2078:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,o,i]=t,[,a,s]=n,u=[e&&a>1?o-1:o,e&&s>1?i-1:i],r=[e&&a>1?a-1:a,e&&s>1?s-1:s],c=u[0]/r[0],l=u[1]/r[1],d=1/c,f=1/l,h=2*Math.ceil(d)+2,x=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${x});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}},2080:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,s,u,r]=n;this.outputShape=[a,t,e,r];const c=[o&&t>1?s-1:s,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e],d=o?"0.5":"0.0";let f;f=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]},\n          ${c[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${r-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}},2081:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.outputShape=[];const[a,s,u,r]=n;this.outputShape=[a,t,e,r];const c=[o&&t>1?s-1:s,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e],d=o?"0.5":"0.0";let f;f=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}},2083:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t,e){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,o,i]=t,[,a,s]=n,u=[e&&a>1?o-1:o,e&&s>1?i-1:i],r=[e&&a>1?a-1:a,e&&s>1?s-1:s],c=u[0]/r[0],l=u[1]/r[1],d=1/c,f=1/l,h=2*Math.ceil(d)+2,x=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${x});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${u[0]}) *\n                (float(dyR) / float(${r[0]}));\n\n            float sourceFracCol =\n                float(${u[1]}) *\n                  (float(dyC) / float(${r[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${o}) - 1),\n                ${e} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${e} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}},2085:function(n,t,e){"use strict";var o,i;e.d(t,"a",(function(){return a})),o=e(698),i=e(651);class a{constructor(n,t){function e(e){const o=n.map(((o,i)=>function(e,o){return-1!==t.indexOf(e)&&1!==n[e]?`${n[e]} - ${o[e]} - 1`:""+o[e]}(i,e)));return`getChannel(getX(${o.join(",")}), vec2(${o.slice(-2).join(",")}))`}this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const a=n.length;if(a>4)throw Error(`WebGL backend: Reverse of rank-${a} tensor is not yet supported`);this.outputShape=n;const s=Object(o.a)("rc",a),u=`${s[a-1]} + 1 < ${this.outputShape[a-1]}`,r=`${s[a-2]} + 1 < ${this.outputShape[a-2]}`,c=Object(i.a)(a);this.userCode=1===a?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${u}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${c} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(n){return e(n)}(s.slice())};\n          if(${u}){\n            result.g = ${function(n){return n[a-1]="("+n[a-1]+" + 1)",e(n)}(s.slice())};\n          }\n          if(${r}) {\n            result.b = ${function(n){return n[a-2]="("+n[a-2]+" + 1)",e(n)}(s.slice())};\n            if(${u}) {\n              result.a = ${function(n){return n[a-1]="("+n[a-1]+" + 1)",n[a-2]="("+n[a-2]+" + 1)",e(n)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}},2086:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(651);class i{constructor(n,t){this.variableNames=["x"];const e=n.length;if(e>4)throw Error(`WebGL backend: Reverse of rank-${e} tensor is not yet supported`);if(this.outputShape=n,1===e)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const i=n.map(((e,o)=>(e=>-1!==t.indexOf(e)&&1!==n[e]?`${n[e]} - coords[${e}] - 1`:`coords[${e}]`)(o))).join(","),a=Object(o.a)(e);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}},2088:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const e=n[1],o=n[2];this.outputShape=n;let i="";i="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${e}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}},2092:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(651);class i{constructor(n,t,e,i,a,s,u=!0,r=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const c=Object(o.a)(a.length),l=Object(o.a)(s.length);let d="";1===e?d="i":2===e&&(d="i, j");const f=`getIndices(${d})`;let h="";1===i?h="i":2===i&&(h="i, coords[1]");const x=`getUpdates(${h})`;let p="";r&&(p="coords[0], coords[1]");const C=`getDefaultValue(${p})`,$=t>1?"strides[j]":"strides",v=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${c} strides = ${c}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${f});\n              flattenedIndex += index.xz * ${$};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${v};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${x};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${C}, sum, found));\n        }\n      `}}},2094:function(n,t,e){"use strict";e.d(t,"a",(function(){return i}));var o=e(616);class i{constructor(n,t,e,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,e];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===Object(o.of)().getNumber("WEBGL_VERSION")?"while (left < right) {":a,u="left"===i?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${u} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}},2131:function(n,t,e){"use strict";e.d(t,"a",(function(){return o}));class o{constructor(n,t){this.variableNames=["x","segmentIds"];const e=n.windowSize,o=n.batchSize,i=n.inSize,a=n.numSegments,s=a*Math.ceil(i/e);this.outputShape=[o,s];const u=4*Math.floor(e/4),r=e%4,c="\n        sumValue += dot(values, segFilter);\n    ";let l="";i%e>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let d="";i%e>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${e}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===r}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===r}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===r}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}},698:function(n,t,e){"use strict";function o(n,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${n}.${t}`))}function i(n,t){return 1===t?[n]:o(n,t)}function a(n,t){if(1===n)return"rc";let e="";for(let o=0;o<n;o++)e+=t[o],o<n-1&&(e+=",");return e}e.d(t,"c",(function(){return o})),e.d(t,"a",(function(){return i})),e.d(t,"b",(function(){return a}))},755:function(n,t,e){"use strict";e.d(t,"a",(function(){return o})),e.d(t,"b",(function(){return i}));class o{constructor(n,t,e,o=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&e)throw Error("Cannot compute positions for average pool.");const a=n.filterWidth,s=n.strideHeight,u=n.strideWidth,r=n.dilationHeight,c=n.dilationWidth,l=n.effectiveFilterHeight,d=n.effectiveFilterWidth,f=n.padInfo.top,h=n.padInfo.left;this.outputShape=n.outShape;const x="avg"===t,p=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,C=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`;let $="0.0";if(x||($="-1.0 / 1e-20"),e){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${s}, ${u});\n        const ivec2 pads = ivec2(${f}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${r}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${o?i?p:C:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");const g=4*Math.floor(a/4),m=a%4,R=`\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${u});\n      const ivec2 pads = ivec2(${f}, ${h});\n      const float initializationValue = ${$};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${$});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${r}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${g}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${R}\n          }\n\n          int xC = xCCorner + ${g};\n          if (${1===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${2===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${3===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${R}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class i{constructor(n,t,e,o=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&e)throw Error("Cannot compute positions for average pool.");const a=n.filterWidth,s=n.strideDepth,u=n.strideHeight,r=n.strideWidth,c=n.dilationDepth,l=n.dilationHeight,d=n.dilationWidth,f=n.effectiveFilterDepth,h=n.effectiveFilterHeight,x=n.effectiveFilterWidth,p=n.padInfo.front,C=n.padInfo.top,$=n.padInfo.left;this.outputShape=n.outShape;const v="avg"===t;let g="0.0";if(v||(g="-1.0 / 1e-20"),e){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${s}, ${u}, ${r});\n        const ivec3 pads = ivec3(${p}, ${C}, ${$});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${x};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${o?i?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${h} * ${x} +\n                      wR * ${x} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let m=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(m="avgValue / max(count, 1.0)");const R=4*Math.floor(a/4),b=a%4,V=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${s}, ${u}, ${r});\n      const ivec3 pads = ivec3(${p}, ${C}, ${$});\n      const float initializationValue = ${g};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${g});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${R}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${V}\n            }\n\n            int xC = xCCorner + ${R};\n            if (${1===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${V}\n            } else if (${2===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${V}\n            } else if (${3===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${V}\n            }\n          }\n        }\n        setOutput(${m});\n      }\n    `}}}}]);