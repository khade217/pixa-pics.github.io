/*! For license information please see chunk_73.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{1747:function(t,e,s){"use strict";var n,o,i,a,r,u,l,h,c,d,p,f;s.d(e,"a",(function(){return y})),n=s(616),o=s(816),i=s(633),a=s(818),r=s(648),u=s(983),l=s(654),h=s(817),c=s(886),d=s(982),p=s(815),f=s(642);class y extends f.b{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=Object(o.b)(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],r.q(this.inputs).length!==this.inputs.length)throw new i.e("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+this.inputs.map((t=>t.name)));r.q(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+this.outputs.map((t=>t.name))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const o of this.outputs){const t=o.sourceLayer,e=o.nodeIndex,s=o.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(s)}for(const o of this.inputs){const t=o.sourceLayer,e=o.nodeIndex,s=o.tensorIndex;r.a(0===e,"input layer has >1 nodes"),r.a(0===s,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(s)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let o=0;o<this.inputLayers.length;o++){const e=this.inputLayers[o];if(!(e instanceof p.b))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${o} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const o of this.outputLayers)this.outputNames.push(o.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},s={},n={},a={},u={},l=[],h=(t,e,s,n,o,a)=>{null!=n&&null!=o&&null!=a||(n=t.sourceLayer,o=t.nodeIndex,a=t.tensorIndex);const r=n.inboundNodes[o];if(-1!==s.indexOf(r))throw new i.d(`The tensor ${t.name} at layer "${n.name}" is part of a cycle.`);if(-1!==e.indexOf(r))return;this.containerNodes.add(y.nodeKey(n,o)),n.id in u||(u[n.id]=Object.keys(u).length),-1===s.indexOf(r)&&s.push(r);const c=r.inboundLayers.length;for(let i=0;i<c;i++){const t=r.inputTensors[i],n=r.inboundLayers[i],o=r.nodeIndices[i],a=r.tensorIndices[i];h(t,e,s,n,o,a)}for(e.push(r);s.indexOf(r)>=0;)s.splice(s.indexOf(r),1);l.push(r)},c=[],d=[];for(const o of this.outputs)h(o,c,d);const m=l.slice().reverse();for(const o of m){s[o.id]=o,o.id in e||(e[o.id]=0);let t=e[o.id];const i=null==n[o.outboundLayer.id]?0:n[o.outboundLayer.id];t=Math.max(t,i),n[o.outboundLayer.id]=t,a[o.outboundLayer.id]=o.outboundLayer,e[o.id]=t;for(let n=0;n<o.inboundLayers.length;n++){const i=o.inboundLayers[n],a=o.nodeIndices[n],r=i.inboundNodes[a],u=null==e[r.id]?0:e[r.id];e[r.id]=Math.max(t+1,u),s[r.id]=r}}const g={};for(const o in e){const t=e[o];t in g||(g[t]=[]),g[t].push(s[o])}const b={};for(const o in n){const t=n[o];t in b||(b[t]=[]),b[t].push(a[o])}let w=Object.keys(b).map((t=>parseInt(t,10))).sort(r.k);this.layers=[];for(const o of w){const t=b[o];t.sort(((t,e)=>{const s=u[t.id],n=u[e.id];return s<n?-1:s>n?1:0}));for(const e of t)e instanceof y&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=b,w=Object.keys(g).map((t=>parseInt(t,10))).sort(r.k);const L=this.inputs.slice(),N=[];for(const o of w)for(const t of g[o]){const e=t.outboundLayer;if(null!=e){for(const s of t.inputTensors)if(-1===L.indexOf(s))throw new i.d("Graph disconnected: cannot obtain value for tensor "+s+` at layer "${e.name}". The following previous layers were accessed without issue: `+N);for(const e of t.outputTensors)L.push(e);N.push(e.name)}}this.nodesByDepth=g;const I=this.layers.map((t=>t.name));for(const o of I){const t=I.filter((t=>t===o)).length;if(1!==t)throw new i.d(`The name "${o}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(I))}this.outboundNodes=[],this.inboundNodes=[],new f.c({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new i.e("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let n=0;const o=(t=>{const e=Object.keys(t);if(0===e.length)return!1;const s=e[0].split("/");return!isNaN(parseInt(s[s.length-1],10))})(t);o&&this.parseWeights(t);for(const r of this.layers)for(const[t,e]of r.weights.entries()){const a=o?`${e.name.split("/").slice(0,-1).join("/")+"/"}${t}`:e.originalName;if(null!=s[a])throw new i.e("Duplicate weight name: "+a);s[a]=e,n++}const a=[];for(const r in t){let n=r;if(null==s[r]){const t=r.split("/");n=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=s[n])a.push([s[n],t[r]]);else if(e)throw new i.e("Provided weight data has no target variable: "+r);delete s[n]}if(e){const t=[];for(const e in s)t.push(e);if(t.length>0)throw new i.e(`${t.length} of ${n} weights are not set: `+t)}Object(h.c)(a)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),n=["vars","layer_checkpoint_dependencies"],o=s.map((t=>t.startsWith("_")?t.slice(1):t)).filter((t=>!n.includes(t))).join("/");o!==e&&(t[o]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers "+c.a,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=Object(u.b)(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return Object(n.Ei)((()=>{t=r.o(t);const s=new d.a;for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e]);return Object(d.b)(this.outputs,s,e)}))}computeMask(t,e){return Object(n.Ei)((()=>{let s;return t=r.o(t),s=null==e?r.j(null,t.length):r.o(e),this.runInternalGraph(t,s)[1]}))}computeOutputShape(t){const e=l.d(t);if(e.length!==this.inputLayers.length)throw new i.e(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let i=0;i<e.length;i++){const t=this.inputLayers[i],n=e[i];s[t.name+"_0_0"]=n}const n=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(r.k);if(n.length>1)for(const i of n){const t=this.nodesByDepth[i];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const n=[];for(let r=0;r<e.inboundLayers.length;r++){const t=e.inboundLayers[r],o=e.nodeIndices[r],i=e.tensorIndices[r],a=s[`${t.name}_${o}_${i}`];n.push(a)}const o=t.computeOutputShape(r.m(n)),i=l.d(o),a=t.inboundNodes.indexOf(e);for(let e=0;e<i.length;e++)s[`${t.name}_${a}_${e}`]=i[e]}}const o=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const t=this.outputLayers[i],e=this.outputLayersNodeIndices[i],s=this.outputLayersTensorIndices[i],n=`${t.name}_${e}_${s}`;a.push(n)}for(let i=0;i<a.length;i++){const t=a[i];r.a(t in s),o.push(s[t])}return r.m(o)}runInternalGraph(t,e){null==e&&(e=r.j(null,t.length));const s={};for(let i=0;i<this.inputs.length;++i){const n=this.inputs[i],o=t[i],a=e[i];s[n.id]=[o,a]}const n=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(r.k);for(const l of n){const t=this.nodesByDepth[l];for(const e of t){const t=e.outboundLayer,n=e.inputTensors,o=e.outputTensors,a=[];for(const e of n)e.id in s&&a.push(s[e.id]);if(a.length===n.length){let n,u,l,h,c={};if(null!=e.callArgs&&(c=e.callArgs),1===a.length){const[e,s]=a[0];null==c.mask&&(c.mask=s),l=r.o(t.call(e,c)),h=r.o(t.computeMask(e,s)),n=[e],u=[s]}else n=a.map((t=>t[0])),u=a.map((t=>t[1])),null==c.mask&&(c.mask=u),l=r.o(t.call(n,c)),h=r.o(t.computeMask(n,u));if(t.activityRegularizer)throw new i.c("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<o.length;++t){const e=o[t],n=l[t],i=h[t];s[e.id]=[n,i]}}}}const o=[],a=[],u=[];for(const i of this.outputs){r.a(i.id in s,`Could not compute output ${i.name} : ${i.id}`);const[t,e]=s[i.id];u.push(t.shape),o.push(t),a.push(e)}return[o,a,u]}buildNodeConversionMap(t){const e={};let s;for(const n of this.layers){s=n instanceof y?1:0;for(let t=0;t<n.inboundNodes.length;t++){const o=y.nodeKey(n,t);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new i.e("Provide either a layer name or layer index");if("number"==typeof t)return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new i.e("No such layer: "+t)}findLayer(t){if(this.layers.length<=t)throw new i.e(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return Object(n.Ei)((()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const n=y.nodeKey(e,s);this.containerNodes.has(n)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const t=a.getClassName(),n=a.getConfig(),o=[];for(let s=0;s<a.inboundNodes.length;s++){const t=a.inboundNodes[s],n=y.nodeKey(a,s);let r={};if(this.containerNodes.has(n)){if(t.callArgs)try{JSON.stringify(t.callArgs),r=t.callArgs}catch(i){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: `+t.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),r={}}if(t.inboundLayers.length>0){const s=[];for(let n=0;n<t.inboundLayers.length;n++){const o=t.inboundLayers[n],i=t.nodeIndices[n],a=t.tensorIndices[n];let u=e[y.nodeKey(o,i)];null==u&&(u=0),s.push([o.name,u,a,r])}o.push(s)}}}const r={};r.name=a.name,r.className=t,r.config=n,r.inboundNodes=o,s.push(r)}t.layers=s;const n=[];for(let a=0;a<this.inputLayers.length;a++){const t=this.inputLayers[a],s=this.inputLayersNodeIndices[a],o=y.nodeKey(t,s);if(!this.containerNodes.has(o))continue;let i=e[o];null==i&&(i=0);const r=this.inputLayersTensorIndices[a];n.push([t.name,i,r])}t.inputLayers=n;const o=[];for(let a=0;a<this.outputLayers.length;a++){const t=this.outputLayers[a],s=this.outputLayersNodeIndices[a],n=y.nodeKey(t,s);if(!this.containerNodes.has(n))continue;let i=e[n];null==i&&(i=0);const r=this.outputLayersTensorIndices[a];o.push([t.name,i,r])}return t.outputLayers=o,t}static fromConfig(t,e,s={},n=!1){function o(t,e){t.name in c?c[t.name].push(e):c[t.name]=[e]}function u(t,e){const s=[];let n;for(const i of e){const a=i[0],r=i[1],u=i[2];if(n=null==i[3]?{}:i[3],!(a in h))return void o(t,e);const l=h[a];if(l.inboundNodes.length<=r)return void o(t,e);const c=l.inboundNodes[r];s.push(c.outputTensors[u])}s.length>0&&t.apply(r.m(s),n)}function l(t){const s=t.name,r=Object(a.a)(t,null!=e.customObjects?e.customObjects:{});r.setFastWeightInitDuringBuild(n),h[s]=r,t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new i.e("Corrupted configuration, expected array for nodeData: "+t);o(r,t)}))}const h={},c={},d=e.name,p=e.layers;for(const i of p)l(i);for(;!r.h(c);)for(const t of p){const e=h[t.name];if(e.name in c){const t=c[e.name];delete c[e.name];for(const s of t)u(e,s)}}const f=[],y=[],m=e.inputLayers;for(const i of m){const t=i[0],e=i[1],s=i[2];r.a(t in h);const n=h[t].inboundNodes[e].outputTensors;f.push(n[s])}const g=e.outputLayers;for(const i of g){const t=i[0],e=i[1],s=i[2];r.a(t in h);const n=h[t].inboundNodes[e].outputTensors;y.push(n[s])}return new t({inputs:f,outputs:y,name:d})}get stateful(){if(this._stateful)throw new i.e("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Object(n.Ei)((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}},1763:function(t,e,s){"use strict";var n,o;s.d(e,"a",(function(){return i})),n=s(642),o=s(1764);class i extends n.b{constructor(t){super(t),this.randomGenerator=new o.a(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}i.className="BaseRandomLayer"},982:function(t,e,s){"use strict";function n(t){null!=y&&y.setMaxEntries(t),null!=m&&m.setMaxEntries(t)}function o(t,e,s,n){const o=null!=s&&s.training,l=Array.isArray(t),h=l?t:[t],p=h.map((t=>t.name)),g=[],b=e.names();for(const i of p)-1!==b.indexOf(i)?g.push(e.getValue(i)):g.push(null);null!=n&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);const w=p.join(",")+"|"+e.names().sort().join(",");let L,N=y.get(w);if(null==N){const t=function(t,e){u.Si.assert(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let s=[],n={};if(1===t.length){const o=a(t[0],e);s=o.sorted,n=o.recipientMap}else{const o=new Set;for(const i of t){const{sorted:t,recipientMap:r}=a(i,e);for(const e of t)o.has(e.name)||(s.push(e),o.add(e.name));for(const e in r)null==n[e]&&(n[e]=new Set),r[e].forEach((t=>n[e].add(t)))}}return{sorted:s,recipientCounts:i(n)}}(h,e);N=t.sorted,L=t.recipientCounts,y.put(w,N),m.put(w,L)}L={},o||Object.assign(L,m.get(w));const I=new f(e);for(let i=0;i<N.length;++i){if(null!=n){const t=Object(u.yg)().numTensors;t>n.maxNumTensors&&(n.maxNumTensors=t),t<n.minNumTensors&&(n.minNumTensors=t)}const t=N[i],a=t.sourceLayer;if(a instanceof d.b)continue;const l=[],h=[],f=[];let y=!1;for(const s of t.inputs){const t=I.getValue(s),n=I.getMask(s);l.push(t),h.push(n),null!=n&&(y=!0),o||(L[s.name]--,0!==L[s.name]||e.hasKey(s)||-1!==p.indexOf(s.name)||t.isDisposed||!0===s.sourceLayer.stateful||f.push(t))}y&&((s=s||{}).mask=h[0]);const m=Object(c.o)(a.apply(l,s));let b=null;a.supportsMasking&&(b=a.computeMask(l,h));const w=r(t),k=Array.isArray(w)?w:[w];for(let e=0;e<k.length;++e){I.hasKey(k[e])||I.add(k[e],m[e],Array.isArray(b)?b[0]:b);const t=p.indexOf(k[e].name);-1!==t&&(g[t]=m[e])}o||Object(u.bf)(f)}return I.disposeMasks(),l?g:g[0]}function i(t){const e={};for(const s in t)e[s]=t[s].size;return e}function a(t,e){const s=new Set,n=[],o={};for(const r of e.names())s.add(r);const i=[],a=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(s.has(t.name)){i.pop();continue}const e=a[a.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),n.push(t),s.add(t.name),e&&a.pop();else{a.push(i.length-1);for(const e of t.inputs)null==o[e.name]&&(o[e.name]=new Set),o[e.name].add(t.name),s.has(e.name)||i.push(e)}}return{sorted:n,recipientMap:o}}function r(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let s=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const n of t.sourceLayer.inboundNodes[e].outputTensors)if(n.id===t.id){s=e;break}e=t.sourceLayer.getOutputAt(s)}return e}var u,l,h,c,d,p;s.d(e,"a",(function(){return f})),s.d(e,"c",(function(){return n})),s.d(e,"b",(function(){return o})),u=s(616),l=s(633),h=s(1743),c=s(648),d=s(815),p=s(642);class f{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof f)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(null!=this.id2Value[t.id])throw new l.e(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return Object(u.xe)(e,t.dtype)}catch(s){throw new l.e(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=s&&(this.id2Mask[t.id]=s),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof p.d){if(null==this.id2Value[t.id])throw new l.e("Nonexistent key: "+t.name);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new l.e("Feed dict has no SymbolicTensor name: "+t);return this.id2Value[e]}}getMask(t){if(t instanceof p.d){if(null==this.id2Value[t.id])throw new l.e("Nonexistent key: "+t.name);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new l.e("Feed dict has no SymbolicTensor name: "+t);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Object(u.bf)(this.id2Mask)}}const y=new h.a,m=new h.a}}]);