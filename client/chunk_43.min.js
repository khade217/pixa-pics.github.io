/*! For license information please see chunk_43.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{1030:function(e,t,n){"use strict";var a,s,o,i,r,u,c,d,l,h,p,f,g,m,b,x,O,y,C;n.d(t,"a",(function(){return w})),n(1923),a=n(616),s=n(825),o=n(1931),i=n(1930),r=n(1927),u=n(1926),c=n(1925),d=n(1932),l=n(1031),h=n(665),p=n(628),f=n(1929),g=n(1228),m=n(692),b=n(1924),x=n(667),O=n(781),y=n(1928),C=n(674);const v=a.Yf.whereImpl,I={},S=Object(a.of)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class w extends a.Hb{nextDataId(){return w.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(a.of)().getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof l.a)t=e;else{const n=Object(s.a)(Object(a.of)().getNumber("WEBGL_VERSION"),e);t=new l.a(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=Object(s.a)(Object(a.of)().getNumber("WEBGL_VERSION"));t=new l.a(e),this.binaryCache=((n=Object(a.of)().getNumber("WEBGL_VERSION"))in I||(I[n]={}),I[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new b.a(this.gpgpu),this.numMBBeforeWarning=null==Object(a.of)().global.screen?1024:Object(a.of)().global.screen.height*Object(a.of)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new a.T(this,Object(a.mf)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,s,o){const i=this.makeTensorInfo(t,n),r=this.texData.get(i.dataId);r.isPacked=!1,r.texture={texture:e,texShape:[a,s]},r.texShape=[a,s];const u=C.getShapeAs3D(t),d=new c.a(u,!1,o),l=this.runWebGLProgram(d,[i],n,[[a,s]]);return l.shape=t,r.texture=null,this.disposeIntermediateTensorInfo(i),l.dataId}write(e,t,n){if((Object(a.of)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(a.of)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:n,values:e,usage:m.c.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,s,o){if(Object(a.of)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===s)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:s,values:t,usage:m.c.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:s,complexTensorInfos:o,slice:i,shape:r,isPacked:u}=t;if(null!=i){let t;t=u?new O.f(r,x.c):new x.i(r,x.c);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;const c=null!=this.activeTimers;let d,l;if(c&&(d=a.Si.now()),"complex64"===s){const e=this.readSync(o.real.dataId),t=this.readSync(o.imag.dataId);l=a.ie.mergeRealAndImagArrays(e,t)}else l=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=a.Si.now()-d),this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:s,slice:o,dtype:i,complexTensorInfos:r,isPacked:u}=t;if(null!=o){let t;t=u?new O.f(s,x.c):new x.i(s,x.c);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:i}],i),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(Object(a.of)().getBool("DEBUG")&&!Object(a.of)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(a.of)().getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,d,l=null;if("complex64"!==i&&Object(a.of)().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(t.texture.texture,...m.d(s))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const e=await Promise.all([this.read(r.real.dataId),this.read(r.imag.dataId)]),t=e[0],n=e[1];d=a.ie.mergeRealAndImagArrays(t,n)}else if(null==l)d=this.getValuesFromTexture(e);else{const e=a.Si.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(l,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=l){const e=this.gpgpu.gl;C.callAndCheck(e,(()=>e.deleteBuffer(l)))}const h=this.convertAndCacheOnCPU(e,d),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Object(a.mf)().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const n=this.texData.get(e),{values:s,shape:o,slice:i,dtype:r,isPacked:u,texture:c}=n;if("complex64"===r)throw Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=u?new O.f(o,x.c):new x.i(o,x.c);const a=this.runWebGLProgram(n,[{dataId:e,shape:o,dtype:r}],r),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==c)throw Error(null!=s?"Data is not on GPU but on CPU.":"There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),l=Object(a.mf)().makeTensorFromTensorInfo(d),h=this.texData.get(d.dataId);return Object.assign({tensorRef:l},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>a.Si.decodeString(e)));return Object(a.we)(e.shape,e.dtype,n)}catch(n){throw Error("Failed to decode encoded string bytes into utf-8")}return Object(a.we)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!C.canBeRepresented(n)){if(Object(a.of)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:s}=this.texData.get(e),o=a.Si.sizeFromShape(t);if(Object(a.of)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...m.d(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(n),s}const i=Object(a.of)().getBool("WEBGL_PACK")&&!0===s,c=i?C.getShapeAs3D(t):t,d=i?new u.a(c):new r.a(c),l=this.runWebGLProgram(d,[{shape:c,dtype:n,dataId:e}],"float32"),h=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return Object(a.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const o=a.Si.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=a.Si.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const r={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Object(a.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);r.kernelMs=a.Si.sum(e),r.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else r.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,r})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(a.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:a.Si.now(),endMs:null}}endTimer(e){return Object(a.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=a.Si.now(),e)}async getQueryTime(e){if(Object(a.of)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:s,isPacked:o,slice:i}=this.texData.get(e),r=i&&i.origDataId||e,u=this.dataRefCount.get(r);u>1?this.dataRefCount.set(r,u-1):(this.dataRefCount.delete(r),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,s,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=S){return Object(a.of)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&a.Si.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){a.ie.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return v(e.shape,t)}packedUnaryOp(e,t,n){const s=new O.f(e.shape,t),o=this.compileAndRun(s,[e],n);return Object(a.mf)().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Object(p.H)(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Object(a.of)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,x.a,e.dtype);const t=new x.i(e.shape,x.a),n=this.compileAndRun(t,[e]);return Object(a.mf)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&a.Si.isString(n[0])){const o=n.map((e=>a.Si.encodeString(e)));s=this.write(o,e,t)}else s=this.write(n,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,n){return Object(a.mf)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new y.a(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new f.a(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[C.getBatchDim(e.shape),...C.getRowsCols(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},s=[C.getBatchDim(t),...C.getRowsCols(t)],o=new g.a(s,n),i=[n],r=this.runWebGLProgram(o,[a],e.dtype,i,!0);return{dataId:r.dataId,shape:t,dtype:r.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:s,shape:r,dtype:u}=n;if(null!=t){const e=a.Si.sizeFromShape(r),n=t[0]*t[1]*4;a.Si.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const c=C.getShapeAs3D(r);let d;d=s?new i.a(c):new o.a(c);const l=[null!=t?t:m.d(c)];return{dtype:u,shape:r,dataId:this.runWebGLProgram(d,[{shape:c,dtype:u,dataId:e}],u,l,!0,t).dataId}}runWebGLProgram(e,t,n,s,o=!1,i){const r=this.makeTensorInfo(e.outputShape,n),u=this.texData.get(r.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===m.a.DENSE){const t=null!=i?i:m.d(e.outputShape);u.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===a.Si.sizeFromShape(r.shape))return u.values=a.Si.getTypedArrayFromDType(r.dtype,0),r;const c=[],d=t.map((t=>{if("complex64"===t.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&a.Si.sizeFromShape(t.shape)<=Object(a.of)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!C.isReshapeFree(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(r.dataId);const l={shape:r.shape,texData:u,isUniform:!1},p=h.c(e,d,l),f=this.getAndSaveBinary(p,(()=>h.a(this.gpgpu,e,d,l))),g=null!=this.activeTimers;let b;g&&(b=this.startTimer()),Object(a.of)().get("ENGINE_COMPILE_ONLY")||h.d(this.gpgpu,f,d,l,s),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),g&&(b=this.endTimer(b),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(b)}));const x=Object(a.of)().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){const e=a.Si.now();e-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Object(a.of)().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===o){const e=this.unpackTensor(r);return this.disposeIntermediateTensorInfo(r),e}return r}compileAndRun(e,t,n,a,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,a,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Object(a.of)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(a.Ei)((()=>{if(!Object(a.of)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Object(a.of)().getBool("DEBUG");Object(a.of)().set("DEBUG",!1);const t=this.abs(Object(a.Fh)(1e-8)).dataSync()[0];if(Object(a.of)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:s,values:o,texture:i,usage:r,isPacked:u}=t;if(null!=i)return;const l=null!=this.activeTimers;let h;l&&(h=a.Si.now());let p=t.texShape;if(null==p&&(p=C.getTextureShapeFromLogicalShape(n,u),t.texShape=p),null!=o){const e=C.getShapeAs3D(n);let i,r=p[1],f=p[0];const g=o instanceof Uint8Array||o instanceof Uint8ClampedArray;!u&&g||([r,f]=m.e(p[0],p[1])),i=u?new d.a(e,g):new c.a(e,g);const b=g?[f,r]:p,x=this.makeTensorInfo(b,s),O=this.texData.get(x.dataId);O.usage=g?m.c.PIXELS:m.c.UPLOAD,O.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),r,f,o);const y=[[f,r]],v=!0,I=this.runWebGLProgram(i,[x],s,y,v),S=this.texData.get(I.dataId);t.texShape=S.texShape,t.isPacked=S.isPacked,t.usage=S.usage,Object(a.of)().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(t.texture=S.texture,t.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(x),l&&(this.uploadWaitMs+=a.Si.now()-h)}else{const e=this.acquireTexture(p,r,s,u);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw Error("Unknown dtype "+t)}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*a.Si.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Object(a.Kg)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw C.logShaderSourceAndInfoLog(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),Error("Failed to compile fragment shader.");throw Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:s,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:r}=Object(h.b)(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=s,e.outShapeLocation=o,e.outShapeStridesLocation=i,e.outTexShapeLocation=r}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:i,channels:r}=e,u=Object(a.mf)().backend;if(!u.gpgpu.gl.isTexture(s))throw Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(s,t,n,o,i,r);return Object(a.mf)().makeTensorFromDataId(c,t,n,u)}}w.nextDataId=0},1226:function(e,t,n){"use strict";var a,s,o,i;n.d(t,"g",(function(){return r})),a=n(616),s=n(1030),o=n(1227),n.d(t,"f",(function(){return o.a})),i=n(1032),n.d(t,"a",(function(){return i.a})),n.d(t,"b",(function(){return i.b})),n.d(t,"c",(function(){return i.c})),n.d(t,"d",(function(){return i.d})),n.d(t,"e",(function(){return i.e})),n.d(t,"h",(function(){return i.f})),a.Xe.isBrowser()&&Object(a.qh)("webgl",(()=>new s.a),2);const r={forceHalfFloat:i.c}},1231:function(e,t,n){"use strict";n.d(t,"b",(function(){return s})),n.d(t,"a",(function(){return o}));var a=n(616);const s={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class o{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=a.ie.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}},1234:function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"b",(function(){return s}));class a{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,r=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=r-1-e.padInfo.top,d=u-1-e.padInfo.left,l=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float avgMultiplier = float(${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n            wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class s{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,o=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=d-1-e.padInfo.front,f=l-1-e.padInfo.top,g=h-1-e.padInfo.left,m=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${g});\n      const float avgMultiplier = float(${m});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},1945:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));class a{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T"+t));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>"v"+e)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}},1946:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));class a{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T"+t));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>"v"+e)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}},1950:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));class a{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:s,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const i="max"===t?">":"<",r=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${r};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}},1951:function(e,t,n){"use strict";var a,s,o;n.d(t,"a",(function(){return i})),a=n(616),s=n(698),o=n(651);class i{constructor(e,t,n,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,a.Si.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const r=e[e.length-1],u=Math.ceil(r/t);this.outputShape=e.slice(0,-1),u>1&&this.outputShape.push(u),i||this.variableNames.push("bestIndicesA");const c=this.outputShape,d=c.length,l=Object(o.a)(d),h=Object(s.a)("coords",d);let p,f;if(1===u){f=d+1;const e=Object(o.a)(f);p=`\n        ${e} sourceLocR = ${e}(${h.join()}, 0);\n        ++${h[d-1]};\n        ${e} sourceLocG = ${e}(${h.join()}, 0);\n        ++${h[d-2]};\n        ${e} sourceLocA = ${e}(${h.join()}, 0);\n        --${h[d-1]};\n        ${e} sourceLocB = ${e}(${h.join()}, 0);\n        --${h[d-2]};`}else f=d,p=`\n        ${l} sourceLocR = coords;\n        ++${h[d-1]};\n        ${l} sourceLocG = coords;\n        ++${h[d-2]};\n        ${l} sourceLocA = coords;\n        --${h[d-1]};\n        ${l} sourceLocB = coords;\n        --${h[d-2]};`;const g=["x","y","z","w","u","v"].slice(0,f),m="."+g[f-1],b=g.map((e=>"int "+e)),x=Object(s.a)("sourceLocR",f-1).concat("inIdx.r"),O=Object(s.a)("sourceLocG",f-1).concat("inIdx.g"),y=Object(s.a)("sourceLocB",f-1).concat("inIdx.b"),C=Object(s.a)("sourceLocA",f-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",I=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${O.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${C.join()})));`,S=`vec4(\n            getAChannel(${x.join()}),\n            hasNextCol ? getAChannel(${O.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,w=i?"":`\n      float getBestIndicesAChannel(${b.join()}) {\n        return getChannel(getBestIndicesA(${g.join()}),\n                                          vec2(${g.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${b.join()}) {\n        return getChannel(getA(${g.join()}),\n                               vec2(${g.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${h[d-1]} < ${c[d-1]-1};\n        bool hasNextRow = ${h[d-2]} < ${c[d-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},\n          sourceLocB${m}, sourceLocA${m}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${S};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${I}\n          vec4 candidate = ${S};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}},1964:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(616);class s{constructor(e,t,n,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],a.ie.assertAndGetBroadcastShape(e,t),a.ie.assertAndGetBroadcastShape(e,n);let r="vec4(0.0)";null!=s&&(a.ie.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=o&&(a.ie.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${r};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}},1965:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(616);class s{constructor(e,t,n,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],a.ie.assertAndGetBroadcastShape(e,t),a.ie.assertAndGetBroadcastShape(e,n);let r="0.0";null!=s&&(a.ie.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let u="1.0";null!=o&&(a.ie.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${r};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}},1976:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));class a{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}},1977:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));class a{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}},1979:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));class a{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}},683:function(e,t,n){"use strict";var a,s,o,i;n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return u})),a=n(616),s=n(665),o=n(698),i=n(651);const r="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class u{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a.ie.assertAndGetBroadcastShape(t,n);const u=this.outputShape.length;this.enableShapeUniforms=Object(s.e)(u);let c="";if(r)if(0===u||1===a.Si.sizeFromShape(this.outputShape))c="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(c=`\n          ${Object(i.a)(u)} coords = getOutputCoords();\n        `,1===u)this.enableShapeUniforms?c+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":c+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Object(o.a)("coords",u);this.enableShapeUniforms?c+=`\n            bool nextRowOutOfBounds =\n              (${e[u-2]} + 1) >= outShape[${u} - 2];\n            bool nextColOutOfBounds =\n              (${e[u-1]} + 1) >= outShape[${u} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:c+=`\n            bool nextRowOutOfBounds =\n              (${e[u-2]} + 1) >= ${this.outputShape[u-2]};\n            bool nextColOutOfBounds =\n              (${e[u-1]} + 1) >= ${this.outputShape[u-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${c}\n\n        setOutput(result);\n      }\n    `}}},710:function(e,t,n){"use strict";var a,s;n.d(t,"b",(function(){return o})),n.d(t,"a",(function(){return i})),a=n(616),s=n(665);const o="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class i{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=a.ie.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Object(s.e)(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}},825:function(e,t,n){"use strict";function a(e,t){i[e]=t}function s(e,t){if(!(e in i)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(Object(o.of)().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete i[e]}),!1),Object(o.of)().getBool("SOFTWARE_WEBGL_ENABLED")&&(r.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",r)||n.getContext("experimental-webgl",r):n.getContext("webgl2",r)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;i[e]=n}const n=i[e];return null==n||n.isContextLost()?(delete i[e],s(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),i[e])}n.d(t,"b",(function(){return a})),n.d(t,"a",(function(){return s}));var o=n(616);const i={},r={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0}}}]);