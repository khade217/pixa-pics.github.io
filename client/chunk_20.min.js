/*! For license information please see chunk_20.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{1007:function(t,e,n){"use strict";function a(t,e,n,a){const[s,o]=r.ie.computeOutAndReduceShapes(t,a),i=Object(r.Qi)(e,"int32"),c=r.Si.makeZerosTypedArray(r.Si.sizeFromShape(s),i),u=r.Si.sizeFromShape(o);for(let r=0;r<c.length;++r){const t=r*u;let e=1;for(let a=0;a<u;++a)e*=n[t+a];c[r]=e}return{outVals:c,outShape:s,outDtype:i}}var r,s,o;n.d(e,"b",(function(){return a})),n.d(e,"a",(function(){return i})),r=n(616),s=n(624),o=n(682);const i={kernelName:r.Bc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:c}=e,{axis:u,keepDims:l}=i;Object(s.a)(c,"prod");const h=c.shape.length,d=r.Si.parseAxisParam(u,c.shape),p=r.ie.getAxesPermutation(d,h);let f=d,m=c;const g=[];null!=p&&(m=Object(o.a)({inputs:{x:c},backend:n,attrs:{perm:p}}),g.push(m),f=r.ie.getInnerMostAxes(f.length,h));const k=n.data.get(m.dataId).values,{outVals:b,outShape:S,outDtype:I}=a(m.shape,m.dtype,k,f);let y=S;return l&&(y=r.ie.expandShapeToKeepDim(S,d)),g.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(y,I,b)}}},1008:function(t,e,n){"use strict";function a(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let a=e;a<t.length;a++)n[e-1]*=t[a];return n}function r(t,e,n,r,o,i,c,u){if(0===t.length)throw Error("paramsNestedSplits must be non empty");if(0===e[0].length)throw Error("Split tensors must not be scalars");if(function(t,e,n){t.forEach(((t,a)=>{if(t<0||t>=n){const r=s.Si.indexToLoc(a,e.length,s.Si.computeStrides(e)).join(",");throw Error(`indices[${r}] = ${t} is not in [0, ${n})`)}}))}(i,c,e[0][0]-1),0===r.length)throw Error("params.rank must be nonzero");const l=r[0],{outSplits:h,valueSlices:d,numValues:p}=function(t,e,n,a){const r=[];let s=0;const o=e.length-1+n.length,i=Array(o).fill(null).map((()=>[0]));!function(t,e){for(let n=0;n<t.length;++n){const a=t[n],r=n===t.length-1?e:t[n+1].length;if(0===a.length)throw Error("Ragged splits may not be empty");if(a[0]<0)throw Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw Error("Ragged splits must not point past values");for(let t=1;t<a.length;++t)if(a[t-1]>a[t])throw Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let u=0;u<e.length-1;++u){c*=e[u];const t=e[u+1];for(let e=1;e<c+1;++e)i[u].push(e*t)}for(let u=0;u<t.length;++u){let a=t[u],o=t[u]+1;for(let t=0;t<n.length;++t){const r=n[t],s=t+e.length-1;if(s>=0){const t=i[s],e=t[t.length-1]-r[a];for(let n=a;n<o;++n)i[s].push(r[n+1]+e)}a=r[a],o=r[o]}o!==a&&(r.push([a,o]),s+=o-a)}return{outSplits:i,valueSlices:r,numValues:s}}(i,c,t,l),f=function(t){const e=[];for(let n=0;n<t.length;++n){const a=t[n].length,r=s.Si.getArrayFromDType("int32",a);e.push(r),t[n].forEach(((t,e)=>r[e]=t))}return e}(h),m=function(t,e,n,r,o){const i=e.slice();i[0]=o;const c=s.Si.getArrayFromDType(n,s.Si.sizeFromShape(i)),u=t.length;return function(t,e,n,r,s,o){const i=a(e,2)[1],c=a(o,2)[1];let u=0;for(const a of n)for(let e=a[0];e<a[1];++e){for(let n=0;n<r;++n)s[u*c+n]=t[e*i+n];++u}}(t,e,r,0===u?0:u/e[0],c,i),[c,i]}(n,r,o,d,p);return[f,m[0],m[1]]}n.d(e,"a",(function(){return r}));var s=n(616)},1009:function(t,e,n){"use strict";function a(t,e,n,a,o,i,c){if(e.length>1)throw Error("starts must be a scalar or vector");if(o.length>1)throw Error("limits must be a scalar or vector");if(c.length>1)throw Error("deltas must be a scalar or vector");const u=0===e.length,l=0===o.length,h=0===c.length,d=[];u||d.push(e[0]),l||d.push(o[0]),h||d.push(c[0]);for(let r=1;r<d.length;++r)if(d[r]!==d[r-1])throw Error("starts, limits, and deltas must have the same shape");const p=0===d.length?1:d[0],f=r.Si.getArrayFromDType("int32",p+1);f[0]=0;for(let r=0;r<p;++r){const e=u?t[0]:t[r],n=l?a[0]:a[r],o=h?i[0]:i[r];if(0===o)throw Error("Requires delta != 0");let c;if(o>0&&n<e||o<0&&n>e)c=0;else if(c=Math.ceil(Math.abs((n-e)/o)),c>s)throw Error("Requires ((limit - start) / delta) <= "+s);f[r+1]=f[r]+c}const m=f[p],g=r.Si.getArrayFromDType(n,m);let k=0;for(let r=0;r<p;++r){const e=f[r+1]-f[r];let n=u?t[0]:t[r];const a=h?i[0]:i[r];for(let t=0;t<e;++t)g[k++]=n,n+=a}return[f,g]}n.d(e,"a",(function(){return a}));var r=n(616);const s=2147483647},1010:function(t,e,n){"use strict";function a(t,e,n){for(let a=0;a<n;a++)t[a]=e[a]}function r(t,e){const n=[];for(let a of t){if(a<0){if(!e)throw Error(`Dimension ${a} must be >= 0`);if(a<-1)throw Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function s(t,e,n,a,r,s,o,i,u,l){return new c(t,e,n,a,r,s,o,i,u,l).compute()}var o,i;n.d(e,"a",(function(){return s})),o=n(616),i=o.ie.RowPartitionType;class c{constructor(t,e,n,a,r,s,i,c,u,l){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=c,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=o.ie.getRowPartitionTypesHelper(l),this.raggedRank=o.ie.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===i.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===i.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case i.VALUE_ROWIDS:return c.getMaxWidthValueRowID(e);case i.ROW_SPLITS:return c.getMaxWidthRowSplit(e);default:throw Error("Cannot handle partition type "+i[this.getRowPartitionTypeByDimension(t-1)])}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let n=0;for(let a=0;a<e-1;++a){const e=t[a+1]-t[a];e>n&&(n=e)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let n=0,a=t[0],r=0;for(let s=1;s<e;++s){const e=t[s];e!==a&&(a=e,r=Math.max(s-n,r),n=s)}return Math.max(e-n,r)}tensorShapeFromTensor(t,e,n=!0){if(0===e.length){if(-1===t[0])return[];throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return r(t,n)}calculateOutputSize(t){const e=this.valuesShape,n=this.defaultValueShape;o.ie.validateDefaultValueShape(n,e);const a=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=o.ie.combineRaggedTensorToTensorShapes(this.raggedRank,a,e);r[0]<0&&(r[0]=t);for(let s=1;s<=this.raggedRank;++s)r[s]<0&&(r[s]=this.getMaxWidth(s));return r}calculateFirstParentOutputIndex(t,e,n){const a=Math.min(t,n),r=[];let s=0;for(let o=0;o<a;++o,s+=e)r.push(s);for(let o=a;o<t;++o)r.push(-1);return o.Si.assert(r.length===t,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(t,e,n,a){const r=t.length,s=[];for(let o=0;o<r-1;++o){const r=t[o+1]-t[o];let i=Math.min(a,r),c=e[o];-1===c&&(i=0);for(let t=0;t<i;++t)s.push(c),c+=n;for(let t=0;t<r-i;++t)s.push(-1)}if(r>0&&s.length!==t[r-1])throw Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,n,a){const r=t.length,s=[];if(0===r)return[];let o=0,i=t[0];if(i>=e.length)throw Error(`Got currentValueRowId=${i}, which is not less than ${e.length}`);let c=e[i];s.push(c);for(let u=1;u<r;++u){const r=t[u];if(r===i)c>=0&&(++o,o<a?c+=n:c=-1);else{if(o=0,i=r,r>=e.length)throw Error(`Got nextValueRowId=${r} which is not less than ${e.length}`);c=e[r]}s.push(c)}if(s.length!==t.length)throw Error("Invalid row ids.");return s}calculateOutputIndex(t,e,n,a){const r=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case i.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,e,n,a);case i.ROW_SPLITS:if(r.length-1>e.length)throw Error(`Row partition size is greater than output size: ${r.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(r,e,n,a);default:throw Error("Unsupported partition type: "+i[s])}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case i.FIRST_DIM_SIZE:return t[0];case i.VALUE_ROWIDS:throw Error("Cannot handle VALUE_ROWIDS in first dimension.");case i.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error("Cannot handle type "+i[e])}}compute(){if(this.rowPartitionValues[0].length<=0)throw Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),e=this.calculateOutputSize(t),n=Array(this.raggedRank+1);n[n.length-1]=1;for(let r=n.length-2;r>=0;--r)n[r]=n[r+1]*e[r+1];const a=r(e,!1),s=o.Si.getArrayFromDType(this.valuesDType,o.Si.sizeFromShape(a));if(n[0]*e[0]>0){let r=this.calculateFirstParentOutputIndex(t,n[0],e[0]);for(let t=1;t<=this.raggedRank;++t)r=this.calculateOutputIndex(t-1,r,n[t],e[t]);this.setOutput(this.raggedRank,r,s,a)}return[a,s]}setOutput(t,e,n,r){if(0===n.length)return;const s=this.values,i=n;let c=r.slice();c=c.slice(t+1);const u=o.Si.sizeFromShape(c),l=e.length;let h=this.defaultValue;if(h.length!==u&&1!==h.length){const t=this.defaultValueShape;Object(o.Ei)((()=>{const e=Object(o.wh)(h,t),n=Object(o.te)(e,c);h=n.dataSync()}))}let d=0,p=0,f=0;for(let o=0;o<=l;++o){let t=o<l?e[o]:-1;if(t!==f){if(p<f){const t=s.subarray(d*u);a(i.subarray(p*u),t,(f-p)*u)}if(o>=l){const e=n.length;t=Math.floor(e/u)}if(t>f)if(1===this.defaultValue.length)i.subarray(f*u,t*u).fill(this.defaultValue[0]),f=t;else for(;t>f;)a(i.slice(f*u),h,u),++f;t<0?(d=o+1,p=f):(d=o,p=f,f=p+1)}else++f}}}},1011:function(t,e,n){"use strict";function a(t,e,n,a){if(t===e||t<e&&n<0||e<t&&n>1)return r.Si.makeZerosTypedArray(0,a);const s=Math.abs(Math.ceil((e-t)/n)),o=r.Si.makeZerosTypedArray(s,a);e<t&&1===n&&(n=-1),o[0]=t;for(let r=1;r<o.length;r++)o[r]=o[r-1]+n;return o}n.d(e,"a",(function(){return a}));var r=n(616)},1012:function(t,e,n){"use strict";var a,r,s;n.d(e,"b",(function(){return o})),n.d(e,"a",(function(){return c})),a=n(616),r=n(697),s=n(631);const o=Object(r.a)((t=>1/Math.sqrt(t))),i=Object(s.b)(a.Wc,o),c={kernelName:a.Wc,backendName:"cpu",kernelFunc:i}},1213:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),n.d(e,"b",(function(){return o})),a=n(616),r=n(631);const s=Object(r.a)(a.Mc,(t=>Math.max(0,t))),o={kernelName:a.Mc,backendName:"cpu",kernelFunc:s}},1215:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),n.d(e,"b",(function(){return o})),a=n(616),r=n(631);const s=Object(r.a)(a.Nc,(t=>Math.min(Math.max(0,t),6))),o={kernelName:a.Nc,backendName:"cpu",kernelFunc:s}},1216:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n}=t,{x:a,alpha:r}=e;Object(s.a)([a,r],"prelu");const o=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,[u,l]=i(a.shape,r.shape,o,c,"float32");return n.makeTensorInfo(l,"float32",u)}var r,s,o;n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return c})),r=n(616),s=n(624),o=n(655);const i=Object(o.a)(((t,e)=>t<0?e*t:t)),c={kernelName:r.Ac,backendName:"cpu",kernelFunc:a}},1222:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n,attrs:a}=t,{logits:h}=e,{dim:d}=a,p=h.shape.length;let f=d;if(-1===f&&(f=p-1),f!==p-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${p} and dim was ${f}`);const m=r.Si.parseAxisParam([f],h.shape),g=Object(o.a)({inputs:{x:h},backend:n,attrs:{reductionIndices:m,keepDims:!1}}),k=r.ie.expandShapeToKeepDim(g.shape,m),b=Object(c.a)({inputs:{x:g},backend:n,attrs:{shape:k}}),S=Object(u.a)({inputs:{a:h,b},backend:n}),I=Object(s.a)({inputs:{x:S},backend:n}),y=Object(l.a)({inputs:{x:I},backend:n,attrs:{axis:m,keepDims:!1}}),w=Object(c.a)({inputs:{x:y},backend:n,attrs:{shape:k}}),v=Object(i.a)({inputs:{a:I,b:w},backend:n});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),v}var r,s,o,i,c,u,l;n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return h})),r=n(616),s=n(891),o=n(1221),i=n(895),c=n(666),u=n(822),l=n(824);const h={kernelName:r.hd,backendName:"cpu",kernelFunc:a}},1890:function(t,e,n){"use strict";var a,r,s;n.d(e,"a",(function(){return c})),a=n(616),r=n(655),s=n(663);const o=Object(r.a)(((t,e)=>Math.pow(t,e))),i=Object(s.a)(a.zc,o),c={kernelName:a.zc,backendName:"cpu",kernelFunc:i}},1891:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(1008);const s={kernelName:a.Dc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:a}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:c}=a,u=s.map((t=>n.data.get(t.dataId).values)),l=s.map((t=>t.shape)),h=n.data.get(o.dataId).values,d=n.data.get(i.dataId).values,[p,f,m]=Object(r.a)(u,l,h,o.shape,o.dtype,d,i.shape,c),g=p.map((t=>n.makeTensorInfo([t.length],"int32",t))),k=n.makeTensorInfo(m,o.dtype,f);return g.concat([k])}}},1892:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(1009);const s={kernelName:a.Ec,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:a,limits:s,deltas:o}=e,i=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,[l,h]=Object(r.a)(i,a.shape,a.dtype,c,s.shape,u,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([h.length],a.dtype,h)]}}},1893:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(1010);const s={kernelName:a.Fc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:a}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:c}=e,{rowPartitionTypes:u}=a,l=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(i.dataId).values,p=c.map((t=>n.data.get(t.dataId).values)),f=c.map((t=>t.shape)),[m,g]=Object(r.a)(l,s.shape,h,o.shape,o.dtype,d,i.shape,p,f,u);return n.makeTensorInfo(m,o.dtype,g)}}},1894:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(1011);const s={kernelName:a.Gc,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:a,stop:s,dtype:o,step:i}=n,c=Object(r.a)(a,s,i,o);return e.makeTensorInfo([c.length],o,c)}}},1895:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return o})),a=n(616),r=n(631);const s=Object(r.a)(a.Kc,(t=>1/t)),o={kernelName:a.Kc,backendName:"cpu",kernelFunc:s}},1896:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(624);const s={kernelName:a.Pc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:o}=e,{alignCorners:i,halfPixelCenters:c,size:u}=s;Object(r.a)(o,"resizeBilinear");const l=a.Si.computeStrides(o.shape),[h,d]=u,[p,f,m,g]=o.shape,k=n.data.get(o.dataId).values,b=new Float32Array(a.Si.sizeFromShape([p,h,d,g])),S=[i&&h>1?f-1:f,i&&d>1?m-1:m],I=[i&&h>1?h-1:h,i&&d>1?d-1:d];let y=0;const w=S[0]/I[0],v=S[1]/I[1];for(let a=0;a<p;a++)for(let t=0;t<h;t++){let e;e=c?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,s=Math.min(f-1,Math.ceil(e)),o=a*l[0]+n*l[1],i=a*l[0]+s*l[1];for(let t=0;t<d;t++){let e;e=c?v*(t+.5)-.5:v*t;const n=Math.max(0,Math.floor(e)),a=e-n,s=Math.min(m-1,Math.ceil(e)),u=o+n*l[2],h=i+n*l[2],d=o+s*l[2],p=i+s*l[2];for(let t=0;t<g;t++){const e=k[u+t],n=k[h+t],s=e+(k[d+t]-e)*a,o=s+(n+(k[p+t]-n)*a-s)*r;b[y++]=o}}}return n.makeTensorInfo([p,h,d,g],"float32",b)}}},1897:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(624);const s={kernelName:a.Qc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:o,dy:i}=e,{alignCorners:c}=s;Object(r.a)([i,o],"resizeBilinearGrad");const u=a.Si.computeStrides(o.shape),[l,h,d,p]=o.shape,[,f,m]=i.shape,g=new Float32Array(l*h*d*p),k=[c&&f>1?h-1:h,c&&m>1?d-1:d],b=[c&&f>1?f-1:f,c&&m>1?m-1:m],S=k[0]/b[0],I=k[1]/b[1],y=n.data.get(i.dataId).values;let w=0;for(let a=0;a<l;a++){const t=a*u[0];for(let e=0;e<f;e++){const n=e*S,a=Math.floor(n),r=Math.min(Math.ceil(n),h-1),s=t+a*u[1],o=t+r*u[1],i=n-a,c=1-i;for(let t=0;t<m;t++){const e=t*I,n=Math.floor(e),a=Math.min(Math.ceil(e),d-1),r=e-n,l=1-r,h=s+n*u[2],f=s+a*u[2],m=o+n*u[2],k=o+a*u[2],b=c*l,S=c*r,v=i*l,T=i*r;for(let t=0;t<p;t++){const e=y[w++];g[h+t]+=e*b,g[f+t]+=e*S,g[m+t]+=e*v,g[k+t]+=e*T}}}}return n.makeTensorInfo([l,d,h,p],"float32",g)}}},1898:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(624);const s={kernelName:a.Rc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:o}=e,{alignCorners:i,halfPixelCenters:c,size:u}=s;Object(r.a)(o,"resizeNearestNeighbor");const l=a.Si.computeStrides(o.shape),[h,d]=u,[p,f,m,g]=o.shape,k=n.data.get(o.dataId).values,b=new Float32Array(p*h*d*g),S=[i&&h>1?f-1:f,i&&d>1?m-1:m],I=[i&&h>1?h-1:h,i&&d>1?d-1:d],y=S[0]/I[0],w=S[1]/I[1];let v=0;for(let a=0;a<p;a++){const t=a*l[0];for(let e=0;e<h;e++){const n=c?y*(e+.5):y*e;let a=Math.min(f-1,i?Math.round(n):Math.floor(n));c&&(a=Math.max(0,a));const r=t+a*l[1];for(let t=0;t<d;t++){const e=c?w*(t+.5):w*t;let n=Math.min(m-1,i?Math.round(e):Math.floor(e));c&&(n=Math.max(0,n));const a=r+n*l[2];for(let t=0;t<g;t++){const e=k[a+t];b[v++]=e}}}}return n.makeTensorInfo([p,h,d,g],o.dtype,b)}}},1899:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(624);const s={kernelName:a.Sc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:o,dy:i}=e,{alignCorners:c}=s;Object(r.a)([i,o],"resizeNearestNeighborGrad");const u=a.Si.computeStrides(o.shape),l=a.Si.computeStrides(i.shape),[h,d,p,f]=o.shape,[,m,g]=i.shape,k=new Float32Array(h*d*p*f),b=n.data.get(i.dataId).values,S=[c&&m>1?d-1:d,c&&g>1?p-1:p],I=[c&&m>1?m-1:m,c&&g>1?g-1:g],y=S[0]/I[0],w=S[1]/I[1],v=1/y,T=1/w,M=2*Math.ceil(v)+2,N=2*Math.ceil(T)+2;for(let a=0;a<h;a++){const t=a*u[0];for(let e=0;e<d;e++){const n=t+e*u[1],a=Math.floor(Math.floor(e*v)-M/2);for(let r=0;r<p;r++){const s=n+r*u[2],o=Math.floor(Math.floor(r*T)-N/2);for(let n=0;n<f;n++){let i=0;for(let s=0;s<M;s++){const u=s+a;if(u<0||u>=m)continue;const h=t+u*l[1],f=u*y;if(e===Math.min(d-1,c?Math.round(f):Math.floor(f)))for(let t=0;t<N;t++){const e=t+o;if(e<0||e>=g)continue;const a=h+e*l[2],s=e*w;r===Math.min(p-1,c?Math.round(s):Math.floor(s))&&(i+=b[a+n])}}k[s+n]=i}}}}return n.makeTensorInfo(o.shape,o.dtype,k)}}},1900:function(t,e,n){"use strict";var a,r,s;n.d(e,"a",(function(){return o})),a=n(616),r=n(624),s=n(709);const o={kernelName:a.Tc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{x:i}=e,{dims:c}=o;Object(r.a)(i,"reverse");const u=i.shape.length,l=a.Si.parseAxisParam(c,i.shape);if(0===u)return Object(s.a)({inputs:{x:i},backend:n});const h=new a.Ed(i.shape,i.dtype),d=n.bufferSync(i);for(let a=0;a<h.size;a++){const t=h.indexToLoc(a),e=t.slice();l.forEach((t=>e[t]=i.shape[t]-1-e[t])),h.set(d.get(...e),...t)}return n.makeTensorInfo(h.shape,h.dtype,h.values)}}},1901:function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var a=n(616);const r={kernelName:a.Uc,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,c=n,u=a.Si.getTypedArrayFromDType(r.dtype,a.Si.sizeFromShape(r.shape)),[l,h,d,p]=r.shape,[f,m]=a.ie.getImageCenter(i,h,d),g=Math.sin(s),k=Math.cos(s),b=c.data.get(r.dataId).values;for(let a=0;a<l;a++){const t=a*d*h*p;for(let e=0;e<h;e++){const n=e*(d*p);for(let a=0;a<d;a++){const r=a*p;for(let s=0;s<p;s++){const i=[l,e,a,s],c=i[2],S=i[1];let I=(c-f)*k-(S-m)*g,y=(c-f)*g+(S-m)*k;I=Math.round(I+f),y=Math.round(y+m);let w=o;"number"!=typeof o&&(w=3===s?255:o[s]),I>=0&&I<d&&y>=0&&y<h&&(w=b[t+y*(d*p)+I*p+s]),u[t+n+r+s]=w}}}}return{dataId:c.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}}},1902:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return o})),a=n(616),r=n(631);const s=Object(r.a)(a.Vc,(t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1})),o={kernelName:a.Vc,backendName:"cpu",kernelFunc:s}},1903:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(821);const s={kernelName:a.Yc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:o,updates:i}=e,{shape:c}=s,{sliceRank:u,numUpdates:l,sliceSize:h,strides:d,outputSize:p}=a.ie.calculateShapes(i,o,c),f=n.bufferSync(o),m=n.bufferSync(i),g=Object(r.a)(f,m,c,p,h,l,u,d,0,!0);return n.makeTensorInfo(c,g.dtype,g.values)}}},1904:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return s})),a=n(616),r=n(624);const s={kernelName:a.ad,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:s,t:o,e:i}=e;Object(r.a)([s,o,i],"select");const c=s.shape.length,u=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,h=n.data.get(i.dataId).values,d=Object(a.Qi)(o.dtype,i.dtype),p=a.Si.makeZerosTypedArray(a.Si.sizeFromShape(o.shape),d);let f=0;const m=0===c||c>1||1===o.shape.length?1:a.Si.sizeFromShape(o.shape.slice(1));for(let a=0;a<u.length;a++)for(let t=0;t<m;t++)1===u[a]?p[f++]=l[a]:p[f++]=h[a];return n.makeTensorInfo(o.shape,d,p)}}},1905:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return c})),a=n(616),r=n(631);const s=a.ie.SELU_SCALEALPHA,o=a.ie.SELU_SCALE,i=Object(r.a)(a.bd,(t=>t>=0?o*t:s*(Math.exp(t)-1))),c={kernelName:a.bd,backendName:"cpu",kernelFunc:i}},1906:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return o})),a=n(616),r=n(631);const s=Object(r.a)(a.dd,(t=>t<0?-1:t>0?1:0)),o={kernelName:a.dd,backendName:"cpu",kernelFunc:s}},1907:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return o})),a=n(616),r=n(631);const s=Object(r.a)(a.ed,(t=>Math.sin(t))),o={kernelName:a.ed,backendName:"cpu",kernelFunc:s}},1908:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return o})),a=n(616),r=n(631);const s=Object(r.a)(a.fd,(t=>Math.sinh(t))),o={kernelName:a.fd,backendName:"cpu",kernelFunc:s}},1909:function(t,e,n){"use strict";var a,r;n.d(e,"a",(function(){return i})),a=n(616),r=n(631);const s=-13.942385152878742,o=Object(r.a)(a.id,(t=>{const e=t>-s,n=t<s,a=Math.exp(t);let r;return r=n?a:e?t:Math.log(1+a),r})),i={kernelName:a.id,backendName:"cpu",kernelFunc:o}},2267:function(t,e,n){"use strict";function a(t,e){let n=0,a=t.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),t[r]<e?n=r+1:a=r;return a}function r(t,e){let n=0,a=t.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),t[r]<=e?n=r+1:a=r;return a}var s=n(616);n.d(e,"a",(function(){return o}));const o={kernelName:s.Zc,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{sortedSequence:i,values:c}=e,{side:u}=o,l=function(t,e,n,o,i,c){const u=s.Si.getArrayFromDType("int32",n*i);for(let s=0;s<n;++s){const n=t.slice(s*o,(s+1)*o),l=s*i;for(let t=0;t<i;++t)u[l+t]="left"===c?a(n,e[t+l]):r(n,e[t+l])}return u}(n.data.get(i.dataId).values,n.data.get(c.dataId).values,i.shape[0],i.shape[1],c.shape[1],u);return n.makeTensorInfo(c.shape,"int32",l)}}},666:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n,attrs:a}=t,{x:s}=e,{shape:o}=a,i=r.Si.sizeFromShape(s.shape),c=r.Si.inferFromImplicitShape(o,i),u=r.Si.sizeFromShape(c);r.Si.assert(i===u,(()=>`The new shape (${c}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const t=l.complexTensorInfos.real,e=l.complexTensorInfos.imag;t.shape=c,e.shape=c}return{dataId:s.dataId,shape:c,dtype:s.dtype}}n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return s}));var r=n(616);const s={kernelName:r.Oc,backendName:"cpu",kernelFunc:a}},728:function(t,e,n){"use strict";function a(t,e,n,a,r){const o=s.Zh.isSliceContinous(a,e,n),i=s.Si.sizeFromShape(n),c=s.Si.computeStrides(a);if(o){const n=s.Zh.computeFlatOffset(e,c);return"string"===r?t.slice(n,n+i):t.subarray(n,n+i)}const u="string"===r?s.ie.fromUint8ToStringArray(t):t,l=Object(s.we)(a,r,u),h=Object(s.we)(n,r);for(let s=0;s<h.size;++s){const t=h.indexToLoc(s),n=t.map(((t,n)=>t+e[n]));h.set(l.get(...n),...t)}return"string"===r?s.ie.fromStringArrayToUint8(h.values):h.values}function r(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:c,size:u}=r;Object(o.a)(i,"slice");const[l,h]=s.Zh.parseSliceParams(i,c,u);s.Zh.assertParamsValid(i,l,h);const d=a(n.data.get(i.dataId).values,l,h,i.shape,i.dtype);return n.makeTensorInfo(h,i.dtype,d)}var s,o;n.d(e,"c",(function(){return a})),n.d(e,"a",(function(){return r})),n.d(e,"b",(function(){return i})),s=n(616),o=n(624);const i={kernelName:s.gd,backendName:"cpu",kernelFunc:r}},780:function(t,e,n){"use strict";function a(t){const{inputs:e,backend:n}=t,{input:a}=e,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}n.d(e,"a",(function(){return a})),n.d(e,"b",(function(){return r}));const r={kernelName:n(616).Ic,backendName:"cpu",kernelFunc:a}},821:function(t,e,n){"use strict";function a(t,e,n,a,s,o,i,c,u,l){const h=[a/s,s],d=t.values,p=e.values;if(0===a)return Object(r.we)(n,e.dtype);const f=u instanceof r.Ed?u:Object(r.we)(h,e.dtype);"string"==typeof u||"number"==typeof u?f.values.fill(u):"boolean"==typeof u&&f.values.fill(+u);for(let r=0;r<o;r++){const t=[];let o=0;for(let e=0;e<i;e++){const n=d[r*i+e];t.push(n),o+=n*c[e]}if(o<0||o>=a/s)throw Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<s;n++)l?f.values[o*s+n]+=p[r*s+n]:f.values[o*s+n]=0===e.rank?p[0]:p[r*s+n]}return f}n.d(e,"a",(function(){return a}));var r=n(616)},893:function(t,e,n){"use strict";var a,r,s;n.d(e,"c",(function(){return o})),n.d(e,"a",(function(){return i})),n.d(e,"b",(function(){return c})),a=n(616),r=n(697),s=n(631);const o=Object(r.a)((t=>1/(1+Math.exp(-t)))),i=Object(s.a)(a.cd,(t=>1/(1+Math.exp(-t)))),c={kernelName:a.cd,backendName:"cpu",kernelFunc:i}},895:function(t,e,n){"use strict";var a,r,s;n.d(e,"a",(function(){return i})),n.d(e,"b",(function(){return c})),a=n(616),r=n(655),s=n(663);const o=Object(r.a)(((t,e)=>t/e)),i=Object(s.a)(a.Jc,o),c={kernelName:a.Jc,backendName:"cpu",kernelFunc:i}}}]);