/*! For license information please see chunk_52.min.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{1756:function(t,e,i){"use strict";var s,r,n,a,l;i.d(e,"a",(function(){return o})),s=i(616),r=i(724),n=i(642),a=i(633),l=i(654);class o extends n.b{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?Object(r.b)():t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new a.e(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,i;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],i=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new a.e(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new a.e(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);i=t.padding[1]}this.padding=[e,i]}this.inputSpec=[new n.a({ndim:4})]}computeOutputShape(t){let e,i;return t=Object(l.a)(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,i=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,i]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,i=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,i,t[3]])}call(t,e){return Object(s.Ei)((()=>{return e=Object(l.b)(t),i=this.padding,n=this.dataFormat,Object(s.Ei)((()=>{if(4!==e.rank)throw new a.e("temporalPadding expects input tensor to be 4-D, but received a "+e.rank+"-D tensor.");if(null==i&&(i=[[1,1],[1,1]]),2!==i.length||2!==i[0].length||2!==i[1].length)throw new a.e("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=Object(r.b)()),"channelsLast"!==n&&"channelsFirst"!==n)throw new a.e(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===n?[[0,0],[0,0],i[0],i[1]]:[[0,0],i[0],i[1],[0,0]],s.Sg(e,t)}));var e,i,n}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}o.className="ZeroPadding2D",s.Lh.registerClass(o)},1757:function(t,e,i){"use strict";function s(t,e,i,s,r,l){return Object(n.Ei)((()=>{let c;Object(o.a)(r),Object(o.d)(l),Object(o.c)(s),null==i&&(i=[1,1]),null==s&&(s="valid"),null==r&&(r=Object(a.b)()),null==l&&(l="max"),t=Object(g.j)(t,r);const u="same"===s?"same":"valid";return c="max"===l?n.tg(t,e,i,u):n.fe(t,e,i,u),"channelsFirst"===r&&(c=n.Ji(c,[0,3,1,2])),c}))}function r(t,e,i,s,r,l){return Object(n.Ei)((()=>{let c;Object(o.a)(r),Object(o.d)(l),Object(o.c)(s),null==i&&(i=[1,1,1]),null==s&&(s="valid"),null==r&&(r=Object(a.b)()),null==l&&(l="max"),t=Object(g.k)(t,r);const u="same"===s?"same":"valid";return c="max"===l?n.ug(t,e,i,u):n.ge(t,e,i,u),"channelsFirst"===r&&(c=n.Ji(c,[0,4,1,2,3])),c}))}var n,a,l,o,c,u,h,p,d,g;i.d(e,"h",(function(){return f})),i.d(e,"a",(function(){return m})),i.d(e,"i",(function(){return j})),i.d(e,"b",(function(){return w})),i.d(e,"j",(function(){return y})),i.d(e,"c",(function(){return z})),i.d(e,"d",(function(){return I})),i.d(e,"f",(function(){return A})),i.d(e,"e",(function(){return R})),i.d(e,"g",(function(){return L})),n=i(616),a=i(724),l=i(659),o=i(691),c=i(642),u=i(633),h=i(888),p=i(648),d=i(654),g=i(984);class b extends c.b{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new u.e("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.poolSize));this.poolSize=t.poolSize}if(Object(p.b)(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new u.e("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.strides));this.strides=t.strides}Object(p.b)(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Object(o.c)(this.padding),this.inputSpec=[new c.a({ndim:3})]}computeOutputShape(t){t=Object(d.a)(t);const e=Object(h.a)(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Object(n.Ei)((()=>{this.invokeCallHook(t,e),t=l.i(Object(d.b)(t),2);const i=this.poolingFunction(Object(d.b)(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return n.ki(i,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class f extends b{constructor(t){super(t)}poolingFunction(t,e,i,r,n){return Object(o.a)(n),Object(o.c)(r),s(t,e,i,r,n,"max")}}f.className="MaxPooling1D",n.Lh.registerClass(f);class m extends b{constructor(t){super(t)}poolingFunction(t,e,i,r,n){return Object(o.a)(n),Object(o.c)(r),s(t,e,i,r,n,"avg")}}m.className="AveragePooling1D",n.Lh.registerClass(m);class O extends c.b{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new u.e("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+t.strides.length+".");this.strides=t.strides}else this.strides=[t.strides,t.strides];Object(p.b)(this.poolSize,"poolSize"),Object(p.b)(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Object(o.a)(this.dataFormat),Object(o.c)(this.padding),this.inputSpec=[new c.a({ndim:4})]}computeOutputShape(t){t=Object(d.a)(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Object(h.a)(e,this.poolSize[0],this.padding,this.strides[0]),i=Object(h.a)(i,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,i]:[t[0],e,i,t[3]]}call(t,e){return Object(n.Ei)((()=>(this.invokeCallHook(t,e),this.poolingFunction(Object(d.b)(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class j extends O{constructor(t){super(t)}poolingFunction(t,e,i,r,n){return Object(o.a)(n),Object(o.c)(r),s(t,e,i,r,n,"max")}}j.className="MaxPooling2D",n.Lh.registerClass(j);class w extends O{constructor(t){super(t)}poolingFunction(t,e,i,r,n){return Object(o.a)(n),Object(o.c)(r),s(t,e,i,r,n,"avg")}}w.className="AveragePooling2D",n.Lh.registerClass(w);class S extends c.b{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new u.e("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+t.strides.length+".");this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Object(p.b)(this.poolSize,"poolSize"),Object(p.b)(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Object(o.a)(this.dataFormat),Object(o.c)(this.padding),this.inputSpec=[new c.a({ndim:5})]}computeOutputShape(t){t=Object(d.a)(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Object(h.a)(e,this.poolSize[0],this.padding,this.strides[0]),i=Object(h.a)(i,this.poolSize[1],this.padding,this.strides[1]),s=Object(h.a)(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,i,s]:[t[0],e,i,s,t[4]]}call(t,e){return Object(n.Ei)((()=>(this.invokeCallHook(t,e),this.poolingFunction(Object(d.b)(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class y extends S{constructor(t){super(t)}poolingFunction(t,e,i,s,n){return Object(o.a)(n),Object(o.c)(s),r(t,e,i,s,n,"max")}}y.className="MaxPooling3D",n.Lh.registerClass(y);class z extends S{constructor(t){super(t)}poolingFunction(t,e,i,s,n){return Object(o.a)(n),Object(o.c)(s),r(t,e,i,s,n,"avg")}}z.className="AveragePooling3D",n.Lh.registerClass(z);class k extends c.b{constructor(t){super(t),this.inputSpec=[new c.a({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new u.c}}class I extends k{constructor(t){super(t||{})}call(t,e){return Object(n.Ei)((()=>{const e=Object(d.b)(t);return n.xg(e,1)}))}}I.className="GlobalAveragePooling1D",n.Lh.registerClass(I);class A extends k{constructor(t){super(t||{})}call(t,e){return Object(n.Ei)((()=>{const e=Object(d.b)(t);return n.sg(e,1)}))}}A.className="GlobalMaxPooling1D",n.Lh.registerClass(A);class C extends c.b{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Object(o.a)(this.dataFormat),this.inputSpec=[new c.a({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new u.c}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class R extends C{call(t,e){return Object(n.Ei)((()=>{const e=Object(d.b)(t);return"channelsLast"===this.dataFormat?n.xg(e,[1,2]):n.xg(e,[2,3])}))}}R.className="GlobalAveragePooling2D",n.Lh.registerClass(R);class L extends C{call(t,e){return Object(n.Ei)((()=>{const e=Object(d.b)(t);return"channelsLast"===this.dataFormat?n.sg(e,[1,2]):n.sg(e,[2,3])}))}}L.className="GlobalMaxPooling2D",n.Lh.registerClass(L)},1758:function(t,e,i){"use strict";var s,r,n,a,l,o,c,u,h,p;i.d(e,"b",(function(){return g})),i.d(e,"a",(function(){return b})),s=i(616),r=i(659),n=i(691),a=i(642),l=i(633),o=i(1204),c=i(648),u=i(654),h=i(749),p=i(818);class d extends a.b{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,i={}){const s=e.layer,r=Object(p.a)(s,i);delete e.layer;const n={layer:r};return Object.assign(n,e),new t(n)}}class g extends d{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=Object(u.a)(t)).length<3)throw new l.e("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(t));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=Object(u.a)(t))[0]].concat(t.slice(2)),i=this.layer.computeOutputShape(e),s=t[1];return[i[0],s].concat(i.slice(1))}call(t,e){return Object(s.Ei)((()=>(t=Object(u.b)(t),Object(h.k)(((t,i)=>[Object(u.b)(this.layer.call(t,e)),[]]),t,[],!1,null,null,!1,!0)[1])))}}g.className="TimeDistributed",s.Lh.registerClass(g);class b extends d{constructor(t){super(t);const e=t.layer.getConfig(),i={};i.className=t.layer.getClassName(),i.config=e,this.forwardLayer=Object(p.a)(i),e.goBackwards=!0!==e.goBackwards;const s={};var r;if(s.className=t.layer.getClassName(),s.config=e,this.backwardLayer=Object(p.a)(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,r=this.mergeMode,c.d(o.a,"BidirectionalMergeMode",r),t.weights)throw new l.c("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,i=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,i)),this.backwardLayer.setWeights(t.slice(i))}computeOutputShape(t){let e,i,s,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(s=r.slice(1),e=r[0]):e=r[0],"concat"===this.mergeMode?(e[e.length-1]*=2,i=[e]):i=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?i.concat(s).concat(s.slice()):[e].concat(s).concat(s.slice()):c.m(i)}apply(t,e){let i=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=Object(h.l)(t,i,s,this.numConstants);if(t=r.inputs,i=r.initialState,s=r.constants,Array.isArray(t)&&(i=t.slice(1),t=t[0]),(null==i||0===i.length)&&null==s)return super.apply(t,e);const n=[],o=[];if(null!=i){const t=i.length;if(t%2>0)throw new l.e("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=i,n.push(...i);const s=i.map((t=>new a.a({shape:t.shape})));this.forwardLayer.stateSpec=s.slice(0,t/2),this.backwardLayer.stateSpec=s.slice(t/2),o.push(...s)}if(null!=s)throw new l.c("Support for constants in Bidirectional layers is not implemented yet.");const c=n[0]instanceof a.d;for(const u of n)if(u instanceof a.d!==c)throw new l.e("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const i=[t].concat(n),s=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=s;const a=super.apply(i,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return Object(s.Ei)((()=>{const i=e.initialState;let n,a,l,o;if(null==i)n=this.forwardLayer.call(t,e),a=this.backwardLayer.call(t,e);else{const s=i.slice(0,i.length/2),r=i.slice(i.length/2);n=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),a=this.backwardLayer.call(t,Object.assign(e,{initialState:r}))}return this.returnState&&(Array.isArray(n)&&(l=n.slice(1).concat(a.slice(1))),n=n[0],a=a[0]),this.returnSequences&&(a=s.xh(a,1)),"concat"===this.mergeMode?o=r.e([n,a]):"sum"===this.mergeMode?o=s.Ud(n,a):"ave"===this.mergeMode?o=s.Gg(.5,s.Ud(n,a)):"mul"===this.mergeMode?o=s.Gg(n,a):null==this.mergeMode&&(o=[n,a]),this.returnState?null==this.mergeMode?o.concat(l):[o].concat(l):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Object(n.g)(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),Object(n.g)(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let i;if(Array.isArray(e)&&(e=e[0]),i=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(i)?i.concat(t).concat(t):[i].concat(t).concat(t)}return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const i=Object(p.a)(e.layer);if(delete e.layer,null!=e.numConstants)throw new l.c("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=e;return s.layer=i,new t(s)}}b.className="Bidirectional",s.Lh.registerClass(b)},1759:function(t,e,i){"use strict";var s,r,n,a;i.d(e,"a",(function(){return l})),s=i(642),r=i(616),n=i(654),a=i(659);class l extends s.b{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Object(r.Ei)((()=>("float32"!==(t=Object(n.b)(t)).dtype&&(t=a.c(t,"float32")),Object(r.Ud)(Object(r.Gg)(t,this.scale),this.offset))))}}l.className="Rescaling",r.Lh.registerClass(l)},1760:function(t,e,i){"use strict";var s,r,n,a;i.d(e,"a",(function(){return c})),s=i(616),r=i(654),n=i(642),a=i(659);const{resizeBilinear:l,cropAndResize:o}=s.Qf;class c extends n.b{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,i,n,l,c,u,h){return Object(s.Ei)((()=>{let p,d=!1;const g=[e/c,i/u,(n+e)/c,(l+i)/u],b=[];3===t.rank?(d=!0,p=Object(s.li)([t])):p=t;for(let t=0;t<p.shape[0];t++)b.push(g);const f=Object(s.ui)(b,[b.length,4]),m=Object(s.mh)(0,b.length,1,"int32"),O=o(p,f,m,[n,l],"nearest");return d?a.c(Object(r.b)(Object(s.Pi)(O)),h):a.c(O,h)}))}upsize(t,e,i,r){return Object(s.Ei)((()=>{const s=l(t,[e,i]);return a.c(s,r)}))}call(t,e){return Object(s.Ei)((()=>{const e=Object(r.b)(t),i=e.dtype,s=e.shape,n=s[s.length-3],a=s[s.length-2];let l=0;n!==this.height&&(l=Math.floor((n-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),l>=0&&o>=0?this.centerCrop(e,l,o,this.height,this.width,n,a,i):this.upsize(t,this.height,this.width,i)}))}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=Object(r.a)(t)).length-3,i=t.length-2;return t[e]=this.height,t[i]=this.width,t}}c.className="CenterCrop",s.Lh.registerClass(c)},1761:function(t,e,i){"use strict";var s,r,n,a;i.d(e,"a",(function(){return o})),s=i(616),r=i(642),n=i(633),a=i(654);const l=new Set(["bilinear","nearest"]);class o extends r.b{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!l.has(t.interpolation))throw new n.e(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){const e=(t=Object(a.a)(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Object(s.Ei)((()=>{const e=[this.height,this.width];if("bilinear"===this.interpolation)return s.Qf.resizeBilinear(t,e,!this.cropToAspectRatio);if("nearest"===this.interpolation)return s.Qf.resizeNearestNeighbor(t,e,!this.cropToAspectRatio);throw Error(`Interpolation is ${this.interpolation} but only ${[...l]} are supported`)}))}}o.className="Resizing",s.Lh.registerClass(o)},1762:function(t,e,i){"use strict";var s,r,n,a;i.d(e,"a",(function(){return o})),s=i(616),r=i(654),n=i(633),a=i(1763);const l=new Set(["bilinear","nearest"]);class o extends a.a{constructor(t){super(t);const{factor:e,interpolation:i="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new n.e(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new n.e("factor must have values larger than -1. Got: "+this.factor);if(this.widthUpper<this.widthLower)throw new n.e(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(i){if(!l.has(i))throw new n.e(`Invalid interpolation parameter: ${i} is not implemented`);this.interpolation=i}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=Object(r.a)(t))[2];return[this.imgHeight,-1,e]}call(t,e){return Object(s.Ei)((()=>{const e=Object(r.b)(t);this.imgHeight=e.shape[e.shape.length-3];const i=e.shape[e.shape.length-2];this.widthFactor=Object(s.kh)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let n=this.widthFactor.dataSync()[0]*i;n=Math.round(n);const a=[this.imgHeight,n];switch(this.interpolation){case"bilinear":return s.Qf.resizeBilinear(t,a);case"nearest":return s.Qf.resizeNearestNeighbor(t,a);default:throw Error(`Interpolation is ${this.interpolation}\n          but only ${[...l]} are supported`)}}))}}o.className="RandomWidth",s.Lh.registerClass(o)},2265:function(t,e,i){"use strict";var s=i(642),r=i(616),n=i(654),a=i(633),l=i(659);i.d(e,"a",(function(){return o}));class o extends s.b{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return null==(t=Object(n.a)(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return Object(r.Ei)((()=>{let i;if("int32"!==(t=Object(n.b)(t)).dtype&&(t=l.c(t,"int32")),void 0!==e.countWeights){if("count"!==this.outputMode)throw new a.e("countWeights is not used when outputMode !== count.\n              Received countWeights="+e.countWeights);i=Object(n.b)(e.countWeights)}const s=Object(r.sg)(t),o=Object(r.Ag)(t),c=Object(r.Mf)(this.numTokens,s).bufferSync().get(0),u=Object(r.Nf)(o,0).bufferSync().get(0);if(!c||!u)throw new a.e("Input values must be between 0 < values <= numTokens with numTokens="+this.numTokens);return function(t,e,i,s){let o=Object(n.b)(t);if("int32"!==o.dtype&&(o=l.c(o,"int32")),"int"===e)return o;const c=o.shape;if(0===o.rank&&(o=Object(r.tf)(o,-1)),"oneHot"===e&&1!==o.shape[o.shape.length-1]&&(o=Object(r.tf)(o,-1)),o.rank>2)throw new a.e(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${c} which would result in output rank ${o.rank}.`);const u=["multiHot","oneHot"].includes(e),h=o;let p;if(p=void 0!==s&&"count"===e?Object(r.Te)(h,s,i,u):Object(r.Te)(h,[],i,u),"tfIdf"!==e)return p;if(s)return Object(r.Gg)(p,s);throw new a.e("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,i)}))}}o.className="CategoryEncoding",r.Lh.registerClass(o)},749:function(t,e,i){"use strict";function s(t,e,i,s){function r(t){return null==t||Array.isArray(t)?t:[t]}if(Array.isArray(t)){if(null!=e||null!=i)throw new p.e("When inputs is an array, neither initialState or constants should be provided");null!=s&&(i=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}return{inputs:t,initialState:e=r(e),constants:i=r(i)}}function r(t,e,i,s=!1,r,n,l=!1,o=!1){return a.Ei((()=>{const c=e.shape.length;if(c<3)throw new p.e(`Input should be at least 3D, but is ${c}D.`);const u=[1,0].concat(f.e(2,c));if(e=a.Ji(e,u),null!=n)throw new p.c("The rnn() functoin of the deeplearn.js backend does not support constants yet.");l&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=a.xe(a.xe(r,"bool"),"float32")).rank===c-1&&(r=a.tf(r,-1)),r=a.Ji(r,u)),s&&(e=a.xh(e,0),null!=r&&(r=a.xh(r,0)));const h=[];let d,g=i;const b=e.shape[0],m=a.Pi(e);let O,j;null!=r&&(O=a.Pi(r));for(let e=0;e<b;++e){const i=m[e],s=a.Ei((()=>t(i,g)));if(null==r)d=s[0],g=s[1];else{const t=a.Ei((()=>{const t=O[e],i=a.pi(a.Pg(t),t);return{output:a.Ud(a.Gg(s[0],t),a.Gg(g[0],i)),newStates:g.map(((e,r)=>a.Ud(a.Gg(s[1][r],t),a.Gg(e,i))))}}));d=t.output,g=t.newStates}o&&h.push(d)}if(o){const t=1;j=a.li(h,t)}return[d,j,g]}))}function n(t){const{ones:e,rate:i,training:s=!1,count:r=1,dropoutFunc:n}=t,l=()=>null!=n?n(e(),i):o.g(e(),i),c=()=>o.m(l,e,s);return!r||r<=1?a.Xf(c().clone()):Array(r).fill(void 0).map(c).map((t=>a.Xf(t.clone())))}var a,l,o,c,u,h,p,d,g,b,f,m,O,j;i.d(e,"l",(function(){return s})),i.d(e,"k",(function(){return r})),i.d(e,"e",(function(){return w})),i.d(e,"f",(function(){return S})),i.d(e,"h",(function(){return y})),i.d(e,"g",(function(){return z})),i.d(e,"b",(function(){return k})),i.d(e,"a",(function(){return I})),i.d(e,"d",(function(){return A})),i.d(e,"c",(function(){return C})),i.d(e,"i",(function(){return R})),i.d(e,"j",(function(){return n})),a=i(616),l=i(887),o=i(659),c=i(691),u=i(725),h=i(642),p=i(633),d=i(700),g=i(708),b=i(648),f=i(723),m=i(654),O=i(817),j=i(818);class w extends h.b{constructor(t){let e;if(super(t),null==t.cell)throw new p.e("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new R({cells:t.cell}):t.cell,null==e.stateSize)throw new p.e("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new h.a({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return f.e(0,t).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Object(m.c)(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const i=e[0];let s;if(s=this.returnSequences?[t[0],t[1],i]:[t[0],i],this.returnState){const i=[];for(const s of e)i.push([t[0],s]);return[s].concat(i)}return s}computeMask(t,e){return a.Ei((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let i=0;i<t;++i)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new p.c("Constants support is not implemented in RNN yet.");Object(m.c)(t)&&(t=t[0]);const e=this.stateful?t[0]:null,i=t.slice(2);this.inputSpec[0]=new h.a({shape:[e,null,...i]});const s=[t[0]].concat(t.slice(2));let r;if(this.cell.build(s),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!a.Si.arraysEqual(this.stateSpec.map((t=>t.shape[t.shape.length-1])),r))throw new p.e(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is `+this.cell.stateSize)}else this.stateSpec=r.map((t=>new h.a({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t,e=!1){Object(a.Ei)((()=>{if(!this.stateful)throw new p.b("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new p.e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>a.aj([i,t]))):this.states_=[a.aj([i,this.cell.stateSize])];else if(null==t)a.bf(this.states_),null!=this.keptStates&&(a.bf(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>a.aj([i,t]))):this.states_[0]=a.aj([i,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new p.e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: `+t);!0===e?this.keptStates.push(this.states_.slice()):a.bf(this.states_);for(let e=0;e<this.states_.length;++e){const s=t[e],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,n=[i,r];if(!a.Si.arraysEqual(s.shape,n))throw new p.e(`State ${e} is incompatible with layer ${this.name}: expected shape=${n}, received shape=${s.shape}`);this.states_[e]=s}}this.states_=this.states_.map((t=>a.Xf(t.clone())))}))}apply(t,e){let i=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const n=s(t,i,r,this.numConstants);t=n.inputs,i=n.initialState,r=n.constants;let a=[],l=[];if(null!=i){e.initialState=i,a=a.concat(i),this.stateSpec=[];for(const t of i)this.stateSpec.push(new h.a({shape:t.shape}));l=l.concat(this.stateSpec)}if(null!=r&&(e.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof h.d){const i=[t].concat(a),s=this.inputSpec.concat(l),r=this.inputSpec;this.inputSpec=s;const n=super.apply(i,e);return this.inputSpec=r,n}return super.apply(t,e)}call(t,e){return Object(a.Ei)((()=>{const i=null==e?null:e.mask,s=null==e?null:e.training;let n=null==e?null:e.initialState;t=Object(m.b)(t),null==n&&(n=this.stateful?this.states_:this.getInitialState(t));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(n.length!==a)throw new p.e(`RNN Layer has ${a} state(s) but was passed `+n.length+" initial state(s).");this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:s},o=r(((t,e)=>{const i=this.cell.call([t].concat(e),l);return[i[0],i.slice(1)]}),t,n,this.goBackwards,i,null,this.unroll,this.returnSequences),c=o[0],u=o[1],h=o[2];this.stateful&&this.resetStates(h,s);const d=this.returnSequences?u:c;return this.returnState?[d].concat(h):d}))}getInitialState(t){return Object(a.Ei)((()=>{let e=a.aj(t.shape);return e=a.qi(e,[1,2]),e=o.i(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?o.t(e,[1,t]):e)):this.cell.stateSize>1?[o.t(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===w.className&&(e.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),t),e)}static fromConfig(t,e,i={}){const s=e.cell,r=Object(j.a)(s,i);return new t(Object.assign(e,{cell:r}))}}w.className="RNN",a.Lh.registerClass(w);class S extends h.b{}class y extends S{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Object(b.b)(this.units,"units"),this.activation=Object(l.b)(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Object(d.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Object(d.q)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Object(d.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Object(g.b)(t.kernelRegularizer),this.recurrentRegularizer=Object(g.b)(t.recurrentRegularizer),this.biasRegularizer=Object(g.b)(t.biasRegularizer),this.kernelConstraint=Object(u.e)(t.kernelConstraint),this.recurrentConstraint=Object(u.e)(t.recurrentConstraint),this.biasConstraint=Object(u.e)(t.biasConstraint),this.dropout=f.d([1,f.c([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=f.d([1,f.c([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Object(m.a)(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Object(a.Ei)((()=>{if(2!==t.length)throw new p.e(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let i=t[1];t=t[0];const s=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=n({ones:()=>a.Pg(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=n({ones:()=>a.Pg(i),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=this.recurrentDropoutMask;r=null!=l?o.f(a.Gg(t,l),this.kernel.read()):o.f(t,this.kernel.read()),null!=this.bias&&(r=o.b(r,this.bias.read())),null!=c&&(i=a.Gg(i,c));let u=a.Ud(r,o.f(i,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Object(l.c)(this.activation),useBias:this.useBias,kernelInitializer:Object(d.r)(this.kernelInitializer),recurrentInitializer:Object(d.r)(this.recurrentInitializer),biasInitializer:Object(d.r)(this.biasInitializer),kernelRegularizer:Object(g.e)(this.kernelRegularizer),recurrentRegularizer:Object(g.e)(this.recurrentRegularizer),biasRegularizer:Object(g.e)(this.biasRegularizer),activityRegularizer:Object(g.e)(this.activityRegularizer),kernelConstraint:Object(u.f)(this.kernelConstraint),recurrentConstraint:Object(u.f)(this.recurrentConstraint),biasConstraint:Object(u.f)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}y.className="SimpleRNNCell",a.Lh.registerClass(y);class z extends w{constructor(t){t.cell=new y(t),super(t)}call(t,e){return Object(a.Ei)((()=>{null!=this.cell.dropoutMask&&(a.bf(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(a.bf(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,s=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:s,initialState:r})}))}static fromConfig(t,e){return new t(e)}}z.className="SimpleRNN",a.Lh.registerClass(z);class k extends S{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new p.e("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Object(b.b)(this.units,"units"),this.activation=Object(l.b)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Object(l.b)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Object(d.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Object(d.q)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Object(d.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Object(g.b)(t.kernelRegularizer),this.recurrentRegularizer=Object(g.b)(t.recurrentRegularizer),this.biasRegularizer=Object(g.b)(t.biasRegularizer),this.kernelConstraint=Object(u.e)(t.kernelConstraint),this.recurrentConstraint=Object(u.e)(t.recurrentConstraint),this.biasConstraint=Object(u.e)(t.biasConstraint),this.dropout=f.d([1,f.c([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=f.d([1,f.c([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=Object(m.a)(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Object(a.Ei)((()=>{if(2!==t.length)throw new p.e("GRUCell expects 2 input Tensors (inputs, h, c), got "+t.length+".");const i=null!=e.training&&e.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=n({ones:()=>a.Pg(t),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=n({ones:()=>a.Pg(s),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,l=this.recurrentDropoutMask;let c,u,h;0<this.dropout&&this.dropout<1&&(t=a.Gg(t,r[0]));let d=o.f(t,this.kernel.read());this.useBias&&(d=o.b(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=a.Gg(s,l[0]));const g=this.recurrentKernel.read(),[b,f]=a.gi(g,[2*this.units,this.units],g.rank-1),m=o.f(s,b),[O,j,w]=a.gi(d,3,d.rank-1),[S,y]=a.gi(m,2,m.rank-1);c=this.recurrentActivation.apply(a.Ud(O,S)),u=this.recurrentActivation.apply(a.Ud(j,y));const z=o.f(a.Gg(u,s),f);h=this.activation.apply(a.Ud(w,z));const k=a.Ud(a.Gg(c,s),a.Gg(a.Ud(1,a.Jg(c)),h));return[k,k]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Object(l.c)(this.activation),recurrentActivation:Object(l.c)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Object(d.r)(this.kernelInitializer),recurrentInitializer:Object(d.r)(this.recurrentInitializer),biasInitializer:Object(d.r)(this.biasInitializer),kernelRegularizer:Object(g.e)(this.kernelRegularizer),recurrentRegularizer:Object(g.e)(this.recurrentRegularizer),biasRegularizer:Object(g.e)(this.biasRegularizer),activityRegularizer:Object(g.e)(this.activityRegularizer),kernelConstraint:Object(u.f)(this.kernelConstraint),recurrentConstraint:Object(u.f)(this.recurrentConstraint),biasConstraint:Object(u.f)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}k.className="GRUCell",a.Lh.registerClass(k);class I extends w{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new k(t),super(t)}call(t,e){return Object(a.Ei)((()=>{null!=this.cell.dropoutMask&&(a.bf(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(a.bf(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,s=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:s,initialState:r})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}I.className="GRU",a.Lh.registerClass(I);class A extends S{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Object(b.b)(this.units,"units"),this.activation=Object(l.b)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Object(l.b)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Object(d.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Object(d.q)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Object(d.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Object(g.b)(t.kernelRegularizer),this.recurrentRegularizer=Object(g.b)(t.recurrentRegularizer),this.biasRegularizer=Object(g.b)(t.biasRegularizer),this.kernelConstraint=Object(u.e)(t.kernelConstraint),this.recurrentConstraint=Object(u.e)(t.recurrentConstraint),this.biasConstraint=Object(u.e)(t.biasConstraint),this.dropout=f.d([1,f.c([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=f.d([1,f.c([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const i=(t=Object(m.a)(t))[t.length-1];let s;if(this.kernel=this.addWeight("kernel",[i,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,i=this.units;s=new((e=class extends d.g{apply(e,s){const r=t.apply([i]),n=(new d.j).apply([i]),a=t.apply([2*i]);return o.d(o.d(r,n),a)}}).className="CustomInit",e)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return Object(a.Ei)((()=>{const i=null!=e.training&&e.training;if(3!==t.length)throw new p.e("LSTMCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");let s=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=n({ones:()=>a.Pg(t),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=n({ones:()=>a.Pg(s),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=this.recurrentDropoutMask;let u,h,d,g;0<this.dropout&&this.dropout<1&&(t=a.Gg(t,l[0]));let b=o.f(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=a.Gg(s,c[0])),b=a.Ud(b,o.f(s,this.recurrentKernel.read())),this.useBias&&(b=o.b(b,this.bias.read()));const[f,m,O,j]=a.gi(b,4,b.rank-1);u=this.recurrentActivation.apply(f),h=this.recurrentActivation.apply(m),d=a.Ud(a.Gg(h,r),a.Gg(u,this.activation.apply(O))),g=this.recurrentActivation.apply(j);const w=a.Gg(g,this.activation.apply(d));return[w,w,d]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Object(l.c)(this.activation),recurrentActivation:Object(l.c)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Object(d.r)(this.kernelInitializer),recurrentInitializer:Object(d.r)(this.recurrentInitializer),biasInitializer:Object(d.r)(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Object(g.e)(this.kernelRegularizer),recurrentRegularizer:Object(g.e)(this.recurrentRegularizer),biasRegularizer:Object(g.e)(this.biasRegularizer),activityRegularizer:Object(g.e)(this.activityRegularizer),kernelConstraint:Object(u.f)(this.kernelConstraint),recurrentConstraint:Object(u.f)(this.recurrentConstraint),biasConstraint:Object(u.f)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}A.className="LSTMCell",a.Lh.registerClass(A);class C extends w{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new A(t),super(t)}call(t,e){return Object(a.Ei)((()=>{null!=this.cell.dropoutMask&&(a.bf(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(a.bf(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,s=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:i,training:s,initialState:r})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}C.className="LSTM",a.Lh.registerClass(C);class R extends S{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return Object(a.Ei)((()=>{let i=t.slice(1);const s=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?s.push(i.splice(0,t.stateSize.length)):s.push(i.splice(0,1));s.reverse();const r=[];let n;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];i=s[a],n=0===a?[t[0]].concat(i):[n[0]].concat(i),n=l.call(n,e),r.push(n.slice(1))}i=[];for(const t of r.slice().reverse())i.push(...t);return[n[0]].concat(i)}))}build(t){let e;Object(m.c)(t)&&(t=t[0]),this.cells.forEach(((i,s)=>{Object(c.g)("RNNCell_"+s,(()=>{i.build(t),e=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e,i={}){const s=[];for(const r of e.cells)s.push(Object(j.a)(r,i));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return Object(O.b)(t)}setWeights(t){const e=[];for(const i of this.cells){const s=i.weights.length,r=t.splice(s);for(let t=0;t<i.weights.length;++t)e.push([i.weights[t],r[t]])}Object(O.c)(e)}}R.className="StackedRNNCells",a.Lh.registerClass(R)},818:function(t,e,i){"use strict";function s(t,e={},i=!1){return Object(n.g)(t,r.Lh.SerializationMap.getMap().classNameMap,e,"layer",i)}var r,n;i.d(e,"a",(function(){return s})),r=i(616),n=i(648)}}]);